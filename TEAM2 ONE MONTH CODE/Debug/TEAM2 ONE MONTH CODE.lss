
TEAM2 ONE MONTH CODE.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000043e4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000060  00802000  000043e4  00004478  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000085  00802060  00802060  000044d8  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000044d8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004534  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000598  00000000  00000000  00004578  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ea0a  00000000  00000000  00004b10  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000027ae  00000000  00000000  0001351a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000b00f  00000000  00000000  00015cc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001a70  00000000  00000000  00020cd8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0002b0de  00000000  00000000  00022748  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005afb  00000000  00000000  0004d826  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004b8  00000000  00000000  00053328  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000bbd8  00000000  00000000  000537e0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	a7 c1       	rjmp	.+846    	; 0x350 <__ctors_end>
       2:	00 00       	nop
       4:	cb c1       	rjmp	.+918    	; 0x39c <__bad_interrupt>
       6:	00 00       	nop
       8:	c9 c1       	rjmp	.+914    	; 0x39c <__bad_interrupt>
       a:	00 00       	nop
       c:	c7 c1       	rjmp	.+910    	; 0x39c <__bad_interrupt>
       e:	00 00       	nop
      10:	c5 c1       	rjmp	.+906    	; 0x39c <__bad_interrupt>
      12:	00 00       	nop
      14:	c3 c1       	rjmp	.+902    	; 0x39c <__bad_interrupt>
      16:	00 00       	nop
      18:	c1 c1       	rjmp	.+898    	; 0x39c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	bf c1       	rjmp	.+894    	; 0x39c <__bad_interrupt>
      1e:	00 00       	nop
      20:	bd c1       	rjmp	.+890    	; 0x39c <__bad_interrupt>
      22:	00 00       	nop
      24:	bb c1       	rjmp	.+886    	; 0x39c <__bad_interrupt>
      26:	00 00       	nop
      28:	ba c1       	rjmp	.+884    	; 0x39e <__vector_10>
      2a:	00 00       	nop
      2c:	db c1       	rjmp	.+950    	; 0x3e4 <__vector_11>
      2e:	00 00       	nop
      30:	b5 c1       	rjmp	.+874    	; 0x39c <__bad_interrupt>
      32:	00 00       	nop
      34:	b3 c1       	rjmp	.+870    	; 0x39c <__bad_interrupt>
      36:	00 00       	nop
      38:	59 c2       	rjmp	.+1202   	; 0x4ec <__vector_14>
      3a:	00 00       	nop
      3c:	8f c2       	rjmp	.+1310   	; 0x55c <__vector_15>
      3e:	00 00       	nop
      40:	c5 c2       	rjmp	.+1418   	; 0x5cc <__vector_16>
      42:	00 00       	nop
      44:	fb c2       	rjmp	.+1526   	; 0x63c <__vector_17>
      46:	00 00       	nop
      48:	31 c3       	rjmp	.+1634   	; 0x6ac <__vector_18>
      4a:	00 00       	nop
      4c:	67 c3       	rjmp	.+1742   	; 0x71c <__vector_19>
      4e:	00 00       	nop
      50:	9d c3       	rjmp	.+1850   	; 0x78c <__vector_20>
      52:	00 00       	nop
      54:	d3 c3       	rjmp	.+1958   	; 0x7fc <__vector_21>
      56:	00 00       	nop
      58:	09 c4       	rjmp	.+2066   	; 0x86c <__vector_22>
      5a:	00 00       	nop
      5c:	3f c4       	rjmp	.+2174   	; 0x8dc <__vector_23>
      5e:	00 00       	nop
      60:	9d c1       	rjmp	.+826    	; 0x39c <__bad_interrupt>
      62:	00 00       	nop
      64:	9b c1       	rjmp	.+822    	; 0x39c <__bad_interrupt>
      66:	00 00       	nop
      68:	99 c1       	rjmp	.+818    	; 0x39c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	97 c1       	rjmp	.+814    	; 0x39c <__bad_interrupt>
      6e:	00 00       	nop
      70:	95 c1       	rjmp	.+810    	; 0x39c <__bad_interrupt>
      72:	00 00       	nop
      74:	93 c1       	rjmp	.+806    	; 0x39c <__bad_interrupt>
      76:	00 00       	nop
      78:	91 c1       	rjmp	.+802    	; 0x39c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	8f c1       	rjmp	.+798    	; 0x39c <__bad_interrupt>
      7e:	00 00       	nop
      80:	8d c1       	rjmp	.+794    	; 0x39c <__bad_interrupt>
      82:	00 00       	nop
      84:	8b c1       	rjmp	.+790    	; 0x39c <__bad_interrupt>
      86:	00 00       	nop
      88:	89 c1       	rjmp	.+786    	; 0x39c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	87 c1       	rjmp	.+782    	; 0x39c <__bad_interrupt>
      8e:	00 00       	nop
      90:	85 c1       	rjmp	.+778    	; 0x39c <__bad_interrupt>
      92:	00 00       	nop
      94:	83 c1       	rjmp	.+774    	; 0x39c <__bad_interrupt>
      96:	00 00       	nop
      98:	81 c1       	rjmp	.+770    	; 0x39c <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 c7 0e 	jmp	0x1d8e	; 0x1d8e <__vector_39>
      a0:	0c 94 04 0f 	jmp	0x1e08	; 0x1e08 <__vector_40>
      a4:	0c 94 41 0f 	jmp	0x1e82	; 0x1e82 <__vector_41>
      a8:	0c 94 7e 0f 	jmp	0x1efc	; 0x1efc <__vector_42>
      ac:	77 c1       	rjmp	.+750    	; 0x39c <__bad_interrupt>
      ae:	00 00       	nop
      b0:	75 c1       	rjmp	.+746    	; 0x39c <__bad_interrupt>
      b2:	00 00       	nop
      b4:	73 c1       	rjmp	.+742    	; 0x39c <__bad_interrupt>
      b6:	00 00       	nop
      b8:	71 c1       	rjmp	.+738    	; 0x39c <__bad_interrupt>
      ba:	00 00       	nop
      bc:	77 c6       	rjmp	.+3310   	; 0xdac <__vector_47>
      be:	00 00       	nop
      c0:	ad c6       	rjmp	.+3418   	; 0xe1c <__vector_48>
      c2:	00 00       	nop
      c4:	e3 c6       	rjmp	.+3526   	; 0xe8c <__vector_49>
      c6:	00 00       	nop
      c8:	19 c7       	rjmp	.+3634   	; 0xefc <__vector_50>
      ca:	00 00       	nop
      cc:	4f c7       	rjmp	.+3742   	; 0xf6c <__vector_51>
      ce:	00 00       	nop
      d0:	85 c7       	rjmp	.+3850   	; 0xfdc <__vector_52>
      d2:	00 00       	nop
      d4:	bb c7       	rjmp	.+3958   	; 0x104c <__vector_53>
      d6:	00 00       	nop
      d8:	f1 c7       	rjmp	.+4066   	; 0x10bc <__vector_54>
      da:	00 00       	nop
      dc:	0c 94 96 08 	jmp	0x112c	; 0x112c <__vector_55>
      e0:	0c 94 ce 08 	jmp	0x119c	; 0x119c <__vector_56>
      e4:	5b c1       	rjmp	.+694    	; 0x39c <__bad_interrupt>
      e6:	00 00       	nop
      e8:	59 c1       	rjmp	.+690    	; 0x39c <__bad_interrupt>
      ea:	00 00       	nop
      ec:	57 c1       	rjmp	.+686    	; 0x39c <__bad_interrupt>
      ee:	00 00       	nop
      f0:	55 c1       	rjmp	.+682    	; 0x39c <__bad_interrupt>
      f2:	00 00       	nop
      f4:	53 c1       	rjmp	.+678    	; 0x39c <__bad_interrupt>
      f6:	00 00       	nop
      f8:	51 c1       	rjmp	.+674    	; 0x39c <__bad_interrupt>
      fa:	00 00       	nop
      fc:	4f c1       	rjmp	.+670    	; 0x39c <__bad_interrupt>
      fe:	00 00       	nop
     100:	4d c1       	rjmp	.+666    	; 0x39c <__bad_interrupt>
     102:	00 00       	nop
     104:	4b c1       	rjmp	.+662    	; 0x39c <__bad_interrupt>
     106:	00 00       	nop
     108:	49 c1       	rjmp	.+658    	; 0x39c <__bad_interrupt>
     10a:	00 00       	nop
     10c:	47 c1       	rjmp	.+654    	; 0x39c <__bad_interrupt>
     10e:	00 00       	nop
     110:	45 c1       	rjmp	.+650    	; 0x39c <__bad_interrupt>
     112:	00 00       	nop
     114:	43 c1       	rjmp	.+646    	; 0x39c <__bad_interrupt>
     116:	00 00       	nop
     118:	41 c1       	rjmp	.+642    	; 0x39c <__bad_interrupt>
     11a:	00 00       	nop
     11c:	0c 94 d3 0d 	jmp	0x1ba6	; 0x1ba6 <__vector_71>
     120:	0c 94 10 0e 	jmp	0x1c20	; 0x1c20 <__vector_72>
     124:	0c 94 4d 0e 	jmp	0x1c9a	; 0x1c9a <__vector_73>
     128:	0c 94 8a 0e 	jmp	0x1d14	; 0x1d14 <__vector_74>
     12c:	37 c1       	rjmp	.+622    	; 0x39c <__bad_interrupt>
     12e:	00 00       	nop
     130:	35 c1       	rjmp	.+618    	; 0x39c <__bad_interrupt>
     132:	00 00       	nop
     134:	0b c4       	rjmp	.+2070   	; 0x94c <__vector_77>
     136:	00 00       	nop
     138:	41 c4       	rjmp	.+2178   	; 0x9bc <__vector_78>
     13a:	00 00       	nop
     13c:	77 c4       	rjmp	.+2286   	; 0xa2c <__vector_79>
     13e:	00 00       	nop
     140:	ad c4       	rjmp	.+2394   	; 0xa9c <__vector_80>
     142:	00 00       	nop
     144:	e3 c4       	rjmp	.+2502   	; 0xb0c <__vector_81>
     146:	00 00       	nop
     148:	19 c5       	rjmp	.+2610   	; 0xb7c <__vector_82>
     14a:	00 00       	nop
     14c:	4f c5       	rjmp	.+2718   	; 0xbec <__vector_83>
     14e:	00 00       	nop
     150:	85 c5       	rjmp	.+2826   	; 0xc5c <__vector_84>
     152:	00 00       	nop
     154:	bb c5       	rjmp	.+2934   	; 0xccc <__vector_85>
     156:	00 00       	nop
     158:	f1 c5       	rjmp	.+3042   	; 0xd3c <__vector_86>
     15a:	00 00       	nop
     15c:	1f c1       	rjmp	.+574    	; 0x39c <__bad_interrupt>
     15e:	00 00       	nop
     160:	1d c1       	rjmp	.+570    	; 0x39c <__bad_interrupt>
     162:	00 00       	nop
     164:	1b c1       	rjmp	.+566    	; 0x39c <__bad_interrupt>
     166:	00 00       	nop
     168:	19 c1       	rjmp	.+562    	; 0x39c <__bad_interrupt>
     16a:	00 00       	nop
     16c:	17 c1       	rjmp	.+558    	; 0x39c <__bad_interrupt>
     16e:	00 00       	nop
     170:	15 c1       	rjmp	.+554    	; 0x39c <__bad_interrupt>
     172:	00 00       	nop
     174:	13 c1       	rjmp	.+550    	; 0x39c <__bad_interrupt>
     176:	00 00       	nop
     178:	11 c1       	rjmp	.+546    	; 0x39c <__bad_interrupt>
     17a:	00 00       	nop
     17c:	0f c1       	rjmp	.+542    	; 0x39c <__bad_interrupt>
     17e:	00 00       	nop
     180:	0d c1       	rjmp	.+538    	; 0x39c <__bad_interrupt>
     182:	00 00       	nop
     184:	0b c1       	rjmp	.+534    	; 0x39c <__bad_interrupt>
     186:	00 00       	nop
     188:	09 c1       	rjmp	.+530    	; 0x39c <__bad_interrupt>
     18a:	00 00       	nop
     18c:	07 c1       	rjmp	.+526    	; 0x39c <__bad_interrupt>
     18e:	00 00       	nop
     190:	05 c1       	rjmp	.+522    	; 0x39c <__bad_interrupt>
     192:	00 00       	nop
     194:	03 c1       	rjmp	.+518    	; 0x39c <__bad_interrupt>
     196:	00 00       	nop
     198:	01 c1       	rjmp	.+514    	; 0x39c <__bad_interrupt>
     19a:	00 00       	nop
     19c:	ff c0       	rjmp	.+510    	; 0x39c <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	fd c0       	rjmp	.+506    	; 0x39c <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	fb c0       	rjmp	.+502    	; 0x39c <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	f9 c0       	rjmp	.+498    	; 0x39c <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	f7 c0       	rjmp	.+494    	; 0x39c <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	0c 94 06 09 	jmp	0x120c	; 0x120c <__vector_108>
     1b4:	0c 94 3e 09 	jmp	0x127c	; 0x127c <__vector_109>
     1b8:	0c 94 76 09 	jmp	0x12ec	; 0x12ec <__vector_110>
     1bc:	0c 94 ae 09 	jmp	0x135c	; 0x135c <__vector_111>
     1c0:	0c 94 e6 09 	jmp	0x13cc	; 0x13cc <__vector_112>
     1c4:	0c 94 1e 0a 	jmp	0x143c	; 0x143c <__vector_113>
     1c8:	0c 94 56 0a 	jmp	0x14ac	; 0x14ac <__vector_114>
     1cc:	0c 94 8e 0a 	jmp	0x151c	; 0x151c <__vector_115>
     1d0:	0c 94 c6 0a 	jmp	0x158c	; 0x158c <__vector_116>
     1d4:	0c 94 fe 0a 	jmp	0x15fc	; 0x15fc <__vector_117>
     1d8:	e1 c0       	rjmp	.+450    	; 0x39c <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	df c0       	rjmp	.+446    	; 0x39c <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	dd c0       	rjmp	.+442    	; 0x39c <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	db c0       	rjmp	.+438    	; 0x39c <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	d9 c0       	rjmp	.+434    	; 0x39c <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	d7 c0       	rjmp	.+430    	; 0x39c <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	d5 c0       	rjmp	.+426    	; 0x39c <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	08 00       	.word	0x0008	; ????
     1f6:	00 00       	nop
     1f8:	be 92       	st	-X, r11
     1fa:	24 49       	sbci	r18, 0x94	; 148
     1fc:	12 3e       	cpi	r17, 0xE2	; 226
     1fe:	ab aa       	std	Y+51, r10	; 0x33
     200:	aa 2a       	or	r10, r26
     202:	be cd       	rjmp	.-1156   	; 0xfffffd80 <__eeprom_end+0xff7efd80>
     204:	cc cc       	rjmp	.-1640   	; 0xfffffb9e <__eeprom_end+0xff7efb9e>
     206:	4c 3e       	cpi	r20, 0xEC	; 236
     208:	00 00       	nop
     20a:	00 80       	ld	r0, Z
     20c:	be ab       	std	Y+54, r27	; 0x36
     20e:	aa aa       	std	Y+50, r10	; 0x32
     210:	aa 3e       	cpi	r26, 0xEA	; 234
     212:	00 00       	nop
     214:	00 00       	nop
     216:	bf 00       	.word	0x00bf	; ????
     218:	00 00       	nop
     21a:	80 3f       	cpi	r24, 0xF0	; 240
     21c:	00 00       	nop
     21e:	00 00       	nop
     220:	00 08       	sbc	r0, r0
     222:	41 78       	andi	r20, 0x81	; 129
     224:	d3 bb       	out	0x13, r29	; 19
     226:	43 87       	std	Z+11, r20	; 0x0b
     228:	d1 13       	cpse	r29, r17
     22a:	3d 19       	sub	r19, r13
     22c:	0e 3c       	cpi	r16, 0xCE	; 206
     22e:	c3 bd       	out	0x23, r28	; 35
     230:	42 82       	std	Z+2, r4	; 0x02
     232:	ad 2b       	or	r26, r29
     234:	3e 68       	ori	r19, 0x8E	; 142
     236:	ec 82       	std	Y+4, r14	; 0x04
     238:	76 be       	out	0x36, r7	; 54
     23a:	d9 8f       	std	Y+25, r29	; 0x19
     23c:	e1 a9       	ldd	r30, Z+49	; 0x31
     23e:	3e 4c       	sbci	r19, 0xCE	; 206
     240:	80 ef       	ldi	r24, 0xF0	; 240
     242:	ff be       	out	0x3f, r15	; 63
     244:	01 c4       	rjmp	.+2050   	; 0xa48 <__vector_79+0x1c>
     246:	ff 7f       	andi	r31, 0xFF	; 255
     248:	3f 00       	.word	0x003f	; ????
     24a:	00 00       	nop
	...

0000024e <__trampolines_end>:
     24e:	6e 61       	ori	r22, 0x1E	; 30
     250:	6e 00       	.word	0x006e	; ????

00000252 <__c.2240>:
     252:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     262:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     272:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     282:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     292:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     2a2:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     2b2:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     2c2:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     2d2:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     2e2:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     2f2:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     302:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     312:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     322:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     332:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     342:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000350 <__ctors_end>:
     350:	11 24       	eor	r1, r1
     352:	1f be       	out	0x3f, r1	; 63
     354:	cf ef       	ldi	r28, 0xFF	; 255
     356:	cd bf       	out	0x3d, r28	; 61
     358:	df e3       	ldi	r29, 0x3F	; 63
     35a:	de bf       	out	0x3e, r29	; 62
     35c:	00 e0       	ldi	r16, 0x00	; 0
     35e:	0c bf       	out	0x3c, r16	; 60
     360:	18 be       	out	0x38, r1	; 56
     362:	19 be       	out	0x39, r1	; 57
     364:	1a be       	out	0x3a, r1	; 58
     366:	1b be       	out	0x3b, r1	; 59

00000368 <__do_copy_data>:
     368:	10 e2       	ldi	r17, 0x20	; 32
     36a:	a0 e0       	ldi	r26, 0x00	; 0
     36c:	b0 e2       	ldi	r27, 0x20	; 32
     36e:	e4 ee       	ldi	r30, 0xE4	; 228
     370:	f3 e4       	ldi	r31, 0x43	; 67
     372:	00 e0       	ldi	r16, 0x00	; 0
     374:	0b bf       	out	0x3b, r16	; 59
     376:	02 c0       	rjmp	.+4      	; 0x37c <__do_copy_data+0x14>
     378:	07 90       	elpm	r0, Z+
     37a:	0d 92       	st	X+, r0
     37c:	a0 36       	cpi	r26, 0x60	; 96
     37e:	b1 07       	cpc	r27, r17
     380:	d9 f7       	brne	.-10     	; 0x378 <__do_copy_data+0x10>
     382:	1b be       	out	0x3b, r1	; 59

00000384 <__do_clear_bss>:
     384:	20 e2       	ldi	r18, 0x20	; 32
     386:	a0 e6       	ldi	r26, 0x60	; 96
     388:	b0 e2       	ldi	r27, 0x20	; 32
     38a:	01 c0       	rjmp	.+2      	; 0x38e <.do_clear_bss_start>

0000038c <.do_clear_bss_loop>:
     38c:	1d 92       	st	X+, r1

0000038e <.do_clear_bss_start>:
     38e:	a5 3e       	cpi	r26, 0xE5	; 229
     390:	b2 07       	cpc	r27, r18
     392:	e1 f7       	brne	.-8      	; 0x38c <.do_clear_bss_loop>
     394:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <main>
     398:	0c 94 f0 21 	jmp	0x43e0	; 0x43e0 <_exit>

0000039c <__bad_interrupt>:
     39c:	31 ce       	rjmp	.-926    	; 0x0 <__vectors>

0000039e <__vector_10>:
/**
 * \internal
 * \brief Overflow interrupt handling high counter
 */
ISR(RTC_OVF_vect)
{
     39e:	1f 92       	push	r1
     3a0:	0f 92       	push	r0
     3a2:	0f b6       	in	r0, 0x3f	; 63
     3a4:	0f 92       	push	r0
     3a6:	11 24       	eor	r1, r1
     3a8:	08 b6       	in	r0, 0x38	; 56
     3aa:	0f 92       	push	r0
     3ac:	18 be       	out	0x38, r1	; 56
     3ae:	0b b6       	in	r0, 0x3b	; 59
     3b0:	0f 92       	push	r0
     3b2:	1b be       	out	0x3b, r1	; 59
     3b4:	8f 93       	push	r24
     3b6:	9f 93       	push	r25
     3b8:	ef 93       	push	r30
     3ba:	ff 93       	push	r31
	rtc_data.counter_high++;
     3bc:	e6 eb       	ldi	r30, 0xB6	; 182
     3be:	f0 e2       	ldi	r31, 0x20	; 32
     3c0:	80 81       	ld	r24, Z
     3c2:	91 81       	ldd	r25, Z+1	; 0x01
     3c4:	01 96       	adiw	r24, 0x01	; 1
     3c6:	80 83       	st	Z, r24
     3c8:	91 83       	std	Z+1, r25	; 0x01
}
     3ca:	ff 91       	pop	r31
     3cc:	ef 91       	pop	r30
     3ce:	9f 91       	pop	r25
     3d0:	8f 91       	pop	r24
     3d2:	0f 90       	pop	r0
     3d4:	0b be       	out	0x3b, r0	; 59
     3d6:	0f 90       	pop	r0
     3d8:	08 be       	out	0x38, r0	; 56
     3da:	0f 90       	pop	r0
     3dc:	0f be       	out	0x3f, r0	; 63
     3de:	0f 90       	pop	r0
     3e0:	1f 90       	pop	r1
     3e2:	18 95       	reti

000003e4 <__vector_11>:
/**
 * \internal
 * \brief Compare interrupt used for alarm
 */
ISR(RTC_COMP_vect)
{
     3e4:	1f 92       	push	r1
     3e6:	0f 92       	push	r0
     3e8:	0f b6       	in	r0, 0x3f	; 63
     3ea:	0f 92       	push	r0
     3ec:	11 24       	eor	r1, r1
     3ee:	08 b6       	in	r0, 0x38	; 56
     3f0:	0f 92       	push	r0
     3f2:	18 be       	out	0x38, r1	; 56
     3f4:	09 b6       	in	r0, 0x39	; 57
     3f6:	0f 92       	push	r0
     3f8:	19 be       	out	0x39, r1	; 57
     3fa:	0b b6       	in	r0, 0x3b	; 59
     3fc:	0f 92       	push	r0
     3fe:	1b be       	out	0x3b, r1	; 59
     400:	cf 92       	push	r12
     402:	df 92       	push	r13
     404:	ef 92       	push	r14
     406:	ff 92       	push	r15
     408:	0f 93       	push	r16
     40a:	1f 93       	push	r17
     40c:	2f 93       	push	r18
     40e:	3f 93       	push	r19
     410:	4f 93       	push	r20
     412:	5f 93       	push	r21
     414:	6f 93       	push	r22
     416:	7f 93       	push	r23
     418:	8f 93       	push	r24
     41a:	9f 93       	push	r25
     41c:	af 93       	push	r26
     41e:	bf 93       	push	r27
     420:	ef 93       	push	r30
     422:	ff 93       	push	r31
	if (rtc_data.counter_high >= rtc_data.alarm_high) {
     424:	e6 eb       	ldi	r30, 0xB6	; 182
     426:	f0 e2       	ldi	r31, 0x20	; 32
     428:	80 81       	ld	r24, Z
     42a:	91 81       	ldd	r25, Z+1	; 0x01
     42c:	22 81       	ldd	r18, Z+2	; 0x02
     42e:	33 81       	ldd	r19, Z+3	; 0x03
     430:	82 17       	cp	r24, r18
     432:	93 07       	cpc	r25, r19
     434:	f0 f1       	brcs	.+124    	; 0x4b2 <__FUSE_REGION_LENGTH__+0xb2>
		RTC.INTCTRL = RTC_OVERFLOW_INT_LEVEL;
     436:	21 e0       	ldi	r18, 0x01	; 1
     438:	20 93 02 04 	sts	0x0402, r18	; 0x800402 <__TEXT_REGION_LENGTH__+0x700402>
		if (rtc_data.callback) {
     43c:	e0 91 bc 20 	lds	r30, 0x20BC	; 0x8020bc <rtc_data+0x6>
     440:	f0 91 bd 20 	lds	r31, 0x20BD	; 0x8020bd <rtc_data+0x7>
     444:	30 97       	sbiw	r30, 0x00	; 0
     446:	a9 f1       	breq	.+106    	; 0x4b2 <__FUSE_REGION_LENGTH__+0xb2>
			uint32_t count = ((uint32_t)rtc_data.counter_high << 16)
					| RTC.CNT;
     448:	60 91 08 04 	lds	r22, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
     44c:	70 91 09 04 	lds	r23, 0x0409	; 0x800409 <__TEXT_REGION_LENGTH__+0x700409>
ISR(RTC_COMP_vect)
{
	if (rtc_data.counter_high >= rtc_data.alarm_high) {
		RTC.INTCTRL = RTC_OVERFLOW_INT_LEVEL;
		if (rtc_data.callback) {
			uint32_t count = ((uint32_t)rtc_data.counter_high << 16)
     450:	a0 e0       	ldi	r26, 0x00	; 0
     452:	b0 e0       	ldi	r27, 0x00	; 0
     454:	dc 01       	movw	r26, r24
     456:	99 27       	eor	r25, r25
     458:	88 27       	eor	r24, r24
					| RTC.CNT;
     45a:	ab 01       	movw	r20, r22
     45c:	60 e0       	ldi	r22, 0x00	; 0
     45e:	70 e0       	ldi	r23, 0x00	; 0
ISR(RTC_COMP_vect)
{
	if (rtc_data.counter_high >= rtc_data.alarm_high) {
		RTC.INTCTRL = RTC_OVERFLOW_INT_LEVEL;
		if (rtc_data.callback) {
			uint32_t count = ((uint32_t)rtc_data.counter_high << 16)
     460:	8c 01       	movw	r16, r24
     462:	9d 01       	movw	r18, r26
     464:	04 2b       	or	r16, r20
     466:	15 2b       	or	r17, r21
     468:	26 2b       	or	r18, r22
     46a:	37 2b       	or	r19, r23
     46c:	c9 01       	movw	r24, r18
     46e:	b8 01       	movw	r22, r16
					| RTC.CNT;
			uint32_t alarm = ((uint32_t)rtc_data.alarm_high << 16)
     470:	a6 eb       	ldi	r26, 0xB6	; 182
     472:	b0 e2       	ldi	r27, 0x20	; 32
     474:	12 96       	adiw	r26, 0x02	; 2
     476:	0d 91       	ld	r16, X+
     478:	1c 91       	ld	r17, X
     47a:	13 97       	sbiw	r26, 0x03	; 3
     47c:	20 e0       	ldi	r18, 0x00	; 0
     47e:	30 e0       	ldi	r19, 0x00	; 0
     480:	98 01       	movw	r18, r16
     482:	11 27       	eor	r17, r17
     484:	00 27       	eor	r16, r16
					| rtc_data.alarm_low;
     486:	14 96       	adiw	r26, 0x04	; 4
     488:	cd 90       	ld	r12, X+
     48a:	dc 90       	ld	r13, X
     48c:	15 97       	sbiw	r26, 0x05	; 5
     48e:	e1 2c       	mov	r14, r1
     490:	f1 2c       	mov	r15, r1
	if (rtc_data.counter_high >= rtc_data.alarm_high) {
		RTC.INTCTRL = RTC_OVERFLOW_INT_LEVEL;
		if (rtc_data.callback) {
			uint32_t count = ((uint32_t)rtc_data.counter_high << 16)
					| RTC.CNT;
			uint32_t alarm = ((uint32_t)rtc_data.alarm_high << 16)
     492:	0c 29       	or	r16, r12
     494:	1d 29       	or	r17, r13
     496:	2e 29       	or	r18, r14
     498:	3f 29       	or	r19, r15
					| rtc_data.alarm_low;
			/* Workaround for errata. Count might not be updated
			 * when waking up from sleep, so in this case use alarm
			 * time plus one.
			 */
			if (alarm >= count)
     49a:	06 17       	cp	r16, r22
     49c:	17 07       	cpc	r17, r23
     49e:	28 07       	cpc	r18, r24
     4a0:	39 07       	cpc	r19, r25
     4a2:	30 f0       	brcs	.+12     	; 0x4b0 <__FUSE_REGION_LENGTH__+0xb0>
				count = alarm + 1;
     4a4:	c9 01       	movw	r24, r18
     4a6:	b8 01       	movw	r22, r16
     4a8:	6f 5f       	subi	r22, 0xFF	; 255
     4aa:	7f 4f       	sbci	r23, 0xFF	; 255
     4ac:	8f 4f       	sbci	r24, 0xFF	; 255
     4ae:	9f 4f       	sbci	r25, 0xFF	; 255
			rtc_data.callback(count);
     4b0:	19 95       	eicall
		}
	}
}
     4b2:	ff 91       	pop	r31
     4b4:	ef 91       	pop	r30
     4b6:	bf 91       	pop	r27
     4b8:	af 91       	pop	r26
     4ba:	9f 91       	pop	r25
     4bc:	8f 91       	pop	r24
     4be:	7f 91       	pop	r23
     4c0:	6f 91       	pop	r22
     4c2:	5f 91       	pop	r21
     4c4:	4f 91       	pop	r20
     4c6:	3f 91       	pop	r19
     4c8:	2f 91       	pop	r18
     4ca:	1f 91       	pop	r17
     4cc:	0f 91       	pop	r16
     4ce:	ff 90       	pop	r15
     4d0:	ef 90       	pop	r14
     4d2:	df 90       	pop	r13
     4d4:	cf 90       	pop	r12
     4d6:	0f 90       	pop	r0
     4d8:	0b be       	out	0x3b, r0	; 59
     4da:	0f 90       	pop	r0
     4dc:	09 be       	out	0x39, r0	; 57
     4de:	0f 90       	pop	r0
     4e0:	08 be       	out	0x38, r0	; 56
     4e2:	0f 90       	pop	r0
     4e4:	0f be       	out	0x3f, r0	; 63
     4e6:	0f 90       	pop	r0
     4e8:	1f 90       	pop	r1
     4ea:	18 95       	reti

000004ec <__vector_14>:
 *
 * This function will handle interrupt on Timer Counter CO overflow and
 * call the callback function.
 */
ISR(TCC0_OVF_vect)
{
     4ec:	1f 92       	push	r1
     4ee:	0f 92       	push	r0
     4f0:	0f b6       	in	r0, 0x3f	; 63
     4f2:	0f 92       	push	r0
     4f4:	11 24       	eor	r1, r1
     4f6:	08 b6       	in	r0, 0x38	; 56
     4f8:	0f 92       	push	r0
     4fa:	18 be       	out	0x38, r1	; 56
     4fc:	09 b6       	in	r0, 0x39	; 57
     4fe:	0f 92       	push	r0
     500:	19 be       	out	0x39, r1	; 57
     502:	0b b6       	in	r0, 0x3b	; 59
     504:	0f 92       	push	r0
     506:	1b be       	out	0x3b, r1	; 59
     508:	2f 93       	push	r18
     50a:	3f 93       	push	r19
     50c:	4f 93       	push	r20
     50e:	5f 93       	push	r21
     510:	6f 93       	push	r22
     512:	7f 93       	push	r23
     514:	8f 93       	push	r24
     516:	9f 93       	push	r25
     518:	af 93       	push	r26
     51a:	bf 93       	push	r27
     51c:	ef 93       	push	r30
     51e:	ff 93       	push	r31
	if (tc_tcc0_ovf_callback) {
     520:	e0 91 ae 20 	lds	r30, 0x20AE	; 0x8020ae <tc_tcc0_ovf_callback>
     524:	f0 91 af 20 	lds	r31, 0x20AF	; 0x8020af <tc_tcc0_ovf_callback+0x1>
     528:	30 97       	sbiw	r30, 0x00	; 0
     52a:	09 f0       	breq	.+2      	; 0x52e <__vector_14+0x42>
		tc_tcc0_ovf_callback();
     52c:	19 95       	eicall
	}
}
     52e:	ff 91       	pop	r31
     530:	ef 91       	pop	r30
     532:	bf 91       	pop	r27
     534:	af 91       	pop	r26
     536:	9f 91       	pop	r25
     538:	8f 91       	pop	r24
     53a:	7f 91       	pop	r23
     53c:	6f 91       	pop	r22
     53e:	5f 91       	pop	r21
     540:	4f 91       	pop	r20
     542:	3f 91       	pop	r19
     544:	2f 91       	pop	r18
     546:	0f 90       	pop	r0
     548:	0b be       	out	0x3b, r0	; 59
     54a:	0f 90       	pop	r0
     54c:	09 be       	out	0x39, r0	; 57
     54e:	0f 90       	pop	r0
     550:	08 be       	out	0x38, r0	; 56
     552:	0f 90       	pop	r0
     554:	0f be       	out	0x3f, r0	; 63
     556:	0f 90       	pop	r0
     558:	1f 90       	pop	r1
     55a:	18 95       	reti

0000055c <__vector_15>:
 *
 * This function will handle interrupt on Timer Counter CO error and
 * call the callback function.
 */
ISR(TCC0_ERR_vect)
{
     55c:	1f 92       	push	r1
     55e:	0f 92       	push	r0
     560:	0f b6       	in	r0, 0x3f	; 63
     562:	0f 92       	push	r0
     564:	11 24       	eor	r1, r1
     566:	08 b6       	in	r0, 0x38	; 56
     568:	0f 92       	push	r0
     56a:	18 be       	out	0x38, r1	; 56
     56c:	09 b6       	in	r0, 0x39	; 57
     56e:	0f 92       	push	r0
     570:	19 be       	out	0x39, r1	; 57
     572:	0b b6       	in	r0, 0x3b	; 59
     574:	0f 92       	push	r0
     576:	1b be       	out	0x3b, r1	; 59
     578:	2f 93       	push	r18
     57a:	3f 93       	push	r19
     57c:	4f 93       	push	r20
     57e:	5f 93       	push	r21
     580:	6f 93       	push	r22
     582:	7f 93       	push	r23
     584:	8f 93       	push	r24
     586:	9f 93       	push	r25
     588:	af 93       	push	r26
     58a:	bf 93       	push	r27
     58c:	ef 93       	push	r30
     58e:	ff 93       	push	r31
	if (tc_tcc0_err_callback) {
     590:	e0 91 ac 20 	lds	r30, 0x20AC	; 0x8020ac <tc_tcc0_err_callback>
     594:	f0 91 ad 20 	lds	r31, 0x20AD	; 0x8020ad <tc_tcc0_err_callback+0x1>
     598:	30 97       	sbiw	r30, 0x00	; 0
     59a:	09 f0       	breq	.+2      	; 0x59e <__vector_15+0x42>
		tc_tcc0_err_callback();
     59c:	19 95       	eicall
	}
}
     59e:	ff 91       	pop	r31
     5a0:	ef 91       	pop	r30
     5a2:	bf 91       	pop	r27
     5a4:	af 91       	pop	r26
     5a6:	9f 91       	pop	r25
     5a8:	8f 91       	pop	r24
     5aa:	7f 91       	pop	r23
     5ac:	6f 91       	pop	r22
     5ae:	5f 91       	pop	r21
     5b0:	4f 91       	pop	r20
     5b2:	3f 91       	pop	r19
     5b4:	2f 91       	pop	r18
     5b6:	0f 90       	pop	r0
     5b8:	0b be       	out	0x3b, r0	; 59
     5ba:	0f 90       	pop	r0
     5bc:	09 be       	out	0x39, r0	; 57
     5be:	0f 90       	pop	r0
     5c0:	08 be       	out	0x38, r0	; 56
     5c2:	0f 90       	pop	r0
     5c4:	0f be       	out	0x3f, r0	; 63
     5c6:	0f 90       	pop	r0
     5c8:	1f 90       	pop	r1
     5ca:	18 95       	reti

000005cc <__vector_16>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureA and
 * call the callback function.
 */
ISR(TCC0_CCA_vect)
{
     5cc:	1f 92       	push	r1
     5ce:	0f 92       	push	r0
     5d0:	0f b6       	in	r0, 0x3f	; 63
     5d2:	0f 92       	push	r0
     5d4:	11 24       	eor	r1, r1
     5d6:	08 b6       	in	r0, 0x38	; 56
     5d8:	0f 92       	push	r0
     5da:	18 be       	out	0x38, r1	; 56
     5dc:	09 b6       	in	r0, 0x39	; 57
     5de:	0f 92       	push	r0
     5e0:	19 be       	out	0x39, r1	; 57
     5e2:	0b b6       	in	r0, 0x3b	; 59
     5e4:	0f 92       	push	r0
     5e6:	1b be       	out	0x3b, r1	; 59
     5e8:	2f 93       	push	r18
     5ea:	3f 93       	push	r19
     5ec:	4f 93       	push	r20
     5ee:	5f 93       	push	r21
     5f0:	6f 93       	push	r22
     5f2:	7f 93       	push	r23
     5f4:	8f 93       	push	r24
     5f6:	9f 93       	push	r25
     5f8:	af 93       	push	r26
     5fa:	bf 93       	push	r27
     5fc:	ef 93       	push	r30
     5fe:	ff 93       	push	r31
	if (tc_tcc0_cca_callback) {
     600:	e0 91 aa 20 	lds	r30, 0x20AA	; 0x8020aa <tc_tcc0_cca_callback>
     604:	f0 91 ab 20 	lds	r31, 0x20AB	; 0x8020ab <tc_tcc0_cca_callback+0x1>
     608:	30 97       	sbiw	r30, 0x00	; 0
     60a:	09 f0       	breq	.+2      	; 0x60e <__vector_16+0x42>
		tc_tcc0_cca_callback();
     60c:	19 95       	eicall
	}
}
     60e:	ff 91       	pop	r31
     610:	ef 91       	pop	r30
     612:	bf 91       	pop	r27
     614:	af 91       	pop	r26
     616:	9f 91       	pop	r25
     618:	8f 91       	pop	r24
     61a:	7f 91       	pop	r23
     61c:	6f 91       	pop	r22
     61e:	5f 91       	pop	r21
     620:	4f 91       	pop	r20
     622:	3f 91       	pop	r19
     624:	2f 91       	pop	r18
     626:	0f 90       	pop	r0
     628:	0b be       	out	0x3b, r0	; 59
     62a:	0f 90       	pop	r0
     62c:	09 be       	out	0x39, r0	; 57
     62e:	0f 90       	pop	r0
     630:	08 be       	out	0x38, r0	; 56
     632:	0f 90       	pop	r0
     634:	0f be       	out	0x3f, r0	; 63
     636:	0f 90       	pop	r0
     638:	1f 90       	pop	r1
     63a:	18 95       	reti

0000063c <__vector_17>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureB and
 * call the callback function.
 */
ISR(TCC0_CCB_vect)
{
     63c:	1f 92       	push	r1
     63e:	0f 92       	push	r0
     640:	0f b6       	in	r0, 0x3f	; 63
     642:	0f 92       	push	r0
     644:	11 24       	eor	r1, r1
     646:	08 b6       	in	r0, 0x38	; 56
     648:	0f 92       	push	r0
     64a:	18 be       	out	0x38, r1	; 56
     64c:	09 b6       	in	r0, 0x39	; 57
     64e:	0f 92       	push	r0
     650:	19 be       	out	0x39, r1	; 57
     652:	0b b6       	in	r0, 0x3b	; 59
     654:	0f 92       	push	r0
     656:	1b be       	out	0x3b, r1	; 59
     658:	2f 93       	push	r18
     65a:	3f 93       	push	r19
     65c:	4f 93       	push	r20
     65e:	5f 93       	push	r21
     660:	6f 93       	push	r22
     662:	7f 93       	push	r23
     664:	8f 93       	push	r24
     666:	9f 93       	push	r25
     668:	af 93       	push	r26
     66a:	bf 93       	push	r27
     66c:	ef 93       	push	r30
     66e:	ff 93       	push	r31
	if (tc_tcc0_ccb_callback) {
     670:	e0 91 a8 20 	lds	r30, 0x20A8	; 0x8020a8 <tc_tcc0_ccb_callback>
     674:	f0 91 a9 20 	lds	r31, 0x20A9	; 0x8020a9 <tc_tcc0_ccb_callback+0x1>
     678:	30 97       	sbiw	r30, 0x00	; 0
     67a:	09 f0       	breq	.+2      	; 0x67e <__vector_17+0x42>
		tc_tcc0_ccb_callback();
     67c:	19 95       	eicall
	}
}
     67e:	ff 91       	pop	r31
     680:	ef 91       	pop	r30
     682:	bf 91       	pop	r27
     684:	af 91       	pop	r26
     686:	9f 91       	pop	r25
     688:	8f 91       	pop	r24
     68a:	7f 91       	pop	r23
     68c:	6f 91       	pop	r22
     68e:	5f 91       	pop	r21
     690:	4f 91       	pop	r20
     692:	3f 91       	pop	r19
     694:	2f 91       	pop	r18
     696:	0f 90       	pop	r0
     698:	0b be       	out	0x3b, r0	; 59
     69a:	0f 90       	pop	r0
     69c:	09 be       	out	0x39, r0	; 57
     69e:	0f 90       	pop	r0
     6a0:	08 be       	out	0x38, r0	; 56
     6a2:	0f 90       	pop	r0
     6a4:	0f be       	out	0x3f, r0	; 63
     6a6:	0f 90       	pop	r0
     6a8:	1f 90       	pop	r1
     6aa:	18 95       	reti

000006ac <__vector_18>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureC and
 * call the callback function.
 */
ISR(TCC0_CCC_vect)
{
     6ac:	1f 92       	push	r1
     6ae:	0f 92       	push	r0
     6b0:	0f b6       	in	r0, 0x3f	; 63
     6b2:	0f 92       	push	r0
     6b4:	11 24       	eor	r1, r1
     6b6:	08 b6       	in	r0, 0x38	; 56
     6b8:	0f 92       	push	r0
     6ba:	18 be       	out	0x38, r1	; 56
     6bc:	09 b6       	in	r0, 0x39	; 57
     6be:	0f 92       	push	r0
     6c0:	19 be       	out	0x39, r1	; 57
     6c2:	0b b6       	in	r0, 0x3b	; 59
     6c4:	0f 92       	push	r0
     6c6:	1b be       	out	0x3b, r1	; 59
     6c8:	2f 93       	push	r18
     6ca:	3f 93       	push	r19
     6cc:	4f 93       	push	r20
     6ce:	5f 93       	push	r21
     6d0:	6f 93       	push	r22
     6d2:	7f 93       	push	r23
     6d4:	8f 93       	push	r24
     6d6:	9f 93       	push	r25
     6d8:	af 93       	push	r26
     6da:	bf 93       	push	r27
     6dc:	ef 93       	push	r30
     6de:	ff 93       	push	r31
	if (tc_tcc0_ccc_callback) {
     6e0:	e0 91 a6 20 	lds	r30, 0x20A6	; 0x8020a6 <tc_tcc0_ccc_callback>
     6e4:	f0 91 a7 20 	lds	r31, 0x20A7	; 0x8020a7 <tc_tcc0_ccc_callback+0x1>
     6e8:	30 97       	sbiw	r30, 0x00	; 0
     6ea:	09 f0       	breq	.+2      	; 0x6ee <__vector_18+0x42>
		tc_tcc0_ccc_callback();
     6ec:	19 95       	eicall
	}
}
     6ee:	ff 91       	pop	r31
     6f0:	ef 91       	pop	r30
     6f2:	bf 91       	pop	r27
     6f4:	af 91       	pop	r26
     6f6:	9f 91       	pop	r25
     6f8:	8f 91       	pop	r24
     6fa:	7f 91       	pop	r23
     6fc:	6f 91       	pop	r22
     6fe:	5f 91       	pop	r21
     700:	4f 91       	pop	r20
     702:	3f 91       	pop	r19
     704:	2f 91       	pop	r18
     706:	0f 90       	pop	r0
     708:	0b be       	out	0x3b, r0	; 59
     70a:	0f 90       	pop	r0
     70c:	09 be       	out	0x39, r0	; 57
     70e:	0f 90       	pop	r0
     710:	08 be       	out	0x38, r0	; 56
     712:	0f 90       	pop	r0
     714:	0f be       	out	0x3f, r0	; 63
     716:	0f 90       	pop	r0
     718:	1f 90       	pop	r1
     71a:	18 95       	reti

0000071c <__vector_19>:
 *
 * This function will handle interrupt on Timer Counter CO Compare/CaptureD and
 * call the callback function.
 */
ISR(TCC0_CCD_vect)
{
     71c:	1f 92       	push	r1
     71e:	0f 92       	push	r0
     720:	0f b6       	in	r0, 0x3f	; 63
     722:	0f 92       	push	r0
     724:	11 24       	eor	r1, r1
     726:	08 b6       	in	r0, 0x38	; 56
     728:	0f 92       	push	r0
     72a:	18 be       	out	0x38, r1	; 56
     72c:	09 b6       	in	r0, 0x39	; 57
     72e:	0f 92       	push	r0
     730:	19 be       	out	0x39, r1	; 57
     732:	0b b6       	in	r0, 0x3b	; 59
     734:	0f 92       	push	r0
     736:	1b be       	out	0x3b, r1	; 59
     738:	2f 93       	push	r18
     73a:	3f 93       	push	r19
     73c:	4f 93       	push	r20
     73e:	5f 93       	push	r21
     740:	6f 93       	push	r22
     742:	7f 93       	push	r23
     744:	8f 93       	push	r24
     746:	9f 93       	push	r25
     748:	af 93       	push	r26
     74a:	bf 93       	push	r27
     74c:	ef 93       	push	r30
     74e:	ff 93       	push	r31
	if (tc_tcc0_ccd_callback) {
     750:	e0 91 a4 20 	lds	r30, 0x20A4	; 0x8020a4 <tc_tcc0_ccd_callback>
     754:	f0 91 a5 20 	lds	r31, 0x20A5	; 0x8020a5 <tc_tcc0_ccd_callback+0x1>
     758:	30 97       	sbiw	r30, 0x00	; 0
     75a:	09 f0       	breq	.+2      	; 0x75e <__vector_19+0x42>
		tc_tcc0_ccd_callback();
     75c:	19 95       	eicall
	}
}
     75e:	ff 91       	pop	r31
     760:	ef 91       	pop	r30
     762:	bf 91       	pop	r27
     764:	af 91       	pop	r26
     766:	9f 91       	pop	r25
     768:	8f 91       	pop	r24
     76a:	7f 91       	pop	r23
     76c:	6f 91       	pop	r22
     76e:	5f 91       	pop	r21
     770:	4f 91       	pop	r20
     772:	3f 91       	pop	r19
     774:	2f 91       	pop	r18
     776:	0f 90       	pop	r0
     778:	0b be       	out	0x3b, r0	; 59
     77a:	0f 90       	pop	r0
     77c:	09 be       	out	0x39, r0	; 57
     77e:	0f 90       	pop	r0
     780:	08 be       	out	0x38, r0	; 56
     782:	0f 90       	pop	r0
     784:	0f be       	out	0x3f, r0	; 63
     786:	0f 90       	pop	r0
     788:	1f 90       	pop	r1
     78a:	18 95       	reti

0000078c <__vector_20>:
 *
 * This function will handle interrupt on Timer Counter C1 overflow and
 * call the callback function.
 */
ISR(TCC1_OVF_vect)
{
     78c:	1f 92       	push	r1
     78e:	0f 92       	push	r0
     790:	0f b6       	in	r0, 0x3f	; 63
     792:	0f 92       	push	r0
     794:	11 24       	eor	r1, r1
     796:	08 b6       	in	r0, 0x38	; 56
     798:	0f 92       	push	r0
     79a:	18 be       	out	0x38, r1	; 56
     79c:	09 b6       	in	r0, 0x39	; 57
     79e:	0f 92       	push	r0
     7a0:	19 be       	out	0x39, r1	; 57
     7a2:	0b b6       	in	r0, 0x3b	; 59
     7a4:	0f 92       	push	r0
     7a6:	1b be       	out	0x3b, r1	; 59
     7a8:	2f 93       	push	r18
     7aa:	3f 93       	push	r19
     7ac:	4f 93       	push	r20
     7ae:	5f 93       	push	r21
     7b0:	6f 93       	push	r22
     7b2:	7f 93       	push	r23
     7b4:	8f 93       	push	r24
     7b6:	9f 93       	push	r25
     7b8:	af 93       	push	r26
     7ba:	bf 93       	push	r27
     7bc:	ef 93       	push	r30
     7be:	ff 93       	push	r31
	if (tc_tcc1_ovf_callback) {
     7c0:	e0 91 a2 20 	lds	r30, 0x20A2	; 0x8020a2 <tc_tcc1_ovf_callback>
     7c4:	f0 91 a3 20 	lds	r31, 0x20A3	; 0x8020a3 <tc_tcc1_ovf_callback+0x1>
     7c8:	30 97       	sbiw	r30, 0x00	; 0
     7ca:	09 f0       	breq	.+2      	; 0x7ce <__vector_20+0x42>
		tc_tcc1_ovf_callback();
     7cc:	19 95       	eicall
	}
}
     7ce:	ff 91       	pop	r31
     7d0:	ef 91       	pop	r30
     7d2:	bf 91       	pop	r27
     7d4:	af 91       	pop	r26
     7d6:	9f 91       	pop	r25
     7d8:	8f 91       	pop	r24
     7da:	7f 91       	pop	r23
     7dc:	6f 91       	pop	r22
     7de:	5f 91       	pop	r21
     7e0:	4f 91       	pop	r20
     7e2:	3f 91       	pop	r19
     7e4:	2f 91       	pop	r18
     7e6:	0f 90       	pop	r0
     7e8:	0b be       	out	0x3b, r0	; 59
     7ea:	0f 90       	pop	r0
     7ec:	09 be       	out	0x39, r0	; 57
     7ee:	0f 90       	pop	r0
     7f0:	08 be       	out	0x38, r0	; 56
     7f2:	0f 90       	pop	r0
     7f4:	0f be       	out	0x3f, r0	; 63
     7f6:	0f 90       	pop	r0
     7f8:	1f 90       	pop	r1
     7fa:	18 95       	reti

000007fc <__vector_21>:
 *
 * This function will handle interrupt on Timer Counter C1 error and
 * call the callback function.
 */
ISR(TCC1_ERR_vect)
{
     7fc:	1f 92       	push	r1
     7fe:	0f 92       	push	r0
     800:	0f b6       	in	r0, 0x3f	; 63
     802:	0f 92       	push	r0
     804:	11 24       	eor	r1, r1
     806:	08 b6       	in	r0, 0x38	; 56
     808:	0f 92       	push	r0
     80a:	18 be       	out	0x38, r1	; 56
     80c:	09 b6       	in	r0, 0x39	; 57
     80e:	0f 92       	push	r0
     810:	19 be       	out	0x39, r1	; 57
     812:	0b b6       	in	r0, 0x3b	; 59
     814:	0f 92       	push	r0
     816:	1b be       	out	0x3b, r1	; 59
     818:	2f 93       	push	r18
     81a:	3f 93       	push	r19
     81c:	4f 93       	push	r20
     81e:	5f 93       	push	r21
     820:	6f 93       	push	r22
     822:	7f 93       	push	r23
     824:	8f 93       	push	r24
     826:	9f 93       	push	r25
     828:	af 93       	push	r26
     82a:	bf 93       	push	r27
     82c:	ef 93       	push	r30
     82e:	ff 93       	push	r31
	if (tc_tcc1_err_callback) {
     830:	e0 91 a0 20 	lds	r30, 0x20A0	; 0x8020a0 <tc_tcc1_err_callback>
     834:	f0 91 a1 20 	lds	r31, 0x20A1	; 0x8020a1 <tc_tcc1_err_callback+0x1>
     838:	30 97       	sbiw	r30, 0x00	; 0
     83a:	09 f0       	breq	.+2      	; 0x83e <__vector_21+0x42>
		tc_tcc1_err_callback();
     83c:	19 95       	eicall
	}
}
     83e:	ff 91       	pop	r31
     840:	ef 91       	pop	r30
     842:	bf 91       	pop	r27
     844:	af 91       	pop	r26
     846:	9f 91       	pop	r25
     848:	8f 91       	pop	r24
     84a:	7f 91       	pop	r23
     84c:	6f 91       	pop	r22
     84e:	5f 91       	pop	r21
     850:	4f 91       	pop	r20
     852:	3f 91       	pop	r19
     854:	2f 91       	pop	r18
     856:	0f 90       	pop	r0
     858:	0b be       	out	0x3b, r0	; 59
     85a:	0f 90       	pop	r0
     85c:	09 be       	out	0x39, r0	; 57
     85e:	0f 90       	pop	r0
     860:	08 be       	out	0x38, r0	; 56
     862:	0f 90       	pop	r0
     864:	0f be       	out	0x3f, r0	; 63
     866:	0f 90       	pop	r0
     868:	1f 90       	pop	r1
     86a:	18 95       	reti

0000086c <__vector_22>:
 *
 * This function will handle interrupt on Timer Counter C1 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCC1_CCA_vect)
{
     86c:	1f 92       	push	r1
     86e:	0f 92       	push	r0
     870:	0f b6       	in	r0, 0x3f	; 63
     872:	0f 92       	push	r0
     874:	11 24       	eor	r1, r1
     876:	08 b6       	in	r0, 0x38	; 56
     878:	0f 92       	push	r0
     87a:	18 be       	out	0x38, r1	; 56
     87c:	09 b6       	in	r0, 0x39	; 57
     87e:	0f 92       	push	r0
     880:	19 be       	out	0x39, r1	; 57
     882:	0b b6       	in	r0, 0x3b	; 59
     884:	0f 92       	push	r0
     886:	1b be       	out	0x3b, r1	; 59
     888:	2f 93       	push	r18
     88a:	3f 93       	push	r19
     88c:	4f 93       	push	r20
     88e:	5f 93       	push	r21
     890:	6f 93       	push	r22
     892:	7f 93       	push	r23
     894:	8f 93       	push	r24
     896:	9f 93       	push	r25
     898:	af 93       	push	r26
     89a:	bf 93       	push	r27
     89c:	ef 93       	push	r30
     89e:	ff 93       	push	r31
	if (tc_tcc1_cca_callback) {
     8a0:	e0 91 9e 20 	lds	r30, 0x209E	; 0x80209e <tc_tcc1_cca_callback>
     8a4:	f0 91 9f 20 	lds	r31, 0x209F	; 0x80209f <tc_tcc1_cca_callback+0x1>
     8a8:	30 97       	sbiw	r30, 0x00	; 0
     8aa:	09 f0       	breq	.+2      	; 0x8ae <__vector_22+0x42>
		tc_tcc1_cca_callback();
     8ac:	19 95       	eicall
	}
}
     8ae:	ff 91       	pop	r31
     8b0:	ef 91       	pop	r30
     8b2:	bf 91       	pop	r27
     8b4:	af 91       	pop	r26
     8b6:	9f 91       	pop	r25
     8b8:	8f 91       	pop	r24
     8ba:	7f 91       	pop	r23
     8bc:	6f 91       	pop	r22
     8be:	5f 91       	pop	r21
     8c0:	4f 91       	pop	r20
     8c2:	3f 91       	pop	r19
     8c4:	2f 91       	pop	r18
     8c6:	0f 90       	pop	r0
     8c8:	0b be       	out	0x3b, r0	; 59
     8ca:	0f 90       	pop	r0
     8cc:	09 be       	out	0x39, r0	; 57
     8ce:	0f 90       	pop	r0
     8d0:	08 be       	out	0x38, r0	; 56
     8d2:	0f 90       	pop	r0
     8d4:	0f be       	out	0x3f, r0	; 63
     8d6:	0f 90       	pop	r0
     8d8:	1f 90       	pop	r1
     8da:	18 95       	reti

000008dc <__vector_23>:
 *
 * This function will handle interrupt on Timer Counter C1 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCC1_CCB_vect)
{
     8dc:	1f 92       	push	r1
     8de:	0f 92       	push	r0
     8e0:	0f b6       	in	r0, 0x3f	; 63
     8e2:	0f 92       	push	r0
     8e4:	11 24       	eor	r1, r1
     8e6:	08 b6       	in	r0, 0x38	; 56
     8e8:	0f 92       	push	r0
     8ea:	18 be       	out	0x38, r1	; 56
     8ec:	09 b6       	in	r0, 0x39	; 57
     8ee:	0f 92       	push	r0
     8f0:	19 be       	out	0x39, r1	; 57
     8f2:	0b b6       	in	r0, 0x3b	; 59
     8f4:	0f 92       	push	r0
     8f6:	1b be       	out	0x3b, r1	; 59
     8f8:	2f 93       	push	r18
     8fa:	3f 93       	push	r19
     8fc:	4f 93       	push	r20
     8fe:	5f 93       	push	r21
     900:	6f 93       	push	r22
     902:	7f 93       	push	r23
     904:	8f 93       	push	r24
     906:	9f 93       	push	r25
     908:	af 93       	push	r26
     90a:	bf 93       	push	r27
     90c:	ef 93       	push	r30
     90e:	ff 93       	push	r31
	if (tc_tcc1_ccb_callback) {
     910:	e0 91 9c 20 	lds	r30, 0x209C	; 0x80209c <tc_tcc1_ccb_callback>
     914:	f0 91 9d 20 	lds	r31, 0x209D	; 0x80209d <tc_tcc1_ccb_callback+0x1>
     918:	30 97       	sbiw	r30, 0x00	; 0
     91a:	09 f0       	breq	.+2      	; 0x91e <__vector_23+0x42>
		tc_tcc1_ccb_callback();
     91c:	19 95       	eicall
	}
}
     91e:	ff 91       	pop	r31
     920:	ef 91       	pop	r30
     922:	bf 91       	pop	r27
     924:	af 91       	pop	r26
     926:	9f 91       	pop	r25
     928:	8f 91       	pop	r24
     92a:	7f 91       	pop	r23
     92c:	6f 91       	pop	r22
     92e:	5f 91       	pop	r21
     930:	4f 91       	pop	r20
     932:	3f 91       	pop	r19
     934:	2f 91       	pop	r18
     936:	0f 90       	pop	r0
     938:	0b be       	out	0x3b, r0	; 59
     93a:	0f 90       	pop	r0
     93c:	09 be       	out	0x39, r0	; 57
     93e:	0f 90       	pop	r0
     940:	08 be       	out	0x38, r0	; 56
     942:	0f 90       	pop	r0
     944:	0f be       	out	0x3f, r0	; 63
     946:	0f 90       	pop	r0
     948:	1f 90       	pop	r1
     94a:	18 95       	reti

0000094c <__vector_77>:
 *
 * This function will handle interrupt on Timer Counter D0 overflow and
 * call the callback function.
 */
ISR(TCD0_OVF_vect)
{
     94c:	1f 92       	push	r1
     94e:	0f 92       	push	r0
     950:	0f b6       	in	r0, 0x3f	; 63
     952:	0f 92       	push	r0
     954:	11 24       	eor	r1, r1
     956:	08 b6       	in	r0, 0x38	; 56
     958:	0f 92       	push	r0
     95a:	18 be       	out	0x38, r1	; 56
     95c:	09 b6       	in	r0, 0x39	; 57
     95e:	0f 92       	push	r0
     960:	19 be       	out	0x39, r1	; 57
     962:	0b b6       	in	r0, 0x3b	; 59
     964:	0f 92       	push	r0
     966:	1b be       	out	0x3b, r1	; 59
     968:	2f 93       	push	r18
     96a:	3f 93       	push	r19
     96c:	4f 93       	push	r20
     96e:	5f 93       	push	r21
     970:	6f 93       	push	r22
     972:	7f 93       	push	r23
     974:	8f 93       	push	r24
     976:	9f 93       	push	r25
     978:	af 93       	push	r26
     97a:	bf 93       	push	r27
     97c:	ef 93       	push	r30
     97e:	ff 93       	push	r31
	if (tc_tcd0_ovf_callback) {
     980:	e0 91 9a 20 	lds	r30, 0x209A	; 0x80209a <tc_tcd0_ovf_callback>
     984:	f0 91 9b 20 	lds	r31, 0x209B	; 0x80209b <tc_tcd0_ovf_callback+0x1>
     988:	30 97       	sbiw	r30, 0x00	; 0
     98a:	09 f0       	breq	.+2      	; 0x98e <__vector_77+0x42>
		tc_tcd0_ovf_callback();
     98c:	19 95       	eicall
	}
}
     98e:	ff 91       	pop	r31
     990:	ef 91       	pop	r30
     992:	bf 91       	pop	r27
     994:	af 91       	pop	r26
     996:	9f 91       	pop	r25
     998:	8f 91       	pop	r24
     99a:	7f 91       	pop	r23
     99c:	6f 91       	pop	r22
     99e:	5f 91       	pop	r21
     9a0:	4f 91       	pop	r20
     9a2:	3f 91       	pop	r19
     9a4:	2f 91       	pop	r18
     9a6:	0f 90       	pop	r0
     9a8:	0b be       	out	0x3b, r0	; 59
     9aa:	0f 90       	pop	r0
     9ac:	09 be       	out	0x39, r0	; 57
     9ae:	0f 90       	pop	r0
     9b0:	08 be       	out	0x38, r0	; 56
     9b2:	0f 90       	pop	r0
     9b4:	0f be       	out	0x3f, r0	; 63
     9b6:	0f 90       	pop	r0
     9b8:	1f 90       	pop	r1
     9ba:	18 95       	reti

000009bc <__vector_78>:
 *
 * This function will handle interrupt on Timer Counter D0 error and
 * call the callback function.
 */
ISR(TCD0_ERR_vect)
{
     9bc:	1f 92       	push	r1
     9be:	0f 92       	push	r0
     9c0:	0f b6       	in	r0, 0x3f	; 63
     9c2:	0f 92       	push	r0
     9c4:	11 24       	eor	r1, r1
     9c6:	08 b6       	in	r0, 0x38	; 56
     9c8:	0f 92       	push	r0
     9ca:	18 be       	out	0x38, r1	; 56
     9cc:	09 b6       	in	r0, 0x39	; 57
     9ce:	0f 92       	push	r0
     9d0:	19 be       	out	0x39, r1	; 57
     9d2:	0b b6       	in	r0, 0x3b	; 59
     9d4:	0f 92       	push	r0
     9d6:	1b be       	out	0x3b, r1	; 59
     9d8:	2f 93       	push	r18
     9da:	3f 93       	push	r19
     9dc:	4f 93       	push	r20
     9de:	5f 93       	push	r21
     9e0:	6f 93       	push	r22
     9e2:	7f 93       	push	r23
     9e4:	8f 93       	push	r24
     9e6:	9f 93       	push	r25
     9e8:	af 93       	push	r26
     9ea:	bf 93       	push	r27
     9ec:	ef 93       	push	r30
     9ee:	ff 93       	push	r31
	if (tc_tcd0_err_callback) {
     9f0:	e0 91 98 20 	lds	r30, 0x2098	; 0x802098 <tc_tcd0_err_callback>
     9f4:	f0 91 99 20 	lds	r31, 0x2099	; 0x802099 <tc_tcd0_err_callback+0x1>
     9f8:	30 97       	sbiw	r30, 0x00	; 0
     9fa:	09 f0       	breq	.+2      	; 0x9fe <__vector_78+0x42>
		tc_tcd0_err_callback();
     9fc:	19 95       	eicall
	}
}
     9fe:	ff 91       	pop	r31
     a00:	ef 91       	pop	r30
     a02:	bf 91       	pop	r27
     a04:	af 91       	pop	r26
     a06:	9f 91       	pop	r25
     a08:	8f 91       	pop	r24
     a0a:	7f 91       	pop	r23
     a0c:	6f 91       	pop	r22
     a0e:	5f 91       	pop	r21
     a10:	4f 91       	pop	r20
     a12:	3f 91       	pop	r19
     a14:	2f 91       	pop	r18
     a16:	0f 90       	pop	r0
     a18:	0b be       	out	0x3b, r0	; 59
     a1a:	0f 90       	pop	r0
     a1c:	09 be       	out	0x39, r0	; 57
     a1e:	0f 90       	pop	r0
     a20:	08 be       	out	0x38, r0	; 56
     a22:	0f 90       	pop	r0
     a24:	0f be       	out	0x3f, r0	; 63
     a26:	0f 90       	pop	r0
     a28:	1f 90       	pop	r1
     a2a:	18 95       	reti

00000a2c <__vector_79>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCD0_CCA_vect)
{
     a2c:	1f 92       	push	r1
     a2e:	0f 92       	push	r0
     a30:	0f b6       	in	r0, 0x3f	; 63
     a32:	0f 92       	push	r0
     a34:	11 24       	eor	r1, r1
     a36:	08 b6       	in	r0, 0x38	; 56
     a38:	0f 92       	push	r0
     a3a:	18 be       	out	0x38, r1	; 56
     a3c:	09 b6       	in	r0, 0x39	; 57
     a3e:	0f 92       	push	r0
     a40:	19 be       	out	0x39, r1	; 57
     a42:	0b b6       	in	r0, 0x3b	; 59
     a44:	0f 92       	push	r0
     a46:	1b be       	out	0x3b, r1	; 59
     a48:	2f 93       	push	r18
     a4a:	3f 93       	push	r19
     a4c:	4f 93       	push	r20
     a4e:	5f 93       	push	r21
     a50:	6f 93       	push	r22
     a52:	7f 93       	push	r23
     a54:	8f 93       	push	r24
     a56:	9f 93       	push	r25
     a58:	af 93       	push	r26
     a5a:	bf 93       	push	r27
     a5c:	ef 93       	push	r30
     a5e:	ff 93       	push	r31
	if (tc_tcd0_cca_callback) {
     a60:	e0 91 96 20 	lds	r30, 0x2096	; 0x802096 <tc_tcd0_cca_callback>
     a64:	f0 91 97 20 	lds	r31, 0x2097	; 0x802097 <tc_tcd0_cca_callback+0x1>
     a68:	30 97       	sbiw	r30, 0x00	; 0
     a6a:	09 f0       	breq	.+2      	; 0xa6e <__vector_79+0x42>
		tc_tcd0_cca_callback();
     a6c:	19 95       	eicall
	}
}
     a6e:	ff 91       	pop	r31
     a70:	ef 91       	pop	r30
     a72:	bf 91       	pop	r27
     a74:	af 91       	pop	r26
     a76:	9f 91       	pop	r25
     a78:	8f 91       	pop	r24
     a7a:	7f 91       	pop	r23
     a7c:	6f 91       	pop	r22
     a7e:	5f 91       	pop	r21
     a80:	4f 91       	pop	r20
     a82:	3f 91       	pop	r19
     a84:	2f 91       	pop	r18
     a86:	0f 90       	pop	r0
     a88:	0b be       	out	0x3b, r0	; 59
     a8a:	0f 90       	pop	r0
     a8c:	09 be       	out	0x39, r0	; 57
     a8e:	0f 90       	pop	r0
     a90:	08 be       	out	0x38, r0	; 56
     a92:	0f 90       	pop	r0
     a94:	0f be       	out	0x3f, r0	; 63
     a96:	0f 90       	pop	r0
     a98:	1f 90       	pop	r1
     a9a:	18 95       	reti

00000a9c <__vector_80>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCD0_CCB_vect)
{
     a9c:	1f 92       	push	r1
     a9e:	0f 92       	push	r0
     aa0:	0f b6       	in	r0, 0x3f	; 63
     aa2:	0f 92       	push	r0
     aa4:	11 24       	eor	r1, r1
     aa6:	08 b6       	in	r0, 0x38	; 56
     aa8:	0f 92       	push	r0
     aaa:	18 be       	out	0x38, r1	; 56
     aac:	09 b6       	in	r0, 0x39	; 57
     aae:	0f 92       	push	r0
     ab0:	19 be       	out	0x39, r1	; 57
     ab2:	0b b6       	in	r0, 0x3b	; 59
     ab4:	0f 92       	push	r0
     ab6:	1b be       	out	0x3b, r1	; 59
     ab8:	2f 93       	push	r18
     aba:	3f 93       	push	r19
     abc:	4f 93       	push	r20
     abe:	5f 93       	push	r21
     ac0:	6f 93       	push	r22
     ac2:	7f 93       	push	r23
     ac4:	8f 93       	push	r24
     ac6:	9f 93       	push	r25
     ac8:	af 93       	push	r26
     aca:	bf 93       	push	r27
     acc:	ef 93       	push	r30
     ace:	ff 93       	push	r31
	if (tc_tcd0_ccb_callback) {
     ad0:	e0 91 94 20 	lds	r30, 0x2094	; 0x802094 <tc_tcd0_ccb_callback>
     ad4:	f0 91 95 20 	lds	r31, 0x2095	; 0x802095 <tc_tcd0_ccb_callback+0x1>
     ad8:	30 97       	sbiw	r30, 0x00	; 0
     ada:	09 f0       	breq	.+2      	; 0xade <__vector_80+0x42>
		tc_tcd0_ccb_callback();
     adc:	19 95       	eicall
	}
}
     ade:	ff 91       	pop	r31
     ae0:	ef 91       	pop	r30
     ae2:	bf 91       	pop	r27
     ae4:	af 91       	pop	r26
     ae6:	9f 91       	pop	r25
     ae8:	8f 91       	pop	r24
     aea:	7f 91       	pop	r23
     aec:	6f 91       	pop	r22
     aee:	5f 91       	pop	r21
     af0:	4f 91       	pop	r20
     af2:	3f 91       	pop	r19
     af4:	2f 91       	pop	r18
     af6:	0f 90       	pop	r0
     af8:	0b be       	out	0x3b, r0	; 59
     afa:	0f 90       	pop	r0
     afc:	09 be       	out	0x39, r0	; 57
     afe:	0f 90       	pop	r0
     b00:	08 be       	out	0x38, r0	; 56
     b02:	0f 90       	pop	r0
     b04:	0f be       	out	0x3f, r0	; 63
     b06:	0f 90       	pop	r0
     b08:	1f 90       	pop	r1
     b0a:	18 95       	reti

00000b0c <__vector_81>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureC and
 * call the callback function.
 */
ISR(TCD0_CCC_vect)
{
     b0c:	1f 92       	push	r1
     b0e:	0f 92       	push	r0
     b10:	0f b6       	in	r0, 0x3f	; 63
     b12:	0f 92       	push	r0
     b14:	11 24       	eor	r1, r1
     b16:	08 b6       	in	r0, 0x38	; 56
     b18:	0f 92       	push	r0
     b1a:	18 be       	out	0x38, r1	; 56
     b1c:	09 b6       	in	r0, 0x39	; 57
     b1e:	0f 92       	push	r0
     b20:	19 be       	out	0x39, r1	; 57
     b22:	0b b6       	in	r0, 0x3b	; 59
     b24:	0f 92       	push	r0
     b26:	1b be       	out	0x3b, r1	; 59
     b28:	2f 93       	push	r18
     b2a:	3f 93       	push	r19
     b2c:	4f 93       	push	r20
     b2e:	5f 93       	push	r21
     b30:	6f 93       	push	r22
     b32:	7f 93       	push	r23
     b34:	8f 93       	push	r24
     b36:	9f 93       	push	r25
     b38:	af 93       	push	r26
     b3a:	bf 93       	push	r27
     b3c:	ef 93       	push	r30
     b3e:	ff 93       	push	r31
	if (tc_tcd0_ccc_callback) {
     b40:	e0 91 92 20 	lds	r30, 0x2092	; 0x802092 <tc_tcd0_ccc_callback>
     b44:	f0 91 93 20 	lds	r31, 0x2093	; 0x802093 <tc_tcd0_ccc_callback+0x1>
     b48:	30 97       	sbiw	r30, 0x00	; 0
     b4a:	09 f0       	breq	.+2      	; 0xb4e <__vector_81+0x42>
		tc_tcd0_ccc_callback();
     b4c:	19 95       	eicall
	}
}
     b4e:	ff 91       	pop	r31
     b50:	ef 91       	pop	r30
     b52:	bf 91       	pop	r27
     b54:	af 91       	pop	r26
     b56:	9f 91       	pop	r25
     b58:	8f 91       	pop	r24
     b5a:	7f 91       	pop	r23
     b5c:	6f 91       	pop	r22
     b5e:	5f 91       	pop	r21
     b60:	4f 91       	pop	r20
     b62:	3f 91       	pop	r19
     b64:	2f 91       	pop	r18
     b66:	0f 90       	pop	r0
     b68:	0b be       	out	0x3b, r0	; 59
     b6a:	0f 90       	pop	r0
     b6c:	09 be       	out	0x39, r0	; 57
     b6e:	0f 90       	pop	r0
     b70:	08 be       	out	0x38, r0	; 56
     b72:	0f 90       	pop	r0
     b74:	0f be       	out	0x3f, r0	; 63
     b76:	0f 90       	pop	r0
     b78:	1f 90       	pop	r1
     b7a:	18 95       	reti

00000b7c <__vector_82>:
 *
 * This function will handle interrupt on Timer Counter D0 Compare/CaptureD and
 * call the callback function.
 */
ISR(TCD0_CCD_vect)
{
     b7c:	1f 92       	push	r1
     b7e:	0f 92       	push	r0
     b80:	0f b6       	in	r0, 0x3f	; 63
     b82:	0f 92       	push	r0
     b84:	11 24       	eor	r1, r1
     b86:	08 b6       	in	r0, 0x38	; 56
     b88:	0f 92       	push	r0
     b8a:	18 be       	out	0x38, r1	; 56
     b8c:	09 b6       	in	r0, 0x39	; 57
     b8e:	0f 92       	push	r0
     b90:	19 be       	out	0x39, r1	; 57
     b92:	0b b6       	in	r0, 0x3b	; 59
     b94:	0f 92       	push	r0
     b96:	1b be       	out	0x3b, r1	; 59
     b98:	2f 93       	push	r18
     b9a:	3f 93       	push	r19
     b9c:	4f 93       	push	r20
     b9e:	5f 93       	push	r21
     ba0:	6f 93       	push	r22
     ba2:	7f 93       	push	r23
     ba4:	8f 93       	push	r24
     ba6:	9f 93       	push	r25
     ba8:	af 93       	push	r26
     baa:	bf 93       	push	r27
     bac:	ef 93       	push	r30
     bae:	ff 93       	push	r31
	if (tc_tcd0_ccd_callback) {
     bb0:	e0 91 90 20 	lds	r30, 0x2090	; 0x802090 <tc_tcd0_ccd_callback>
     bb4:	f0 91 91 20 	lds	r31, 0x2091	; 0x802091 <tc_tcd0_ccd_callback+0x1>
     bb8:	30 97       	sbiw	r30, 0x00	; 0
     bba:	09 f0       	breq	.+2      	; 0xbbe <__vector_82+0x42>
		tc_tcd0_ccd_callback();
     bbc:	19 95       	eicall
	}
}
     bbe:	ff 91       	pop	r31
     bc0:	ef 91       	pop	r30
     bc2:	bf 91       	pop	r27
     bc4:	af 91       	pop	r26
     bc6:	9f 91       	pop	r25
     bc8:	8f 91       	pop	r24
     bca:	7f 91       	pop	r23
     bcc:	6f 91       	pop	r22
     bce:	5f 91       	pop	r21
     bd0:	4f 91       	pop	r20
     bd2:	3f 91       	pop	r19
     bd4:	2f 91       	pop	r18
     bd6:	0f 90       	pop	r0
     bd8:	0b be       	out	0x3b, r0	; 59
     bda:	0f 90       	pop	r0
     bdc:	09 be       	out	0x39, r0	; 57
     bde:	0f 90       	pop	r0
     be0:	08 be       	out	0x38, r0	; 56
     be2:	0f 90       	pop	r0
     be4:	0f be       	out	0x3f, r0	; 63
     be6:	0f 90       	pop	r0
     be8:	1f 90       	pop	r1
     bea:	18 95       	reti

00000bec <__vector_83>:
 *
 * This function will handle interrupt on Timer Counter D1 overflow and
 * call the callback function.
 */
ISR(TCD1_OVF_vect)
{
     bec:	1f 92       	push	r1
     bee:	0f 92       	push	r0
     bf0:	0f b6       	in	r0, 0x3f	; 63
     bf2:	0f 92       	push	r0
     bf4:	11 24       	eor	r1, r1
     bf6:	08 b6       	in	r0, 0x38	; 56
     bf8:	0f 92       	push	r0
     bfa:	18 be       	out	0x38, r1	; 56
     bfc:	09 b6       	in	r0, 0x39	; 57
     bfe:	0f 92       	push	r0
     c00:	19 be       	out	0x39, r1	; 57
     c02:	0b b6       	in	r0, 0x3b	; 59
     c04:	0f 92       	push	r0
     c06:	1b be       	out	0x3b, r1	; 59
     c08:	2f 93       	push	r18
     c0a:	3f 93       	push	r19
     c0c:	4f 93       	push	r20
     c0e:	5f 93       	push	r21
     c10:	6f 93       	push	r22
     c12:	7f 93       	push	r23
     c14:	8f 93       	push	r24
     c16:	9f 93       	push	r25
     c18:	af 93       	push	r26
     c1a:	bf 93       	push	r27
     c1c:	ef 93       	push	r30
     c1e:	ff 93       	push	r31
	if (tc_tcd1_ovf_callback) {
     c20:	e0 91 8e 20 	lds	r30, 0x208E	; 0x80208e <tc_tcd1_ovf_callback>
     c24:	f0 91 8f 20 	lds	r31, 0x208F	; 0x80208f <tc_tcd1_ovf_callback+0x1>
     c28:	30 97       	sbiw	r30, 0x00	; 0
     c2a:	09 f0       	breq	.+2      	; 0xc2e <__vector_83+0x42>
		tc_tcd1_ovf_callback();
     c2c:	19 95       	eicall
	}
}
     c2e:	ff 91       	pop	r31
     c30:	ef 91       	pop	r30
     c32:	bf 91       	pop	r27
     c34:	af 91       	pop	r26
     c36:	9f 91       	pop	r25
     c38:	8f 91       	pop	r24
     c3a:	7f 91       	pop	r23
     c3c:	6f 91       	pop	r22
     c3e:	5f 91       	pop	r21
     c40:	4f 91       	pop	r20
     c42:	3f 91       	pop	r19
     c44:	2f 91       	pop	r18
     c46:	0f 90       	pop	r0
     c48:	0b be       	out	0x3b, r0	; 59
     c4a:	0f 90       	pop	r0
     c4c:	09 be       	out	0x39, r0	; 57
     c4e:	0f 90       	pop	r0
     c50:	08 be       	out	0x38, r0	; 56
     c52:	0f 90       	pop	r0
     c54:	0f be       	out	0x3f, r0	; 63
     c56:	0f 90       	pop	r0
     c58:	1f 90       	pop	r1
     c5a:	18 95       	reti

00000c5c <__vector_84>:
 *
 * This function will handle interrupt on Timer Counter D1 error and
 * call the callback function.
 */
ISR(TCD1_ERR_vect)
{
     c5c:	1f 92       	push	r1
     c5e:	0f 92       	push	r0
     c60:	0f b6       	in	r0, 0x3f	; 63
     c62:	0f 92       	push	r0
     c64:	11 24       	eor	r1, r1
     c66:	08 b6       	in	r0, 0x38	; 56
     c68:	0f 92       	push	r0
     c6a:	18 be       	out	0x38, r1	; 56
     c6c:	09 b6       	in	r0, 0x39	; 57
     c6e:	0f 92       	push	r0
     c70:	19 be       	out	0x39, r1	; 57
     c72:	0b b6       	in	r0, 0x3b	; 59
     c74:	0f 92       	push	r0
     c76:	1b be       	out	0x3b, r1	; 59
     c78:	2f 93       	push	r18
     c7a:	3f 93       	push	r19
     c7c:	4f 93       	push	r20
     c7e:	5f 93       	push	r21
     c80:	6f 93       	push	r22
     c82:	7f 93       	push	r23
     c84:	8f 93       	push	r24
     c86:	9f 93       	push	r25
     c88:	af 93       	push	r26
     c8a:	bf 93       	push	r27
     c8c:	ef 93       	push	r30
     c8e:	ff 93       	push	r31
	if (tc_tcd1_err_callback) {
     c90:	e0 91 8c 20 	lds	r30, 0x208C	; 0x80208c <tc_tcd1_err_callback>
     c94:	f0 91 8d 20 	lds	r31, 0x208D	; 0x80208d <tc_tcd1_err_callback+0x1>
     c98:	30 97       	sbiw	r30, 0x00	; 0
     c9a:	09 f0       	breq	.+2      	; 0xc9e <__vector_84+0x42>
		tc_tcd1_err_callback();
     c9c:	19 95       	eicall
	}
}
     c9e:	ff 91       	pop	r31
     ca0:	ef 91       	pop	r30
     ca2:	bf 91       	pop	r27
     ca4:	af 91       	pop	r26
     ca6:	9f 91       	pop	r25
     ca8:	8f 91       	pop	r24
     caa:	7f 91       	pop	r23
     cac:	6f 91       	pop	r22
     cae:	5f 91       	pop	r21
     cb0:	4f 91       	pop	r20
     cb2:	3f 91       	pop	r19
     cb4:	2f 91       	pop	r18
     cb6:	0f 90       	pop	r0
     cb8:	0b be       	out	0x3b, r0	; 59
     cba:	0f 90       	pop	r0
     cbc:	09 be       	out	0x39, r0	; 57
     cbe:	0f 90       	pop	r0
     cc0:	08 be       	out	0x38, r0	; 56
     cc2:	0f 90       	pop	r0
     cc4:	0f be       	out	0x3f, r0	; 63
     cc6:	0f 90       	pop	r0
     cc8:	1f 90       	pop	r1
     cca:	18 95       	reti

00000ccc <__vector_85>:
 *
 * This function will handle interrupt on Timer Counter D1 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCD1_CCA_vect)
{
     ccc:	1f 92       	push	r1
     cce:	0f 92       	push	r0
     cd0:	0f b6       	in	r0, 0x3f	; 63
     cd2:	0f 92       	push	r0
     cd4:	11 24       	eor	r1, r1
     cd6:	08 b6       	in	r0, 0x38	; 56
     cd8:	0f 92       	push	r0
     cda:	18 be       	out	0x38, r1	; 56
     cdc:	09 b6       	in	r0, 0x39	; 57
     cde:	0f 92       	push	r0
     ce0:	19 be       	out	0x39, r1	; 57
     ce2:	0b b6       	in	r0, 0x3b	; 59
     ce4:	0f 92       	push	r0
     ce6:	1b be       	out	0x3b, r1	; 59
     ce8:	2f 93       	push	r18
     cea:	3f 93       	push	r19
     cec:	4f 93       	push	r20
     cee:	5f 93       	push	r21
     cf0:	6f 93       	push	r22
     cf2:	7f 93       	push	r23
     cf4:	8f 93       	push	r24
     cf6:	9f 93       	push	r25
     cf8:	af 93       	push	r26
     cfa:	bf 93       	push	r27
     cfc:	ef 93       	push	r30
     cfe:	ff 93       	push	r31
	if (tc_tcd1_cca_callback) {
     d00:	e0 91 8a 20 	lds	r30, 0x208A	; 0x80208a <tc_tcd1_cca_callback>
     d04:	f0 91 8b 20 	lds	r31, 0x208B	; 0x80208b <tc_tcd1_cca_callback+0x1>
     d08:	30 97       	sbiw	r30, 0x00	; 0
     d0a:	09 f0       	breq	.+2      	; 0xd0e <__vector_85+0x42>
		tc_tcd1_cca_callback();
     d0c:	19 95       	eicall
	}
}
     d0e:	ff 91       	pop	r31
     d10:	ef 91       	pop	r30
     d12:	bf 91       	pop	r27
     d14:	af 91       	pop	r26
     d16:	9f 91       	pop	r25
     d18:	8f 91       	pop	r24
     d1a:	7f 91       	pop	r23
     d1c:	6f 91       	pop	r22
     d1e:	5f 91       	pop	r21
     d20:	4f 91       	pop	r20
     d22:	3f 91       	pop	r19
     d24:	2f 91       	pop	r18
     d26:	0f 90       	pop	r0
     d28:	0b be       	out	0x3b, r0	; 59
     d2a:	0f 90       	pop	r0
     d2c:	09 be       	out	0x39, r0	; 57
     d2e:	0f 90       	pop	r0
     d30:	08 be       	out	0x38, r0	; 56
     d32:	0f 90       	pop	r0
     d34:	0f be       	out	0x3f, r0	; 63
     d36:	0f 90       	pop	r0
     d38:	1f 90       	pop	r1
     d3a:	18 95       	reti

00000d3c <__vector_86>:
 *
 * This function will handle interrupt on Timer Counter D1 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCD1_CCB_vect)
{
     d3c:	1f 92       	push	r1
     d3e:	0f 92       	push	r0
     d40:	0f b6       	in	r0, 0x3f	; 63
     d42:	0f 92       	push	r0
     d44:	11 24       	eor	r1, r1
     d46:	08 b6       	in	r0, 0x38	; 56
     d48:	0f 92       	push	r0
     d4a:	18 be       	out	0x38, r1	; 56
     d4c:	09 b6       	in	r0, 0x39	; 57
     d4e:	0f 92       	push	r0
     d50:	19 be       	out	0x39, r1	; 57
     d52:	0b b6       	in	r0, 0x3b	; 59
     d54:	0f 92       	push	r0
     d56:	1b be       	out	0x3b, r1	; 59
     d58:	2f 93       	push	r18
     d5a:	3f 93       	push	r19
     d5c:	4f 93       	push	r20
     d5e:	5f 93       	push	r21
     d60:	6f 93       	push	r22
     d62:	7f 93       	push	r23
     d64:	8f 93       	push	r24
     d66:	9f 93       	push	r25
     d68:	af 93       	push	r26
     d6a:	bf 93       	push	r27
     d6c:	ef 93       	push	r30
     d6e:	ff 93       	push	r31
	if (tc_tcd1_ccb_callback) {
     d70:	e0 91 88 20 	lds	r30, 0x2088	; 0x802088 <tc_tcd1_ccb_callback>
     d74:	f0 91 89 20 	lds	r31, 0x2089	; 0x802089 <tc_tcd1_ccb_callback+0x1>
     d78:	30 97       	sbiw	r30, 0x00	; 0
     d7a:	09 f0       	breq	.+2      	; 0xd7e <__vector_86+0x42>
		tc_tcd1_ccb_callback();
     d7c:	19 95       	eicall
	}
}
     d7e:	ff 91       	pop	r31
     d80:	ef 91       	pop	r30
     d82:	bf 91       	pop	r27
     d84:	af 91       	pop	r26
     d86:	9f 91       	pop	r25
     d88:	8f 91       	pop	r24
     d8a:	7f 91       	pop	r23
     d8c:	6f 91       	pop	r22
     d8e:	5f 91       	pop	r21
     d90:	4f 91       	pop	r20
     d92:	3f 91       	pop	r19
     d94:	2f 91       	pop	r18
     d96:	0f 90       	pop	r0
     d98:	0b be       	out	0x3b, r0	; 59
     d9a:	0f 90       	pop	r0
     d9c:	09 be       	out	0x39, r0	; 57
     d9e:	0f 90       	pop	r0
     da0:	08 be       	out	0x38, r0	; 56
     da2:	0f 90       	pop	r0
     da4:	0f be       	out	0x3f, r0	; 63
     da6:	0f 90       	pop	r0
     da8:	1f 90       	pop	r1
     daa:	18 95       	reti

00000dac <__vector_47>:
 *
 * This function will handle interrupt on Timer Counter E0 overflow and
 * call the callback function.
 */
ISR(TCE0_OVF_vect)
{
     dac:	1f 92       	push	r1
     dae:	0f 92       	push	r0
     db0:	0f b6       	in	r0, 0x3f	; 63
     db2:	0f 92       	push	r0
     db4:	11 24       	eor	r1, r1
     db6:	08 b6       	in	r0, 0x38	; 56
     db8:	0f 92       	push	r0
     dba:	18 be       	out	0x38, r1	; 56
     dbc:	09 b6       	in	r0, 0x39	; 57
     dbe:	0f 92       	push	r0
     dc0:	19 be       	out	0x39, r1	; 57
     dc2:	0b b6       	in	r0, 0x3b	; 59
     dc4:	0f 92       	push	r0
     dc6:	1b be       	out	0x3b, r1	; 59
     dc8:	2f 93       	push	r18
     dca:	3f 93       	push	r19
     dcc:	4f 93       	push	r20
     dce:	5f 93       	push	r21
     dd0:	6f 93       	push	r22
     dd2:	7f 93       	push	r23
     dd4:	8f 93       	push	r24
     dd6:	9f 93       	push	r25
     dd8:	af 93       	push	r26
     dda:	bf 93       	push	r27
     ddc:	ef 93       	push	r30
     dde:	ff 93       	push	r31
	if (tc_tce0_ovf_callback) {
     de0:	e0 91 86 20 	lds	r30, 0x2086	; 0x802086 <tc_tce0_ovf_callback>
     de4:	f0 91 87 20 	lds	r31, 0x2087	; 0x802087 <tc_tce0_ovf_callback+0x1>
     de8:	30 97       	sbiw	r30, 0x00	; 0
     dea:	09 f0       	breq	.+2      	; 0xdee <__vector_47+0x42>
		tc_tce0_ovf_callback();
     dec:	19 95       	eicall
	}
}
     dee:	ff 91       	pop	r31
     df0:	ef 91       	pop	r30
     df2:	bf 91       	pop	r27
     df4:	af 91       	pop	r26
     df6:	9f 91       	pop	r25
     df8:	8f 91       	pop	r24
     dfa:	7f 91       	pop	r23
     dfc:	6f 91       	pop	r22
     dfe:	5f 91       	pop	r21
     e00:	4f 91       	pop	r20
     e02:	3f 91       	pop	r19
     e04:	2f 91       	pop	r18
     e06:	0f 90       	pop	r0
     e08:	0b be       	out	0x3b, r0	; 59
     e0a:	0f 90       	pop	r0
     e0c:	09 be       	out	0x39, r0	; 57
     e0e:	0f 90       	pop	r0
     e10:	08 be       	out	0x38, r0	; 56
     e12:	0f 90       	pop	r0
     e14:	0f be       	out	0x3f, r0	; 63
     e16:	0f 90       	pop	r0
     e18:	1f 90       	pop	r1
     e1a:	18 95       	reti

00000e1c <__vector_48>:
 *
 * This function will handle interrupt on Timer Counter E0 error and
 * call the callback function.
 */
ISR(TCE0_ERR_vect)
{
     e1c:	1f 92       	push	r1
     e1e:	0f 92       	push	r0
     e20:	0f b6       	in	r0, 0x3f	; 63
     e22:	0f 92       	push	r0
     e24:	11 24       	eor	r1, r1
     e26:	08 b6       	in	r0, 0x38	; 56
     e28:	0f 92       	push	r0
     e2a:	18 be       	out	0x38, r1	; 56
     e2c:	09 b6       	in	r0, 0x39	; 57
     e2e:	0f 92       	push	r0
     e30:	19 be       	out	0x39, r1	; 57
     e32:	0b b6       	in	r0, 0x3b	; 59
     e34:	0f 92       	push	r0
     e36:	1b be       	out	0x3b, r1	; 59
     e38:	2f 93       	push	r18
     e3a:	3f 93       	push	r19
     e3c:	4f 93       	push	r20
     e3e:	5f 93       	push	r21
     e40:	6f 93       	push	r22
     e42:	7f 93       	push	r23
     e44:	8f 93       	push	r24
     e46:	9f 93       	push	r25
     e48:	af 93       	push	r26
     e4a:	bf 93       	push	r27
     e4c:	ef 93       	push	r30
     e4e:	ff 93       	push	r31
	if (tc_tce0_err_callback) {
     e50:	e0 91 84 20 	lds	r30, 0x2084	; 0x802084 <tc_tce0_err_callback>
     e54:	f0 91 85 20 	lds	r31, 0x2085	; 0x802085 <tc_tce0_err_callback+0x1>
     e58:	30 97       	sbiw	r30, 0x00	; 0
     e5a:	09 f0       	breq	.+2      	; 0xe5e <__vector_48+0x42>
		tc_tce0_err_callback();
     e5c:	19 95       	eicall
	}
}
     e5e:	ff 91       	pop	r31
     e60:	ef 91       	pop	r30
     e62:	bf 91       	pop	r27
     e64:	af 91       	pop	r26
     e66:	9f 91       	pop	r25
     e68:	8f 91       	pop	r24
     e6a:	7f 91       	pop	r23
     e6c:	6f 91       	pop	r22
     e6e:	5f 91       	pop	r21
     e70:	4f 91       	pop	r20
     e72:	3f 91       	pop	r19
     e74:	2f 91       	pop	r18
     e76:	0f 90       	pop	r0
     e78:	0b be       	out	0x3b, r0	; 59
     e7a:	0f 90       	pop	r0
     e7c:	09 be       	out	0x39, r0	; 57
     e7e:	0f 90       	pop	r0
     e80:	08 be       	out	0x38, r0	; 56
     e82:	0f 90       	pop	r0
     e84:	0f be       	out	0x3f, r0	; 63
     e86:	0f 90       	pop	r0
     e88:	1f 90       	pop	r1
     e8a:	18 95       	reti

00000e8c <__vector_49>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCE0_CCA_vect)
{
     e8c:	1f 92       	push	r1
     e8e:	0f 92       	push	r0
     e90:	0f b6       	in	r0, 0x3f	; 63
     e92:	0f 92       	push	r0
     e94:	11 24       	eor	r1, r1
     e96:	08 b6       	in	r0, 0x38	; 56
     e98:	0f 92       	push	r0
     e9a:	18 be       	out	0x38, r1	; 56
     e9c:	09 b6       	in	r0, 0x39	; 57
     e9e:	0f 92       	push	r0
     ea0:	19 be       	out	0x39, r1	; 57
     ea2:	0b b6       	in	r0, 0x3b	; 59
     ea4:	0f 92       	push	r0
     ea6:	1b be       	out	0x3b, r1	; 59
     ea8:	2f 93       	push	r18
     eaa:	3f 93       	push	r19
     eac:	4f 93       	push	r20
     eae:	5f 93       	push	r21
     eb0:	6f 93       	push	r22
     eb2:	7f 93       	push	r23
     eb4:	8f 93       	push	r24
     eb6:	9f 93       	push	r25
     eb8:	af 93       	push	r26
     eba:	bf 93       	push	r27
     ebc:	ef 93       	push	r30
     ebe:	ff 93       	push	r31
	if (tc_tce0_cca_callback) {
     ec0:	e0 91 82 20 	lds	r30, 0x2082	; 0x802082 <tc_tce0_cca_callback>
     ec4:	f0 91 83 20 	lds	r31, 0x2083	; 0x802083 <tc_tce0_cca_callback+0x1>
     ec8:	30 97       	sbiw	r30, 0x00	; 0
     eca:	09 f0       	breq	.+2      	; 0xece <__vector_49+0x42>
		tc_tce0_cca_callback();
     ecc:	19 95       	eicall
	}
}
     ece:	ff 91       	pop	r31
     ed0:	ef 91       	pop	r30
     ed2:	bf 91       	pop	r27
     ed4:	af 91       	pop	r26
     ed6:	9f 91       	pop	r25
     ed8:	8f 91       	pop	r24
     eda:	7f 91       	pop	r23
     edc:	6f 91       	pop	r22
     ede:	5f 91       	pop	r21
     ee0:	4f 91       	pop	r20
     ee2:	3f 91       	pop	r19
     ee4:	2f 91       	pop	r18
     ee6:	0f 90       	pop	r0
     ee8:	0b be       	out	0x3b, r0	; 59
     eea:	0f 90       	pop	r0
     eec:	09 be       	out	0x39, r0	; 57
     eee:	0f 90       	pop	r0
     ef0:	08 be       	out	0x38, r0	; 56
     ef2:	0f 90       	pop	r0
     ef4:	0f be       	out	0x3f, r0	; 63
     ef6:	0f 90       	pop	r0
     ef8:	1f 90       	pop	r1
     efa:	18 95       	reti

00000efc <__vector_50>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCE0_CCB_vect)
{
     efc:	1f 92       	push	r1
     efe:	0f 92       	push	r0
     f00:	0f b6       	in	r0, 0x3f	; 63
     f02:	0f 92       	push	r0
     f04:	11 24       	eor	r1, r1
     f06:	08 b6       	in	r0, 0x38	; 56
     f08:	0f 92       	push	r0
     f0a:	18 be       	out	0x38, r1	; 56
     f0c:	09 b6       	in	r0, 0x39	; 57
     f0e:	0f 92       	push	r0
     f10:	19 be       	out	0x39, r1	; 57
     f12:	0b b6       	in	r0, 0x3b	; 59
     f14:	0f 92       	push	r0
     f16:	1b be       	out	0x3b, r1	; 59
     f18:	2f 93       	push	r18
     f1a:	3f 93       	push	r19
     f1c:	4f 93       	push	r20
     f1e:	5f 93       	push	r21
     f20:	6f 93       	push	r22
     f22:	7f 93       	push	r23
     f24:	8f 93       	push	r24
     f26:	9f 93       	push	r25
     f28:	af 93       	push	r26
     f2a:	bf 93       	push	r27
     f2c:	ef 93       	push	r30
     f2e:	ff 93       	push	r31
	if (tc_tce0_ccb_callback) {
     f30:	e0 91 80 20 	lds	r30, 0x2080	; 0x802080 <tc_tce0_ccb_callback>
     f34:	f0 91 81 20 	lds	r31, 0x2081	; 0x802081 <tc_tce0_ccb_callback+0x1>
     f38:	30 97       	sbiw	r30, 0x00	; 0
     f3a:	09 f0       	breq	.+2      	; 0xf3e <__vector_50+0x42>
		tc_tce0_ccb_callback();
     f3c:	19 95       	eicall
	}
}
     f3e:	ff 91       	pop	r31
     f40:	ef 91       	pop	r30
     f42:	bf 91       	pop	r27
     f44:	af 91       	pop	r26
     f46:	9f 91       	pop	r25
     f48:	8f 91       	pop	r24
     f4a:	7f 91       	pop	r23
     f4c:	6f 91       	pop	r22
     f4e:	5f 91       	pop	r21
     f50:	4f 91       	pop	r20
     f52:	3f 91       	pop	r19
     f54:	2f 91       	pop	r18
     f56:	0f 90       	pop	r0
     f58:	0b be       	out	0x3b, r0	; 59
     f5a:	0f 90       	pop	r0
     f5c:	09 be       	out	0x39, r0	; 57
     f5e:	0f 90       	pop	r0
     f60:	08 be       	out	0x38, r0	; 56
     f62:	0f 90       	pop	r0
     f64:	0f be       	out	0x3f, r0	; 63
     f66:	0f 90       	pop	r0
     f68:	1f 90       	pop	r1
     f6a:	18 95       	reti

00000f6c <__vector_51>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureC and
 * call the callback function.
 */
ISR(TCE0_CCC_vect)
{
     f6c:	1f 92       	push	r1
     f6e:	0f 92       	push	r0
     f70:	0f b6       	in	r0, 0x3f	; 63
     f72:	0f 92       	push	r0
     f74:	11 24       	eor	r1, r1
     f76:	08 b6       	in	r0, 0x38	; 56
     f78:	0f 92       	push	r0
     f7a:	18 be       	out	0x38, r1	; 56
     f7c:	09 b6       	in	r0, 0x39	; 57
     f7e:	0f 92       	push	r0
     f80:	19 be       	out	0x39, r1	; 57
     f82:	0b b6       	in	r0, 0x3b	; 59
     f84:	0f 92       	push	r0
     f86:	1b be       	out	0x3b, r1	; 59
     f88:	2f 93       	push	r18
     f8a:	3f 93       	push	r19
     f8c:	4f 93       	push	r20
     f8e:	5f 93       	push	r21
     f90:	6f 93       	push	r22
     f92:	7f 93       	push	r23
     f94:	8f 93       	push	r24
     f96:	9f 93       	push	r25
     f98:	af 93       	push	r26
     f9a:	bf 93       	push	r27
     f9c:	ef 93       	push	r30
     f9e:	ff 93       	push	r31
	if (tc_tce0_ccc_callback) {
     fa0:	e0 91 7e 20 	lds	r30, 0x207E	; 0x80207e <tc_tce0_ccc_callback>
     fa4:	f0 91 7f 20 	lds	r31, 0x207F	; 0x80207f <tc_tce0_ccc_callback+0x1>
     fa8:	30 97       	sbiw	r30, 0x00	; 0
     faa:	09 f0       	breq	.+2      	; 0xfae <__vector_51+0x42>
		tc_tce0_ccc_callback();
     fac:	19 95       	eicall
	}
}
     fae:	ff 91       	pop	r31
     fb0:	ef 91       	pop	r30
     fb2:	bf 91       	pop	r27
     fb4:	af 91       	pop	r26
     fb6:	9f 91       	pop	r25
     fb8:	8f 91       	pop	r24
     fba:	7f 91       	pop	r23
     fbc:	6f 91       	pop	r22
     fbe:	5f 91       	pop	r21
     fc0:	4f 91       	pop	r20
     fc2:	3f 91       	pop	r19
     fc4:	2f 91       	pop	r18
     fc6:	0f 90       	pop	r0
     fc8:	0b be       	out	0x3b, r0	; 59
     fca:	0f 90       	pop	r0
     fcc:	09 be       	out	0x39, r0	; 57
     fce:	0f 90       	pop	r0
     fd0:	08 be       	out	0x38, r0	; 56
     fd2:	0f 90       	pop	r0
     fd4:	0f be       	out	0x3f, r0	; 63
     fd6:	0f 90       	pop	r0
     fd8:	1f 90       	pop	r1
     fda:	18 95       	reti

00000fdc <__vector_52>:
 *
 * This function will handle interrupt on Timer Counter E0 Compare/CaptureD and
 * call the callback function.
 */
ISR(TCE0_CCD_vect)
{
     fdc:	1f 92       	push	r1
     fde:	0f 92       	push	r0
     fe0:	0f b6       	in	r0, 0x3f	; 63
     fe2:	0f 92       	push	r0
     fe4:	11 24       	eor	r1, r1
     fe6:	08 b6       	in	r0, 0x38	; 56
     fe8:	0f 92       	push	r0
     fea:	18 be       	out	0x38, r1	; 56
     fec:	09 b6       	in	r0, 0x39	; 57
     fee:	0f 92       	push	r0
     ff0:	19 be       	out	0x39, r1	; 57
     ff2:	0b b6       	in	r0, 0x3b	; 59
     ff4:	0f 92       	push	r0
     ff6:	1b be       	out	0x3b, r1	; 59
     ff8:	2f 93       	push	r18
     ffa:	3f 93       	push	r19
     ffc:	4f 93       	push	r20
     ffe:	5f 93       	push	r21
    1000:	6f 93       	push	r22
    1002:	7f 93       	push	r23
    1004:	8f 93       	push	r24
    1006:	9f 93       	push	r25
    1008:	af 93       	push	r26
    100a:	bf 93       	push	r27
    100c:	ef 93       	push	r30
    100e:	ff 93       	push	r31
	if (tc_tce0_ccd_callback) {
    1010:	e0 91 7c 20 	lds	r30, 0x207C	; 0x80207c <tc_tce0_ccd_callback>
    1014:	f0 91 7d 20 	lds	r31, 0x207D	; 0x80207d <tc_tce0_ccd_callback+0x1>
    1018:	30 97       	sbiw	r30, 0x00	; 0
    101a:	09 f0       	breq	.+2      	; 0x101e <__vector_52+0x42>
		tc_tce0_ccd_callback();
    101c:	19 95       	eicall
	}
}
    101e:	ff 91       	pop	r31
    1020:	ef 91       	pop	r30
    1022:	bf 91       	pop	r27
    1024:	af 91       	pop	r26
    1026:	9f 91       	pop	r25
    1028:	8f 91       	pop	r24
    102a:	7f 91       	pop	r23
    102c:	6f 91       	pop	r22
    102e:	5f 91       	pop	r21
    1030:	4f 91       	pop	r20
    1032:	3f 91       	pop	r19
    1034:	2f 91       	pop	r18
    1036:	0f 90       	pop	r0
    1038:	0b be       	out	0x3b, r0	; 59
    103a:	0f 90       	pop	r0
    103c:	09 be       	out	0x39, r0	; 57
    103e:	0f 90       	pop	r0
    1040:	08 be       	out	0x38, r0	; 56
    1042:	0f 90       	pop	r0
    1044:	0f be       	out	0x3f, r0	; 63
    1046:	0f 90       	pop	r0
    1048:	1f 90       	pop	r1
    104a:	18 95       	reti

0000104c <__vector_53>:
 *
 * This function will handle interrupt on Timer Counter E1 overflow and
 * call the callback function.
 */
ISR(TCE1_OVF_vect)
{
    104c:	1f 92       	push	r1
    104e:	0f 92       	push	r0
    1050:	0f b6       	in	r0, 0x3f	; 63
    1052:	0f 92       	push	r0
    1054:	11 24       	eor	r1, r1
    1056:	08 b6       	in	r0, 0x38	; 56
    1058:	0f 92       	push	r0
    105a:	18 be       	out	0x38, r1	; 56
    105c:	09 b6       	in	r0, 0x39	; 57
    105e:	0f 92       	push	r0
    1060:	19 be       	out	0x39, r1	; 57
    1062:	0b b6       	in	r0, 0x3b	; 59
    1064:	0f 92       	push	r0
    1066:	1b be       	out	0x3b, r1	; 59
    1068:	2f 93       	push	r18
    106a:	3f 93       	push	r19
    106c:	4f 93       	push	r20
    106e:	5f 93       	push	r21
    1070:	6f 93       	push	r22
    1072:	7f 93       	push	r23
    1074:	8f 93       	push	r24
    1076:	9f 93       	push	r25
    1078:	af 93       	push	r26
    107a:	bf 93       	push	r27
    107c:	ef 93       	push	r30
    107e:	ff 93       	push	r31
	if (tc_tce1_ovf_callback) {
    1080:	e0 91 7a 20 	lds	r30, 0x207A	; 0x80207a <tc_tce1_ovf_callback>
    1084:	f0 91 7b 20 	lds	r31, 0x207B	; 0x80207b <tc_tce1_ovf_callback+0x1>
    1088:	30 97       	sbiw	r30, 0x00	; 0
    108a:	09 f0       	breq	.+2      	; 0x108e <__vector_53+0x42>
		tc_tce1_ovf_callback();
    108c:	19 95       	eicall
	}
}
    108e:	ff 91       	pop	r31
    1090:	ef 91       	pop	r30
    1092:	bf 91       	pop	r27
    1094:	af 91       	pop	r26
    1096:	9f 91       	pop	r25
    1098:	8f 91       	pop	r24
    109a:	7f 91       	pop	r23
    109c:	6f 91       	pop	r22
    109e:	5f 91       	pop	r21
    10a0:	4f 91       	pop	r20
    10a2:	3f 91       	pop	r19
    10a4:	2f 91       	pop	r18
    10a6:	0f 90       	pop	r0
    10a8:	0b be       	out	0x3b, r0	; 59
    10aa:	0f 90       	pop	r0
    10ac:	09 be       	out	0x39, r0	; 57
    10ae:	0f 90       	pop	r0
    10b0:	08 be       	out	0x38, r0	; 56
    10b2:	0f 90       	pop	r0
    10b4:	0f be       	out	0x3f, r0	; 63
    10b6:	0f 90       	pop	r0
    10b8:	1f 90       	pop	r1
    10ba:	18 95       	reti

000010bc <__vector_54>:
 *
 * This function will handle interrupt on Timer Counter E1 error and
 * call the callback function.
 */
ISR(TCE1_ERR_vect)
{
    10bc:	1f 92       	push	r1
    10be:	0f 92       	push	r0
    10c0:	0f b6       	in	r0, 0x3f	; 63
    10c2:	0f 92       	push	r0
    10c4:	11 24       	eor	r1, r1
    10c6:	08 b6       	in	r0, 0x38	; 56
    10c8:	0f 92       	push	r0
    10ca:	18 be       	out	0x38, r1	; 56
    10cc:	09 b6       	in	r0, 0x39	; 57
    10ce:	0f 92       	push	r0
    10d0:	19 be       	out	0x39, r1	; 57
    10d2:	0b b6       	in	r0, 0x3b	; 59
    10d4:	0f 92       	push	r0
    10d6:	1b be       	out	0x3b, r1	; 59
    10d8:	2f 93       	push	r18
    10da:	3f 93       	push	r19
    10dc:	4f 93       	push	r20
    10de:	5f 93       	push	r21
    10e0:	6f 93       	push	r22
    10e2:	7f 93       	push	r23
    10e4:	8f 93       	push	r24
    10e6:	9f 93       	push	r25
    10e8:	af 93       	push	r26
    10ea:	bf 93       	push	r27
    10ec:	ef 93       	push	r30
    10ee:	ff 93       	push	r31
	if (tc_tce1_err_callback) {
    10f0:	e0 91 78 20 	lds	r30, 0x2078	; 0x802078 <tc_tce1_err_callback>
    10f4:	f0 91 79 20 	lds	r31, 0x2079	; 0x802079 <tc_tce1_err_callback+0x1>
    10f8:	30 97       	sbiw	r30, 0x00	; 0
    10fa:	09 f0       	breq	.+2      	; 0x10fe <__vector_54+0x42>
		tc_tce1_err_callback();
    10fc:	19 95       	eicall
	}
}
    10fe:	ff 91       	pop	r31
    1100:	ef 91       	pop	r30
    1102:	bf 91       	pop	r27
    1104:	af 91       	pop	r26
    1106:	9f 91       	pop	r25
    1108:	8f 91       	pop	r24
    110a:	7f 91       	pop	r23
    110c:	6f 91       	pop	r22
    110e:	5f 91       	pop	r21
    1110:	4f 91       	pop	r20
    1112:	3f 91       	pop	r19
    1114:	2f 91       	pop	r18
    1116:	0f 90       	pop	r0
    1118:	0b be       	out	0x3b, r0	; 59
    111a:	0f 90       	pop	r0
    111c:	09 be       	out	0x39, r0	; 57
    111e:	0f 90       	pop	r0
    1120:	08 be       	out	0x38, r0	; 56
    1122:	0f 90       	pop	r0
    1124:	0f be       	out	0x3f, r0	; 63
    1126:	0f 90       	pop	r0
    1128:	1f 90       	pop	r1
    112a:	18 95       	reti

0000112c <__vector_55>:
 *
 * This function will handle interrupt on Timer Counter E1 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCE1_CCA_vect)
{
    112c:	1f 92       	push	r1
    112e:	0f 92       	push	r0
    1130:	0f b6       	in	r0, 0x3f	; 63
    1132:	0f 92       	push	r0
    1134:	11 24       	eor	r1, r1
    1136:	08 b6       	in	r0, 0x38	; 56
    1138:	0f 92       	push	r0
    113a:	18 be       	out	0x38, r1	; 56
    113c:	09 b6       	in	r0, 0x39	; 57
    113e:	0f 92       	push	r0
    1140:	19 be       	out	0x39, r1	; 57
    1142:	0b b6       	in	r0, 0x3b	; 59
    1144:	0f 92       	push	r0
    1146:	1b be       	out	0x3b, r1	; 59
    1148:	2f 93       	push	r18
    114a:	3f 93       	push	r19
    114c:	4f 93       	push	r20
    114e:	5f 93       	push	r21
    1150:	6f 93       	push	r22
    1152:	7f 93       	push	r23
    1154:	8f 93       	push	r24
    1156:	9f 93       	push	r25
    1158:	af 93       	push	r26
    115a:	bf 93       	push	r27
    115c:	ef 93       	push	r30
    115e:	ff 93       	push	r31
	if (tc_tce1_cca_callback) {
    1160:	e0 91 76 20 	lds	r30, 0x2076	; 0x802076 <tc_tce1_cca_callback>
    1164:	f0 91 77 20 	lds	r31, 0x2077	; 0x802077 <tc_tce1_cca_callback+0x1>
    1168:	30 97       	sbiw	r30, 0x00	; 0
    116a:	09 f0       	breq	.+2      	; 0x116e <__vector_55+0x42>
		tc_tce1_cca_callback();
    116c:	19 95       	eicall
	}
}
    116e:	ff 91       	pop	r31
    1170:	ef 91       	pop	r30
    1172:	bf 91       	pop	r27
    1174:	af 91       	pop	r26
    1176:	9f 91       	pop	r25
    1178:	8f 91       	pop	r24
    117a:	7f 91       	pop	r23
    117c:	6f 91       	pop	r22
    117e:	5f 91       	pop	r21
    1180:	4f 91       	pop	r20
    1182:	3f 91       	pop	r19
    1184:	2f 91       	pop	r18
    1186:	0f 90       	pop	r0
    1188:	0b be       	out	0x3b, r0	; 59
    118a:	0f 90       	pop	r0
    118c:	09 be       	out	0x39, r0	; 57
    118e:	0f 90       	pop	r0
    1190:	08 be       	out	0x38, r0	; 56
    1192:	0f 90       	pop	r0
    1194:	0f be       	out	0x3f, r0	; 63
    1196:	0f 90       	pop	r0
    1198:	1f 90       	pop	r1
    119a:	18 95       	reti

0000119c <__vector_56>:
 *
 * This function will handle interrupt on Timer Counter E1 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCE1_CCB_vect)
{
    119c:	1f 92       	push	r1
    119e:	0f 92       	push	r0
    11a0:	0f b6       	in	r0, 0x3f	; 63
    11a2:	0f 92       	push	r0
    11a4:	11 24       	eor	r1, r1
    11a6:	08 b6       	in	r0, 0x38	; 56
    11a8:	0f 92       	push	r0
    11aa:	18 be       	out	0x38, r1	; 56
    11ac:	09 b6       	in	r0, 0x39	; 57
    11ae:	0f 92       	push	r0
    11b0:	19 be       	out	0x39, r1	; 57
    11b2:	0b b6       	in	r0, 0x3b	; 59
    11b4:	0f 92       	push	r0
    11b6:	1b be       	out	0x3b, r1	; 59
    11b8:	2f 93       	push	r18
    11ba:	3f 93       	push	r19
    11bc:	4f 93       	push	r20
    11be:	5f 93       	push	r21
    11c0:	6f 93       	push	r22
    11c2:	7f 93       	push	r23
    11c4:	8f 93       	push	r24
    11c6:	9f 93       	push	r25
    11c8:	af 93       	push	r26
    11ca:	bf 93       	push	r27
    11cc:	ef 93       	push	r30
    11ce:	ff 93       	push	r31
	if (tc_tce1_ccb_callback) {
    11d0:	e0 91 74 20 	lds	r30, 0x2074	; 0x802074 <tc_tce1_ccb_callback>
    11d4:	f0 91 75 20 	lds	r31, 0x2075	; 0x802075 <tc_tce1_ccb_callback+0x1>
    11d8:	30 97       	sbiw	r30, 0x00	; 0
    11da:	09 f0       	breq	.+2      	; 0x11de <__vector_56+0x42>
		tc_tce1_ccb_callback();
    11dc:	19 95       	eicall
	}
}
    11de:	ff 91       	pop	r31
    11e0:	ef 91       	pop	r30
    11e2:	bf 91       	pop	r27
    11e4:	af 91       	pop	r26
    11e6:	9f 91       	pop	r25
    11e8:	8f 91       	pop	r24
    11ea:	7f 91       	pop	r23
    11ec:	6f 91       	pop	r22
    11ee:	5f 91       	pop	r21
    11f0:	4f 91       	pop	r20
    11f2:	3f 91       	pop	r19
    11f4:	2f 91       	pop	r18
    11f6:	0f 90       	pop	r0
    11f8:	0b be       	out	0x3b, r0	; 59
    11fa:	0f 90       	pop	r0
    11fc:	09 be       	out	0x39, r0	; 57
    11fe:	0f 90       	pop	r0
    1200:	08 be       	out	0x38, r0	; 56
    1202:	0f 90       	pop	r0
    1204:	0f be       	out	0x3f, r0	; 63
    1206:	0f 90       	pop	r0
    1208:	1f 90       	pop	r1
    120a:	18 95       	reti

0000120c <__vector_108>:
 *
 * This function will handle interrupt on Timer Counter F0 overflow and
 * call the callback function.
 */
ISR(TCF0_OVF_vect)
{
    120c:	1f 92       	push	r1
    120e:	0f 92       	push	r0
    1210:	0f b6       	in	r0, 0x3f	; 63
    1212:	0f 92       	push	r0
    1214:	11 24       	eor	r1, r1
    1216:	08 b6       	in	r0, 0x38	; 56
    1218:	0f 92       	push	r0
    121a:	18 be       	out	0x38, r1	; 56
    121c:	09 b6       	in	r0, 0x39	; 57
    121e:	0f 92       	push	r0
    1220:	19 be       	out	0x39, r1	; 57
    1222:	0b b6       	in	r0, 0x3b	; 59
    1224:	0f 92       	push	r0
    1226:	1b be       	out	0x3b, r1	; 59
    1228:	2f 93       	push	r18
    122a:	3f 93       	push	r19
    122c:	4f 93       	push	r20
    122e:	5f 93       	push	r21
    1230:	6f 93       	push	r22
    1232:	7f 93       	push	r23
    1234:	8f 93       	push	r24
    1236:	9f 93       	push	r25
    1238:	af 93       	push	r26
    123a:	bf 93       	push	r27
    123c:	ef 93       	push	r30
    123e:	ff 93       	push	r31
	if (tc_tcf0_ovf_callback) {
    1240:	e0 91 72 20 	lds	r30, 0x2072	; 0x802072 <tc_tcf0_ovf_callback>
    1244:	f0 91 73 20 	lds	r31, 0x2073	; 0x802073 <tc_tcf0_ovf_callback+0x1>
    1248:	30 97       	sbiw	r30, 0x00	; 0
    124a:	09 f0       	breq	.+2      	; 0x124e <__vector_108+0x42>
		tc_tcf0_ovf_callback();
    124c:	19 95       	eicall
	}
}
    124e:	ff 91       	pop	r31
    1250:	ef 91       	pop	r30
    1252:	bf 91       	pop	r27
    1254:	af 91       	pop	r26
    1256:	9f 91       	pop	r25
    1258:	8f 91       	pop	r24
    125a:	7f 91       	pop	r23
    125c:	6f 91       	pop	r22
    125e:	5f 91       	pop	r21
    1260:	4f 91       	pop	r20
    1262:	3f 91       	pop	r19
    1264:	2f 91       	pop	r18
    1266:	0f 90       	pop	r0
    1268:	0b be       	out	0x3b, r0	; 59
    126a:	0f 90       	pop	r0
    126c:	09 be       	out	0x39, r0	; 57
    126e:	0f 90       	pop	r0
    1270:	08 be       	out	0x38, r0	; 56
    1272:	0f 90       	pop	r0
    1274:	0f be       	out	0x3f, r0	; 63
    1276:	0f 90       	pop	r0
    1278:	1f 90       	pop	r1
    127a:	18 95       	reti

0000127c <__vector_109>:
 *
 * This function will handle interrupt on Timer Counter F0 error and
 * call the callback function.
 */
ISR(TCF0_ERR_vect)
{
    127c:	1f 92       	push	r1
    127e:	0f 92       	push	r0
    1280:	0f b6       	in	r0, 0x3f	; 63
    1282:	0f 92       	push	r0
    1284:	11 24       	eor	r1, r1
    1286:	08 b6       	in	r0, 0x38	; 56
    1288:	0f 92       	push	r0
    128a:	18 be       	out	0x38, r1	; 56
    128c:	09 b6       	in	r0, 0x39	; 57
    128e:	0f 92       	push	r0
    1290:	19 be       	out	0x39, r1	; 57
    1292:	0b b6       	in	r0, 0x3b	; 59
    1294:	0f 92       	push	r0
    1296:	1b be       	out	0x3b, r1	; 59
    1298:	2f 93       	push	r18
    129a:	3f 93       	push	r19
    129c:	4f 93       	push	r20
    129e:	5f 93       	push	r21
    12a0:	6f 93       	push	r22
    12a2:	7f 93       	push	r23
    12a4:	8f 93       	push	r24
    12a6:	9f 93       	push	r25
    12a8:	af 93       	push	r26
    12aa:	bf 93       	push	r27
    12ac:	ef 93       	push	r30
    12ae:	ff 93       	push	r31
	if (tc_tcf0_err_callback) {
    12b0:	e0 91 70 20 	lds	r30, 0x2070	; 0x802070 <tc_tcf0_err_callback>
    12b4:	f0 91 71 20 	lds	r31, 0x2071	; 0x802071 <tc_tcf0_err_callback+0x1>
    12b8:	30 97       	sbiw	r30, 0x00	; 0
    12ba:	09 f0       	breq	.+2      	; 0x12be <__vector_109+0x42>
		tc_tcf0_err_callback();
    12bc:	19 95       	eicall
	}
}
    12be:	ff 91       	pop	r31
    12c0:	ef 91       	pop	r30
    12c2:	bf 91       	pop	r27
    12c4:	af 91       	pop	r26
    12c6:	9f 91       	pop	r25
    12c8:	8f 91       	pop	r24
    12ca:	7f 91       	pop	r23
    12cc:	6f 91       	pop	r22
    12ce:	5f 91       	pop	r21
    12d0:	4f 91       	pop	r20
    12d2:	3f 91       	pop	r19
    12d4:	2f 91       	pop	r18
    12d6:	0f 90       	pop	r0
    12d8:	0b be       	out	0x3b, r0	; 59
    12da:	0f 90       	pop	r0
    12dc:	09 be       	out	0x39, r0	; 57
    12de:	0f 90       	pop	r0
    12e0:	08 be       	out	0x38, r0	; 56
    12e2:	0f 90       	pop	r0
    12e4:	0f be       	out	0x3f, r0	; 63
    12e6:	0f 90       	pop	r0
    12e8:	1f 90       	pop	r1
    12ea:	18 95       	reti

000012ec <__vector_110>:
 *
 * This function will handle interrupt on Timer Counter F0 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCF0_CCA_vect)
{
    12ec:	1f 92       	push	r1
    12ee:	0f 92       	push	r0
    12f0:	0f b6       	in	r0, 0x3f	; 63
    12f2:	0f 92       	push	r0
    12f4:	11 24       	eor	r1, r1
    12f6:	08 b6       	in	r0, 0x38	; 56
    12f8:	0f 92       	push	r0
    12fa:	18 be       	out	0x38, r1	; 56
    12fc:	09 b6       	in	r0, 0x39	; 57
    12fe:	0f 92       	push	r0
    1300:	19 be       	out	0x39, r1	; 57
    1302:	0b b6       	in	r0, 0x3b	; 59
    1304:	0f 92       	push	r0
    1306:	1b be       	out	0x3b, r1	; 59
    1308:	2f 93       	push	r18
    130a:	3f 93       	push	r19
    130c:	4f 93       	push	r20
    130e:	5f 93       	push	r21
    1310:	6f 93       	push	r22
    1312:	7f 93       	push	r23
    1314:	8f 93       	push	r24
    1316:	9f 93       	push	r25
    1318:	af 93       	push	r26
    131a:	bf 93       	push	r27
    131c:	ef 93       	push	r30
    131e:	ff 93       	push	r31
	if (tc_tcf0_cca_callback) {
    1320:	e0 91 6e 20 	lds	r30, 0x206E	; 0x80206e <tc_tcf0_cca_callback>
    1324:	f0 91 6f 20 	lds	r31, 0x206F	; 0x80206f <tc_tcf0_cca_callback+0x1>
    1328:	30 97       	sbiw	r30, 0x00	; 0
    132a:	09 f0       	breq	.+2      	; 0x132e <__vector_110+0x42>
		tc_tcf0_cca_callback();
    132c:	19 95       	eicall
	}
}
    132e:	ff 91       	pop	r31
    1330:	ef 91       	pop	r30
    1332:	bf 91       	pop	r27
    1334:	af 91       	pop	r26
    1336:	9f 91       	pop	r25
    1338:	8f 91       	pop	r24
    133a:	7f 91       	pop	r23
    133c:	6f 91       	pop	r22
    133e:	5f 91       	pop	r21
    1340:	4f 91       	pop	r20
    1342:	3f 91       	pop	r19
    1344:	2f 91       	pop	r18
    1346:	0f 90       	pop	r0
    1348:	0b be       	out	0x3b, r0	; 59
    134a:	0f 90       	pop	r0
    134c:	09 be       	out	0x39, r0	; 57
    134e:	0f 90       	pop	r0
    1350:	08 be       	out	0x38, r0	; 56
    1352:	0f 90       	pop	r0
    1354:	0f be       	out	0x3f, r0	; 63
    1356:	0f 90       	pop	r0
    1358:	1f 90       	pop	r1
    135a:	18 95       	reti

0000135c <__vector_111>:
 *
 * This function will handle interrupt on Timer Counter F0 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCF0_CCB_vect)
{
    135c:	1f 92       	push	r1
    135e:	0f 92       	push	r0
    1360:	0f b6       	in	r0, 0x3f	; 63
    1362:	0f 92       	push	r0
    1364:	11 24       	eor	r1, r1
    1366:	08 b6       	in	r0, 0x38	; 56
    1368:	0f 92       	push	r0
    136a:	18 be       	out	0x38, r1	; 56
    136c:	09 b6       	in	r0, 0x39	; 57
    136e:	0f 92       	push	r0
    1370:	19 be       	out	0x39, r1	; 57
    1372:	0b b6       	in	r0, 0x3b	; 59
    1374:	0f 92       	push	r0
    1376:	1b be       	out	0x3b, r1	; 59
    1378:	2f 93       	push	r18
    137a:	3f 93       	push	r19
    137c:	4f 93       	push	r20
    137e:	5f 93       	push	r21
    1380:	6f 93       	push	r22
    1382:	7f 93       	push	r23
    1384:	8f 93       	push	r24
    1386:	9f 93       	push	r25
    1388:	af 93       	push	r26
    138a:	bf 93       	push	r27
    138c:	ef 93       	push	r30
    138e:	ff 93       	push	r31
	if (tc_tcf0_ccb_callback) {
    1390:	e0 91 6c 20 	lds	r30, 0x206C	; 0x80206c <tc_tcf0_ccb_callback>
    1394:	f0 91 6d 20 	lds	r31, 0x206D	; 0x80206d <tc_tcf0_ccb_callback+0x1>
    1398:	30 97       	sbiw	r30, 0x00	; 0
    139a:	09 f0       	breq	.+2      	; 0x139e <__vector_111+0x42>
		tc_tcf0_ccb_callback();
    139c:	19 95       	eicall
	}
}
    139e:	ff 91       	pop	r31
    13a0:	ef 91       	pop	r30
    13a2:	bf 91       	pop	r27
    13a4:	af 91       	pop	r26
    13a6:	9f 91       	pop	r25
    13a8:	8f 91       	pop	r24
    13aa:	7f 91       	pop	r23
    13ac:	6f 91       	pop	r22
    13ae:	5f 91       	pop	r21
    13b0:	4f 91       	pop	r20
    13b2:	3f 91       	pop	r19
    13b4:	2f 91       	pop	r18
    13b6:	0f 90       	pop	r0
    13b8:	0b be       	out	0x3b, r0	; 59
    13ba:	0f 90       	pop	r0
    13bc:	09 be       	out	0x39, r0	; 57
    13be:	0f 90       	pop	r0
    13c0:	08 be       	out	0x38, r0	; 56
    13c2:	0f 90       	pop	r0
    13c4:	0f be       	out	0x3f, r0	; 63
    13c6:	0f 90       	pop	r0
    13c8:	1f 90       	pop	r1
    13ca:	18 95       	reti

000013cc <__vector_112>:
 *
 * This function will handle interrupt on Timer Counter F0 Compare/CaptureC and
 * call the callback function.
 */
ISR(TCF0_CCC_vect)
{
    13cc:	1f 92       	push	r1
    13ce:	0f 92       	push	r0
    13d0:	0f b6       	in	r0, 0x3f	; 63
    13d2:	0f 92       	push	r0
    13d4:	11 24       	eor	r1, r1
    13d6:	08 b6       	in	r0, 0x38	; 56
    13d8:	0f 92       	push	r0
    13da:	18 be       	out	0x38, r1	; 56
    13dc:	09 b6       	in	r0, 0x39	; 57
    13de:	0f 92       	push	r0
    13e0:	19 be       	out	0x39, r1	; 57
    13e2:	0b b6       	in	r0, 0x3b	; 59
    13e4:	0f 92       	push	r0
    13e6:	1b be       	out	0x3b, r1	; 59
    13e8:	2f 93       	push	r18
    13ea:	3f 93       	push	r19
    13ec:	4f 93       	push	r20
    13ee:	5f 93       	push	r21
    13f0:	6f 93       	push	r22
    13f2:	7f 93       	push	r23
    13f4:	8f 93       	push	r24
    13f6:	9f 93       	push	r25
    13f8:	af 93       	push	r26
    13fa:	bf 93       	push	r27
    13fc:	ef 93       	push	r30
    13fe:	ff 93       	push	r31
	if (tc_tcf0_ccc_callback) {
    1400:	e0 91 6a 20 	lds	r30, 0x206A	; 0x80206a <tc_tcf0_ccc_callback>
    1404:	f0 91 6b 20 	lds	r31, 0x206B	; 0x80206b <tc_tcf0_ccc_callback+0x1>
    1408:	30 97       	sbiw	r30, 0x00	; 0
    140a:	09 f0       	breq	.+2      	; 0x140e <__vector_112+0x42>
		tc_tcf0_ccc_callback();
    140c:	19 95       	eicall
	}
}
    140e:	ff 91       	pop	r31
    1410:	ef 91       	pop	r30
    1412:	bf 91       	pop	r27
    1414:	af 91       	pop	r26
    1416:	9f 91       	pop	r25
    1418:	8f 91       	pop	r24
    141a:	7f 91       	pop	r23
    141c:	6f 91       	pop	r22
    141e:	5f 91       	pop	r21
    1420:	4f 91       	pop	r20
    1422:	3f 91       	pop	r19
    1424:	2f 91       	pop	r18
    1426:	0f 90       	pop	r0
    1428:	0b be       	out	0x3b, r0	; 59
    142a:	0f 90       	pop	r0
    142c:	09 be       	out	0x39, r0	; 57
    142e:	0f 90       	pop	r0
    1430:	08 be       	out	0x38, r0	; 56
    1432:	0f 90       	pop	r0
    1434:	0f be       	out	0x3f, r0	; 63
    1436:	0f 90       	pop	r0
    1438:	1f 90       	pop	r1
    143a:	18 95       	reti

0000143c <__vector_113>:
 *
 * This function will handle interrupt on Timer Counter F0 Compare/CaptureD and
 * call the callback function.
 */
ISR(TCF0_CCD_vect)
{
    143c:	1f 92       	push	r1
    143e:	0f 92       	push	r0
    1440:	0f b6       	in	r0, 0x3f	; 63
    1442:	0f 92       	push	r0
    1444:	11 24       	eor	r1, r1
    1446:	08 b6       	in	r0, 0x38	; 56
    1448:	0f 92       	push	r0
    144a:	18 be       	out	0x38, r1	; 56
    144c:	09 b6       	in	r0, 0x39	; 57
    144e:	0f 92       	push	r0
    1450:	19 be       	out	0x39, r1	; 57
    1452:	0b b6       	in	r0, 0x3b	; 59
    1454:	0f 92       	push	r0
    1456:	1b be       	out	0x3b, r1	; 59
    1458:	2f 93       	push	r18
    145a:	3f 93       	push	r19
    145c:	4f 93       	push	r20
    145e:	5f 93       	push	r21
    1460:	6f 93       	push	r22
    1462:	7f 93       	push	r23
    1464:	8f 93       	push	r24
    1466:	9f 93       	push	r25
    1468:	af 93       	push	r26
    146a:	bf 93       	push	r27
    146c:	ef 93       	push	r30
    146e:	ff 93       	push	r31
	if (tc_tcf0_ccd_callback) {
    1470:	e0 91 68 20 	lds	r30, 0x2068	; 0x802068 <tc_tcf0_ccd_callback>
    1474:	f0 91 69 20 	lds	r31, 0x2069	; 0x802069 <tc_tcf0_ccd_callback+0x1>
    1478:	30 97       	sbiw	r30, 0x00	; 0
    147a:	09 f0       	breq	.+2      	; 0x147e <__vector_113+0x42>
		tc_tcf0_ccd_callback();
    147c:	19 95       	eicall
	}
}
    147e:	ff 91       	pop	r31
    1480:	ef 91       	pop	r30
    1482:	bf 91       	pop	r27
    1484:	af 91       	pop	r26
    1486:	9f 91       	pop	r25
    1488:	8f 91       	pop	r24
    148a:	7f 91       	pop	r23
    148c:	6f 91       	pop	r22
    148e:	5f 91       	pop	r21
    1490:	4f 91       	pop	r20
    1492:	3f 91       	pop	r19
    1494:	2f 91       	pop	r18
    1496:	0f 90       	pop	r0
    1498:	0b be       	out	0x3b, r0	; 59
    149a:	0f 90       	pop	r0
    149c:	09 be       	out	0x39, r0	; 57
    149e:	0f 90       	pop	r0
    14a0:	08 be       	out	0x38, r0	; 56
    14a2:	0f 90       	pop	r0
    14a4:	0f be       	out	0x3f, r0	; 63
    14a6:	0f 90       	pop	r0
    14a8:	1f 90       	pop	r1
    14aa:	18 95       	reti

000014ac <__vector_114>:
 *
 * This function will handle interrupt on Timer Counter F1 overflow and
 * call the callback function.
 */
ISR(TCF1_OVF_vect)
{
    14ac:	1f 92       	push	r1
    14ae:	0f 92       	push	r0
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	0f 92       	push	r0
    14b4:	11 24       	eor	r1, r1
    14b6:	08 b6       	in	r0, 0x38	; 56
    14b8:	0f 92       	push	r0
    14ba:	18 be       	out	0x38, r1	; 56
    14bc:	09 b6       	in	r0, 0x39	; 57
    14be:	0f 92       	push	r0
    14c0:	19 be       	out	0x39, r1	; 57
    14c2:	0b b6       	in	r0, 0x3b	; 59
    14c4:	0f 92       	push	r0
    14c6:	1b be       	out	0x3b, r1	; 59
    14c8:	2f 93       	push	r18
    14ca:	3f 93       	push	r19
    14cc:	4f 93       	push	r20
    14ce:	5f 93       	push	r21
    14d0:	6f 93       	push	r22
    14d2:	7f 93       	push	r23
    14d4:	8f 93       	push	r24
    14d6:	9f 93       	push	r25
    14d8:	af 93       	push	r26
    14da:	bf 93       	push	r27
    14dc:	ef 93       	push	r30
    14de:	ff 93       	push	r31
	if (tc_tcf1_ovf_callback) {
    14e0:	e0 91 66 20 	lds	r30, 0x2066	; 0x802066 <tc_tcf1_ovf_callback>
    14e4:	f0 91 67 20 	lds	r31, 0x2067	; 0x802067 <tc_tcf1_ovf_callback+0x1>
    14e8:	30 97       	sbiw	r30, 0x00	; 0
    14ea:	09 f0       	breq	.+2      	; 0x14ee <__vector_114+0x42>
		tc_tcf1_ovf_callback();
    14ec:	19 95       	eicall
	}
}
    14ee:	ff 91       	pop	r31
    14f0:	ef 91       	pop	r30
    14f2:	bf 91       	pop	r27
    14f4:	af 91       	pop	r26
    14f6:	9f 91       	pop	r25
    14f8:	8f 91       	pop	r24
    14fa:	7f 91       	pop	r23
    14fc:	6f 91       	pop	r22
    14fe:	5f 91       	pop	r21
    1500:	4f 91       	pop	r20
    1502:	3f 91       	pop	r19
    1504:	2f 91       	pop	r18
    1506:	0f 90       	pop	r0
    1508:	0b be       	out	0x3b, r0	; 59
    150a:	0f 90       	pop	r0
    150c:	09 be       	out	0x39, r0	; 57
    150e:	0f 90       	pop	r0
    1510:	08 be       	out	0x38, r0	; 56
    1512:	0f 90       	pop	r0
    1514:	0f be       	out	0x3f, r0	; 63
    1516:	0f 90       	pop	r0
    1518:	1f 90       	pop	r1
    151a:	18 95       	reti

0000151c <__vector_115>:
 *
 * This function will handle interrupt on Timer Counter F1 error and
 * call the callback function.
 */
ISR(TCF1_ERR_vect)
{
    151c:	1f 92       	push	r1
    151e:	0f 92       	push	r0
    1520:	0f b6       	in	r0, 0x3f	; 63
    1522:	0f 92       	push	r0
    1524:	11 24       	eor	r1, r1
    1526:	08 b6       	in	r0, 0x38	; 56
    1528:	0f 92       	push	r0
    152a:	18 be       	out	0x38, r1	; 56
    152c:	09 b6       	in	r0, 0x39	; 57
    152e:	0f 92       	push	r0
    1530:	19 be       	out	0x39, r1	; 57
    1532:	0b b6       	in	r0, 0x3b	; 59
    1534:	0f 92       	push	r0
    1536:	1b be       	out	0x3b, r1	; 59
    1538:	2f 93       	push	r18
    153a:	3f 93       	push	r19
    153c:	4f 93       	push	r20
    153e:	5f 93       	push	r21
    1540:	6f 93       	push	r22
    1542:	7f 93       	push	r23
    1544:	8f 93       	push	r24
    1546:	9f 93       	push	r25
    1548:	af 93       	push	r26
    154a:	bf 93       	push	r27
    154c:	ef 93       	push	r30
    154e:	ff 93       	push	r31
	if (tc_tcf1_err_callback) {
    1550:	e0 91 64 20 	lds	r30, 0x2064	; 0x802064 <tc_tcf1_err_callback>
    1554:	f0 91 65 20 	lds	r31, 0x2065	; 0x802065 <tc_tcf1_err_callback+0x1>
    1558:	30 97       	sbiw	r30, 0x00	; 0
    155a:	09 f0       	breq	.+2      	; 0x155e <__vector_115+0x42>
		tc_tcf1_err_callback();
    155c:	19 95       	eicall
	}
}
    155e:	ff 91       	pop	r31
    1560:	ef 91       	pop	r30
    1562:	bf 91       	pop	r27
    1564:	af 91       	pop	r26
    1566:	9f 91       	pop	r25
    1568:	8f 91       	pop	r24
    156a:	7f 91       	pop	r23
    156c:	6f 91       	pop	r22
    156e:	5f 91       	pop	r21
    1570:	4f 91       	pop	r20
    1572:	3f 91       	pop	r19
    1574:	2f 91       	pop	r18
    1576:	0f 90       	pop	r0
    1578:	0b be       	out	0x3b, r0	; 59
    157a:	0f 90       	pop	r0
    157c:	09 be       	out	0x39, r0	; 57
    157e:	0f 90       	pop	r0
    1580:	08 be       	out	0x38, r0	; 56
    1582:	0f 90       	pop	r0
    1584:	0f be       	out	0x3f, r0	; 63
    1586:	0f 90       	pop	r0
    1588:	1f 90       	pop	r1
    158a:	18 95       	reti

0000158c <__vector_116>:
 *
 * This function will handle interrupt on Timer Counter F1 Compare/CaptureA and
 * call the callback function.
 */
ISR(TCF1_CCA_vect)
{
    158c:	1f 92       	push	r1
    158e:	0f 92       	push	r0
    1590:	0f b6       	in	r0, 0x3f	; 63
    1592:	0f 92       	push	r0
    1594:	11 24       	eor	r1, r1
    1596:	08 b6       	in	r0, 0x38	; 56
    1598:	0f 92       	push	r0
    159a:	18 be       	out	0x38, r1	; 56
    159c:	09 b6       	in	r0, 0x39	; 57
    159e:	0f 92       	push	r0
    15a0:	19 be       	out	0x39, r1	; 57
    15a2:	0b b6       	in	r0, 0x3b	; 59
    15a4:	0f 92       	push	r0
    15a6:	1b be       	out	0x3b, r1	; 59
    15a8:	2f 93       	push	r18
    15aa:	3f 93       	push	r19
    15ac:	4f 93       	push	r20
    15ae:	5f 93       	push	r21
    15b0:	6f 93       	push	r22
    15b2:	7f 93       	push	r23
    15b4:	8f 93       	push	r24
    15b6:	9f 93       	push	r25
    15b8:	af 93       	push	r26
    15ba:	bf 93       	push	r27
    15bc:	ef 93       	push	r30
    15be:	ff 93       	push	r31
	if (tc_tcf1_cca_callback) {
    15c0:	e0 91 62 20 	lds	r30, 0x2062	; 0x802062 <tc_tcf1_cca_callback>
    15c4:	f0 91 63 20 	lds	r31, 0x2063	; 0x802063 <tc_tcf1_cca_callback+0x1>
    15c8:	30 97       	sbiw	r30, 0x00	; 0
    15ca:	09 f0       	breq	.+2      	; 0x15ce <__vector_116+0x42>
		tc_tcf1_cca_callback();
    15cc:	19 95       	eicall
	}
}
    15ce:	ff 91       	pop	r31
    15d0:	ef 91       	pop	r30
    15d2:	bf 91       	pop	r27
    15d4:	af 91       	pop	r26
    15d6:	9f 91       	pop	r25
    15d8:	8f 91       	pop	r24
    15da:	7f 91       	pop	r23
    15dc:	6f 91       	pop	r22
    15de:	5f 91       	pop	r21
    15e0:	4f 91       	pop	r20
    15e2:	3f 91       	pop	r19
    15e4:	2f 91       	pop	r18
    15e6:	0f 90       	pop	r0
    15e8:	0b be       	out	0x3b, r0	; 59
    15ea:	0f 90       	pop	r0
    15ec:	09 be       	out	0x39, r0	; 57
    15ee:	0f 90       	pop	r0
    15f0:	08 be       	out	0x38, r0	; 56
    15f2:	0f 90       	pop	r0
    15f4:	0f be       	out	0x3f, r0	; 63
    15f6:	0f 90       	pop	r0
    15f8:	1f 90       	pop	r1
    15fa:	18 95       	reti

000015fc <__vector_117>:
 *
 * This function will handle interrupt on Timer Counter F1 Compare/CaptureB and
 * call the callback function.
 */
ISR(TCF1_CCB_vect)
{
    15fc:	1f 92       	push	r1
    15fe:	0f 92       	push	r0
    1600:	0f b6       	in	r0, 0x3f	; 63
    1602:	0f 92       	push	r0
    1604:	11 24       	eor	r1, r1
    1606:	08 b6       	in	r0, 0x38	; 56
    1608:	0f 92       	push	r0
    160a:	18 be       	out	0x38, r1	; 56
    160c:	09 b6       	in	r0, 0x39	; 57
    160e:	0f 92       	push	r0
    1610:	19 be       	out	0x39, r1	; 57
    1612:	0b b6       	in	r0, 0x3b	; 59
    1614:	0f 92       	push	r0
    1616:	1b be       	out	0x3b, r1	; 59
    1618:	2f 93       	push	r18
    161a:	3f 93       	push	r19
    161c:	4f 93       	push	r20
    161e:	5f 93       	push	r21
    1620:	6f 93       	push	r22
    1622:	7f 93       	push	r23
    1624:	8f 93       	push	r24
    1626:	9f 93       	push	r25
    1628:	af 93       	push	r26
    162a:	bf 93       	push	r27
    162c:	ef 93       	push	r30
    162e:	ff 93       	push	r31
	if (tc_tcf1_ccb_callback) {
    1630:	e0 91 60 20 	lds	r30, 0x2060	; 0x802060 <__data_end>
    1634:	f0 91 61 20 	lds	r31, 0x2061	; 0x802061 <__data_end+0x1>
    1638:	30 97       	sbiw	r30, 0x00	; 0
    163a:	09 f0       	breq	.+2      	; 0x163e <__vector_117+0x42>
		tc_tcf1_ccb_callback();
    163c:	19 95       	eicall
	}
}
    163e:	ff 91       	pop	r31
    1640:	ef 91       	pop	r30
    1642:	bf 91       	pop	r27
    1644:	af 91       	pop	r26
    1646:	9f 91       	pop	r25
    1648:	8f 91       	pop	r24
    164a:	7f 91       	pop	r23
    164c:	6f 91       	pop	r22
    164e:	5f 91       	pop	r21
    1650:	4f 91       	pop	r20
    1652:	3f 91       	pop	r19
    1654:	2f 91       	pop	r18
    1656:	0f 90       	pop	r0
    1658:	0b be       	out	0x3b, r0	; 59
    165a:	0f 90       	pop	r0
    165c:	09 be       	out	0x39, r0	; 57
    165e:	0f 90       	pop	r0
    1660:	08 be       	out	0x38, r0	; 56
    1662:	0f 90       	pop	r0
    1664:	0f be       	out	0x3f, r0	; 63
    1666:	0f 90       	pop	r0
    1668:	1f 90       	pop	r1
    166a:	18 95       	reti

0000166c <getAltitude>:
 #include <asf.h>
 #include <math.h>
 #include "Calculations/Altitude/getAltitude.h"
 #include "Drivers/Pressure/getPressure.h"
 #include "Drivers/Temperature/getTemperature.h"
 float getAltitude(void){
    166c:	8f 92       	push	r8
    166e:	9f 92       	push	r9
    1670:	af 92       	push	r10
    1672:	bf 92       	push	r11
    1674:	cf 92       	push	r12
    1676:	df 92       	push	r13
    1678:	ef 92       	push	r14
    167a:	ff 92       	push	r15

	float temperature = getTemperature();
    167c:	0e 94 d3 14 	call	0x29a6	; 0x29a6 <getTemperature>
    1680:	4b 01       	movw	r8, r22
    1682:	5c 01       	movw	r10, r24
	float pressure = (float)getPressure();
    1684:	db d7       	rcall	.+4022   	; 0x263c <getPressure>
    1686:	0e 94 59 18 	call	0x30b2	; 0x30b2 <__floatsisf>
    168a:	9b 01       	movw	r18, r22
    168c:	ac 01       	movw	r20, r24
	
	float alt2 = log(pconst/pressure);

	//printf("pressure: %f\ntemperature: %f\nalt1:%f\nalt2:%f\n",pressure,temperature,alt1,alt2);

	return ((R * temperature)/g)*log(pconst/pressure);  //Equation found here: https://en.wikipedia.org/wiki/Hypsometric_equation 
    168e:	60 e8       	ldi	r22, 0x80	; 128
    1690:	76 ee       	ldi	r23, 0xE6	; 230
    1692:	85 ec       	ldi	r24, 0xC5	; 197
    1694:	97 e4       	ldi	r25, 0x47	; 71
    1696:	0e 94 b5 17 	call	0x2f6a	; 0x2f6a <__divsf3>
    169a:	0e 94 38 19 	call	0x3270	; 0x3270 <log>
    169e:	6b 01       	movw	r12, r22
    16a0:	7c 01       	movw	r14, r24
    16a2:	20 e0       	ldi	r18, 0x00	; 0
    16a4:	30 e8       	ldi	r19, 0x80	; 128
    16a6:	4f e8       	ldi	r20, 0x8F	; 143
    16a8:	53 e4       	ldi	r21, 0x43	; 67
    16aa:	c5 01       	movw	r24, r10
    16ac:	b4 01       	movw	r22, r8
    16ae:	0e 94 78 19 	call	0x32f0	; 0x32f0 <__mulsf3>
    16b2:	2a e0       	ldi	r18, 0x0A	; 10
    16b4:	38 ee       	ldi	r19, 0xE8	; 232
    16b6:	4c e1       	ldi	r20, 0x1C	; 28
    16b8:	51 e4       	ldi	r21, 0x41	; 65
    16ba:	0e 94 b5 17 	call	0x2f6a	; 0x2f6a <__divsf3>
    16be:	a7 01       	movw	r20, r14
    16c0:	96 01       	movw	r18, r12
    16c2:	0e 94 78 19 	call	0x32f0	; 0x32f0 <__mulsf3>
    16c6:	ff 90       	pop	r15
    16c8:	ef 90       	pop	r14
    16ca:	df 90       	pop	r13
    16cc:	cf 90       	pop	r12
    16ce:	bf 90       	pop	r11
    16d0:	af 90       	pop	r10
    16d2:	9f 90       	pop	r9
    16d4:	8f 90       	pop	r8
    16d6:	08 95       	ret

000016d8 <getVelocity>:
 #include "Calculations/Altitude/getAltitude.h"

 float exponentialSmoothing(float p_smth_vel, float current_vel);

 //Velocity function
 float getVelocity(void){
    16d8:	2f 92       	push	r2
    16da:	3f 92       	push	r3
    16dc:	4f 92       	push	r4
    16de:	5f 92       	push	r5
    16e0:	6f 92       	push	r6
    16e2:	7f 92       	push	r7
    16e4:	8f 92       	push	r8
    16e6:	9f 92       	push	r9
    16e8:	af 92       	push	r10
    16ea:	bf 92       	push	r11
    16ec:	cf 92       	push	r12
    16ee:	df 92       	push	r13
    16f0:	ef 92       	push	r14
    16f2:	ff 92       	push	r15
    16f4:	0f 93       	push	r16
    16f6:	1f 93       	push	r17
    16f8:	cf 93       	push	r28
    16fa:	df 93       	push	r29
    16fc:	cd b7       	in	r28, 0x3d	; 61
    16fe:	de b7       	in	r29, 0x3e	; 62
    1700:	c4 59       	subi	r28, 0x94	; 148
    1702:	d1 40       	sbci	r29, 0x01	; 1
    1704:	cd bf       	out	0x3d, r28	; 61
    1706:	de bf       	out	0x3e, r29	; 62
	float perms = 3.1249523;	
	float arr_alt[25]; //Creates an array of size 25 for altitude.
	float arr_vel[25]; //Velocity array.
	float arr_time[25]; //time array
	while ((TCF0.INTFLAGS<<7)!=0b10000000); //wait until interrupt is done.
    1708:	e0 e0       	ldi	r30, 0x00	; 0
    170a:	fb e0       	ldi	r31, 0x0B	; 11
    170c:	84 85       	ldd	r24, Z+12	; 0x0c
    170e:	81 30       	cpi	r24, 0x01	; 1
    1710:	e9 f7       	brne	.-6      	; 0x170c <getVelocity+0x34>
	float final_alt = getAltitude(); //sets final altitude for the loop to the current altitude.
    1712:	ac df       	rcall	.-168    	; 0x166c <getAltitude>
    1714:	2b 01       	movw	r4, r22
    1716:	3c 01       	movw	r6, r24
    1718:	8e 01       	movw	r16, r28
    171a:	0f 5f       	subi	r16, 0xFF	; 255
    171c:	1f 4f       	sbci	r17, 0xFF	; 255
    171e:	5e 01       	movw	r10, r28
    1720:	89 ec       	ldi	r24, 0xC9	; 201
    1722:	a8 0e       	add	r10, r24
    1724:	b1 1c       	adc	r11, r1
    1726:	4e 01       	movw	r8, r28
    1728:	a5 e6       	ldi	r26, 0x65	; 101
    172a:	8a 0e       	add	r8, r26
    172c:	91 1c       	adc	r9, r1
    172e:	68 01       	movw	r12, r16
	for(int i = 0; i < 25; i++){ //For each element in altTable
		while ((TCF0.INTFLAGS<<7)!=0b10000000); //wait until TCF0 overflows, which will take 10ms
    1730:	0f 2e       	mov	r0, r31
    1732:	e1 2c       	mov	r14, r1
    1734:	fb e0       	ldi	r31, 0x0B	; 11
    1736:	ff 2e       	mov	r15, r31
    1738:	f0 2d       	mov	r31, r0
    173a:	f7 01       	movw	r30, r14
    173c:	84 85       	ldd	r24, Z+12	; 0x0c
    173e:	81 30       	cpi	r24, 0x01	; 1
    1740:	e1 f7       	brne	.-8      	; 0x173a <getVelocity+0x62>
		
		//delay_ms(10); //Delay for 10ms, creates a sample rate for velocity of 100Hz. 
		arr_alt[i] = final_alt - getAltitude(); //Set the current element to the delta altitude found with final altitude of the previous iteration subtracted by the current altitude.
    1742:	94 df       	rcall	.-216    	; 0x166c <getAltitude>
    1744:	9b 01       	movw	r18, r22
    1746:	ac 01       	movw	r20, r24
    1748:	c3 01       	movw	r24, r6
    174a:	b2 01       	movw	r22, r4
    174c:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <__subsf3>
    1750:	d6 01       	movw	r26, r12
    1752:	6d 93       	st	X+, r22
    1754:	7d 93       	st	X+, r23
    1756:	8d 93       	st	X+, r24
    1758:	9d 93       	st	X+, r25
    175a:	6d 01       	movw	r12, r26

		arr_time[i] = TCF0.CNT/perms + 10; //time element array is one ahead so we can record the change in time + 10ms for the timer counter.
    175c:	f7 01       	movw	r30, r14
    175e:	60 a1       	ldd	r22, Z+32	; 0x20
    1760:	71 a1       	ldd	r23, Z+33	; 0x21
    1762:	80 e0       	ldi	r24, 0x00	; 0
    1764:	90 e0       	ldi	r25, 0x00	; 0
    1766:	0e 94 57 18 	call	0x30ae	; 0x30ae <__floatunsisf>
    176a:	28 e3       	ldi	r18, 0x38	; 56
    176c:	3f ef       	ldi	r19, 0xFF	; 255
    176e:	47 e4       	ldi	r20, 0x47	; 71
    1770:	50 e4       	ldi	r21, 0x40	; 64
    1772:	0e 94 b5 17 	call	0x2f6a	; 0x2f6a <__divsf3>
    1776:	20 e0       	ldi	r18, 0x00	; 0
    1778:	30 e0       	ldi	r19, 0x00	; 0
    177a:	40 e2       	ldi	r20, 0x20	; 32
    177c:	51 e4       	ldi	r21, 0x41	; 65
    177e:	0e 94 51 17 	call	0x2ea2	; 0x2ea2 <__addsf3>
    1782:	d5 01       	movw	r26, r10
    1784:	6d 93       	st	X+, r22
    1786:	7d 93       	st	X+, r23
    1788:	8d 93       	st	X+, r24
    178a:	9d 93       	st	X+, r25
    178c:	5d 01       	movw	r10, r26
		
		final_alt = getAltitude(); //Sets the final altitude for the iteration to the current altitude.
    178e:	6e df       	rcall	.-292    	; 0x166c <getAltitude>
    1790:	2b 01       	movw	r4, r22
    1792:	3c 01       	movw	r6, r24
	float arr_alt[25]; //Creates an array of size 25 for altitude.
	float arr_vel[25]; //Velocity array.
	float arr_time[25]; //time array
	while ((TCF0.INTFLAGS<<7)!=0b10000000); //wait until interrupt is done.
	float final_alt = getAltitude(); //sets final altitude for the loop to the current altitude.
	for(int i = 0; i < 25; i++){ //For each element in altTable
    1794:	c8 14       	cp	r12, r8
    1796:	d9 04       	cpc	r13, r9
    1798:	81 f6       	brne	.-96     	; 0x173a <getVelocity+0x62>
    179a:	4e 01       	movw	r8, r28
    179c:	bd ec       	ldi	r27, 0xCD	; 205
    179e:	8b 0e       	add	r8, r27
    17a0:	91 1c       	adc	r9, r1
    17a2:	5e 01       	movw	r10, r28
    17a4:	e9 e6       	ldi	r30, 0x69	; 105
    17a6:	ae 0e       	add	r10, r30
    17a8:	b1 1c       	adc	r11, r1
    17aa:	1e 01       	movw	r2, r28
    17ac:	f1 e6       	ldi	r31, 0x61	; 97
    17ae:	2f 0e       	add	r2, r31
    17b0:	31 1c       	adc	r3, r1
    17b2:	35 01       	movw	r6, r10
    17b4:	f8 01       	movw	r30, r16
    17b6:	0c 5f       	subi	r16, 0xFC	; 252
    17b8:	1f 4f       	sbci	r17, 0xFF	; 255
		final_alt = getAltitude(); //Sets the final altitude for the iteration to the current altitude.
	}

	//Attempt at numerical differentiation.
	for(int z = 1; z < 25; z++){
		arr_vel[z] = (arr_alt[z+1] - arr_alt[z-1])/(2*arr_time[z]); //Approximated velocity using a centered difference scheme, reduces noise from taking the derivative.
    17ba:	d4 01       	movw	r26, r8
    17bc:	cd 90       	ld	r12, X+
    17be:	dd 90       	ld	r13, X+
    17c0:	ed 90       	ld	r14, X+
    17c2:	fd 90       	ld	r15, X+
    17c4:	4d 01       	movw	r8, r26
    17c6:	20 81       	ld	r18, Z
    17c8:	31 81       	ldd	r19, Z+1	; 0x01
    17ca:	42 81       	ldd	r20, Z+2	; 0x02
    17cc:	53 81       	ldd	r21, Z+3	; 0x03
    17ce:	60 85       	ldd	r22, Z+8	; 0x08
    17d0:	71 85       	ldd	r23, Z+9	; 0x09
    17d2:	82 85       	ldd	r24, Z+10	; 0x0a
    17d4:	93 85       	ldd	r25, Z+11	; 0x0b
    17d6:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <__subsf3>
    17da:	cf 56       	subi	r28, 0x6F	; 111
    17dc:	de 4f       	sbci	r29, 0xFE	; 254
    17de:	68 83       	st	Y, r22
    17e0:	79 83       	std	Y+1, r23	; 0x01
    17e2:	8a 83       	std	Y+2, r24	; 0x02
    17e4:	9b 83       	std	Y+3, r25	; 0x03
    17e6:	c1 59       	subi	r28, 0x91	; 145
    17e8:	d1 40       	sbci	r29, 0x01	; 1
    17ea:	a7 01       	movw	r20, r14
    17ec:	96 01       	movw	r18, r12
    17ee:	c7 01       	movw	r24, r14
    17f0:	b6 01       	movw	r22, r12
    17f2:	0e 94 51 17 	call	0x2ea2	; 0x2ea2 <__addsf3>
    17f6:	9b 01       	movw	r18, r22
    17f8:	ac 01       	movw	r20, r24
    17fa:	cf 56       	subi	r28, 0x6F	; 111
    17fc:	de 4f       	sbci	r29, 0xFE	; 254
    17fe:	68 81       	ld	r22, Y
    1800:	79 81       	ldd	r23, Y+1	; 0x01
    1802:	8a 81       	ldd	r24, Y+2	; 0x02
    1804:	9b 81       	ldd	r25, Y+3	; 0x03
    1806:	c1 59       	subi	r28, 0x91	; 145
    1808:	d1 40       	sbci	r29, 0x01	; 1
    180a:	0e 94 b5 17 	call	0x2f6a	; 0x2f6a <__divsf3>
    180e:	f3 01       	movw	r30, r6
    1810:	61 93       	st	Z+, r22
    1812:	71 93       	st	Z+, r23
    1814:	81 93       	st	Z+, r24
    1816:	91 93       	st	Z+, r25
    1818:	3f 01       	movw	r6, r30
		
		final_alt = getAltitude(); //Sets the final altitude for the iteration to the current altitude.
	}

	//Attempt at numerical differentiation.
	for(int z = 1; z < 25; z++){
    181a:	02 15       	cp	r16, r2
    181c:	13 05       	cpc	r17, r3
    181e:	51 f6       	brne	.-108    	; 0x17b4 <getVelocity+0xdc>
		arr_vel[z] = (arr_alt[z+1] - arr_alt[z-1])/(2*arr_time[z]); //Approximated velocity using a centered difference scheme, reduces noise from taking the derivative.
	}

	arr_vel[0] = arr_alt[0]/(arr_time[0] + 10); //Still need to get the first velocity, time was missing ~10ms.
    1820:	20 e0       	ldi	r18, 0x00	; 0
    1822:	30 e0       	ldi	r19, 0x00	; 0
    1824:	40 e2       	ldi	r20, 0x20	; 32
    1826:	51 e4       	ldi	r21, 0x41	; 65
    1828:	c7 53       	subi	r28, 0x37	; 55
    182a:	df 4f       	sbci	r29, 0xFF	; 255
    182c:	68 81       	ld	r22, Y
    182e:	79 81       	ldd	r23, Y+1	; 0x01
    1830:	8a 81       	ldd	r24, Y+2	; 0x02
    1832:	9b 81       	ldd	r25, Y+3	; 0x03
    1834:	c9 5c       	subi	r28, 0xC9	; 201
    1836:	d0 40       	sbci	r29, 0x00	; 0
    1838:	0e 94 51 17 	call	0x2ea2	; 0x2ea2 <__addsf3>
    183c:	9b 01       	movw	r18, r22
    183e:	ac 01       	movw	r20, r24
    1840:	69 81       	ldd	r22, Y+1	; 0x01
    1842:	7a 81       	ldd	r23, Y+2	; 0x02
    1844:	8b 81       	ldd	r24, Y+3	; 0x03
    1846:	9c 81       	ldd	r25, Y+4	; 0x04
    1848:	0e 94 b5 17 	call	0x2f6a	; 0x2f6a <__divsf3>
    184c:	a9 96       	adiw	r28, 0x29	; 41
    184e:	6c af       	std	Y+60, r22	; 0x3c
    1850:	7d af       	std	Y+61, r23	; 0x3d
    1852:	8e af       	std	Y+62, r24	; 0x3e
    1854:	9f af       	std	Y+63, r25	; 0x3f
    1856:	a9 97       	sbiw	r28, 0x29	; 41

	//Now we know the velocity for 25 different samples over a total of 250ms. We now need to exponentially smooth the data to reduce noise again.

	float a_smooth[25]; //Smoothed velocity table of size 25.
	a_smooth[0] = arr_vel[0]; //Sets the initial smoothed value to the first velocity taken.
    1858:	c3 5d       	subi	r28, 0xD3	; 211
    185a:	de 4f       	sbci	r29, 0xFE	; 254
    185c:	68 83       	st	Y, r22
    185e:	79 83       	std	Y+1, r23	; 0x01
    1860:	8a 83       	std	Y+2, r24	; 0x02
    1862:	9b 83       	std	Y+3, r25	; 0x03
    1864:	cd 52       	subi	r28, 0x2D	; 45
    1866:	d1 40       	sbci	r29, 0x01	; 1
    1868:	8e 01       	movw	r16, r28
    186a:	03 5d       	subi	r16, 0xD3	; 211
    186c:	1e 4f       	sbci	r17, 0xFE	; 254
    186e:	7e 01       	movw	r14, r28
    1870:	f3 e7       	ldi	r31, 0x73	; 115
    1872:	ef 1a       	sub	r14, r31
    1874:	fe ef       	ldi	r31, 0xFE	; 254
    1876:	ff 0a       	sbc	r15, r31
	for(int j = 1; j < 25; j++){ //For our 24 elements of velocity..
		a_smooth[j] = exponentialSmoothing(a_smooth[j - 1], arr_vel[j]); //For the current element of smoothed velocity, set it equal to the value that our exponential smoothing function gives us. We input the previous value for the smoothed table as our forecast/second variable, then the element of velocity at the current position. 
    1878:	d5 01       	movw	r26, r10
    187a:	6d 91       	ld	r22, X+
    187c:	7d 91       	ld	r23, X+
    187e:	8d 91       	ld	r24, X+
    1880:	9d 91       	ld	r25, X+
    1882:	5d 01       	movw	r10, r26
    1884:	f8 01       	movw	r30, r16
    1886:	41 90       	ld	r4, Z+
    1888:	51 90       	ld	r5, Z+
    188a:	61 90       	ld	r6, Z+
    188c:	71 90       	ld	r7, Z+
    188e:	8f 01       	movw	r16, r30
	return s_vel/24; //The function finally ends with returning the average, or the sum of our 24 elements of velocity divided by 24.
 }

 float exponentialSmoothing(float p_smth_vel, float current_vel){ //We need the previous smoothed value as well as the current un-smoothed value, as indicated by the equation on this page: https://en.wikipedia.org/wiki/Exponential_smoothing#Basic_exponential_smoothing
	float smooth_factor = .2; //20% smoothing factor, needs to be tested.
	return (current_vel * smooth_factor) + (p_smth_vel * (1 - smooth_factor)); //returns the smoothed velocity for the current position of our table! That wasn't so hard, was it?
    1890:	2d ec       	ldi	r18, 0xCD	; 205
    1892:	3c ec       	ldi	r19, 0xCC	; 204
    1894:	4c e4       	ldi	r20, 0x4C	; 76
    1896:	5e e3       	ldi	r21, 0x3E	; 62
    1898:	0e 94 78 19 	call	0x32f0	; 0x32f0 <__mulsf3>
    189c:	cf 56       	subi	r28, 0x6F	; 111
    189e:	de 4f       	sbci	r29, 0xFE	; 254
    18a0:	68 83       	st	Y, r22
    18a2:	79 83       	std	Y+1, r23	; 0x01
    18a4:	8a 83       	std	Y+2, r24	; 0x02
    18a6:	9b 83       	std	Y+3, r25	; 0x03
    18a8:	c1 59       	subi	r28, 0x91	; 145
    18aa:	d1 40       	sbci	r29, 0x01	; 1
    18ac:	2d ec       	ldi	r18, 0xCD	; 205
    18ae:	3c ec       	ldi	r19, 0xCC	; 204
    18b0:	4c e4       	ldi	r20, 0x4C	; 76
    18b2:	5f e3       	ldi	r21, 0x3F	; 63
    18b4:	c3 01       	movw	r24, r6
    18b6:	b2 01       	movw	r22, r4
    18b8:	0e 94 78 19 	call	0x32f0	; 0x32f0 <__mulsf3>
    18bc:	9b 01       	movw	r18, r22
    18be:	ac 01       	movw	r20, r24
    18c0:	cf 56       	subi	r28, 0x6F	; 111
    18c2:	de 4f       	sbci	r29, 0xFE	; 254
    18c4:	68 81       	ld	r22, Y
    18c6:	79 81       	ldd	r23, Y+1	; 0x01
    18c8:	8a 81       	ldd	r24, Y+2	; 0x02
    18ca:	9b 81       	ldd	r25, Y+3	; 0x03
    18cc:	c1 59       	subi	r28, 0x91	; 145
    18ce:	d1 40       	sbci	r29, 0x01	; 1
    18d0:	0e 94 51 17 	call	0x2ea2	; 0x2ea2 <__addsf3>
	//Now we know the velocity for 25 different samples over a total of 250ms. We now need to exponentially smooth the data to reduce noise again.

	float a_smooth[25]; //Smoothed velocity table of size 25.
	a_smooth[0] = arr_vel[0]; //Sets the initial smoothed value to the first velocity taken.
	for(int j = 1; j < 25; j++){ //For our 24 elements of velocity..
		a_smooth[j] = exponentialSmoothing(a_smooth[j - 1], arr_vel[j]); //For the current element of smoothed velocity, set it equal to the value that our exponential smoothing function gives us. We input the previous value for the smoothed table as our forecast/second variable, then the element of velocity at the current position. 
    18d4:	d8 01       	movw	r26, r16
    18d6:	6d 93       	st	X+, r22
    18d8:	7d 93       	st	X+, r23
    18da:	8d 93       	st	X+, r24
    18dc:	9c 93       	st	X, r25
    18de:	13 97       	sbiw	r26, 0x03	; 3

	//Now we know the velocity for 25 different samples over a total of 250ms. We now need to exponentially smooth the data to reduce noise again.

	float a_smooth[25]; //Smoothed velocity table of size 25.
	a_smooth[0] = arr_vel[0]; //Sets the initial smoothed value to the first velocity taken.
	for(int j = 1; j < 25; j++){ //For our 24 elements of velocity..
    18e0:	0e 15       	cp	r16, r14
    18e2:	1f 05       	cpc	r17, r15
    18e4:	49 f6       	brne	.-110    	; 0x1878 <getVelocity+0x1a0>
    18e6:	8e 01       	movw	r16, r28
    18e8:	0f 5c       	subi	r16, 0xCF	; 207
    18ea:	1e 4f       	sbci	r17, 0xFE	; 254
    18ec:	7e 01       	movw	r14, r28
    18ee:	bf e6       	ldi	r27, 0x6F	; 111
    18f0:	eb 1a       	sub	r14, r27
    18f2:	be ef       	ldi	r27, 0xFE	; 254
    18f4:	fb 0a       	sbc	r15, r27
    18f6:	60 e0       	ldi	r22, 0x00	; 0
    18f8:	70 e0       	ldi	r23, 0x00	; 0
    18fa:	cb 01       	movw	r24, r22
		a_smooth[j] = exponentialSmoothing(a_smooth[j - 1], arr_vel[j]); //For the current element of smoothed velocity, set it equal to the value that our exponential smoothing function gives us. We input the previous value for the smoothed table as our forecast/second variable, then the element of velocity at the current position. 
	}
	float s_vel = 0; //Summed velocity so we can average it.
	for(int b = 1; b < 25; b++) //For our size 25 smoothed velocity table, we want to ignore the first value because it is a duplicate, then iterate through every other value.
		s_vel += a_smooth[b]; //Set the sum of velocity equal to itself plus the element at our current position. Sums up all of the values in our table.
    18fc:	f8 01       	movw	r30, r16
    18fe:	21 91       	ld	r18, Z+
    1900:	31 91       	ld	r19, Z+
    1902:	41 91       	ld	r20, Z+
    1904:	51 91       	ld	r21, Z+
    1906:	8f 01       	movw	r16, r30
    1908:	0e 94 51 17 	call	0x2ea2	; 0x2ea2 <__addsf3>
	a_smooth[0] = arr_vel[0]; //Sets the initial smoothed value to the first velocity taken.
	for(int j = 1; j < 25; j++){ //For our 24 elements of velocity..
		a_smooth[j] = exponentialSmoothing(a_smooth[j - 1], arr_vel[j]); //For the current element of smoothed velocity, set it equal to the value that our exponential smoothing function gives us. We input the previous value for the smoothed table as our forecast/second variable, then the element of velocity at the current position. 
	}
	float s_vel = 0; //Summed velocity so we can average it.
	for(int b = 1; b < 25; b++) //For our size 25 smoothed velocity table, we want to ignore the first value because it is a duplicate, then iterate through every other value.
    190c:	0e 15       	cp	r16, r14
    190e:	1f 05       	cpc	r17, r15
    1910:	a9 f7       	brne	.-22     	; 0x18fc <getVelocity+0x224>
		s_vel += a_smooth[b]; //Set the sum of velocity equal to itself plus the element at our current position. Sums up all of the values in our table.
	return s_vel/24; //The function finally ends with returning the average, or the sum of our 24 elements of velocity divided by 24.
    1912:	20 e0       	ldi	r18, 0x00	; 0
    1914:	30 e0       	ldi	r19, 0x00	; 0
    1916:	40 ec       	ldi	r20, 0xC0	; 192
    1918:	51 e4       	ldi	r21, 0x41	; 65
    191a:	0e 94 b5 17 	call	0x2f6a	; 0x2f6a <__divsf3>
 }
    191e:	cc 56       	subi	r28, 0x6C	; 108
    1920:	de 4f       	sbci	r29, 0xFE	; 254
    1922:	cd bf       	out	0x3d, r28	; 61
    1924:	de bf       	out	0x3e, r29	; 62
    1926:	df 91       	pop	r29
    1928:	cf 91       	pop	r28
    192a:	1f 91       	pop	r17
    192c:	0f 91       	pop	r16
    192e:	ff 90       	pop	r15
    1930:	ef 90       	pop	r14
    1932:	df 90       	pop	r13
    1934:	cf 90       	pop	r12
    1936:	bf 90       	pop	r11
    1938:	af 90       	pop	r10
    193a:	9f 90       	pop	r9
    193c:	8f 90       	pop	r8
    193e:	7f 90       	pop	r7
    1940:	6f 90       	pop	r6
    1942:	5f 90       	pop	r5
    1944:	4f 90       	pop	r4
    1946:	3f 90       	pop	r3
    1948:	2f 90       	pop	r2
    194a:	08 95       	ret

0000194c <LED>:
 *  Author: seanw
 */ 
  /* LED method for two XPEBGR-L1-0000-00G01-SB01 LEDs */
  #include <asf.h>
  #include "Drivers/Outputs/LED/LED_driver.h"
  void LED(uint16_t period,uint8_t duty_cycle){
    194c:	9c 01       	movw	r18, r24
	  PORTD.OUT |= 0b00000010; //out, high = 1, low = 0.
    194e:	e0 e6       	ldi	r30, 0x60	; 96
    1950:	f6 e0       	ldi	r31, 0x06	; 6
    1952:	94 81       	ldd	r25, Z+4	; 0x04
    1954:	92 60       	ori	r25, 0x02	; 2
    1956:	94 83       	std	Z+4, r25	; 0x04

	  TCD0.PER = period; //Set period of output.
    1958:	e0 e0       	ldi	r30, 0x00	; 0
    195a:	f9 e0       	ldi	r31, 0x09	; 9
    195c:	26 a3       	std	Z+38, r18	; 0x26
    195e:	37 a3       	std	Z+39, r19	; 0x27
	  TCD0.CCB = TCD0.PER - (TCD0.PER/duty_cycle); //Set duty cycle of output for Command Capture register A.
    1960:	26 a1       	ldd	r18, Z+38	; 0x26
    1962:	37 a1       	ldd	r19, Z+39	; 0x27
    1964:	86 a1       	ldd	r24, Z+38	; 0x26
    1966:	97 a1       	ldd	r25, Z+39	; 0x27
    1968:	70 e0       	ldi	r23, 0x00	; 0
    196a:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <__udivmodhi4>
    196e:	26 1b       	sub	r18, r22
    1970:	37 0b       	sbc	r19, r23
    1972:	22 a7       	std	Z+42, r18	; 0x2a
    1974:	33 a7       	std	Z+43, r19	; 0x2b
    1976:	08 95       	ret

00001978 <lightChase>:
	
	return (uint16_t)(voltage*1000); //voltage*1000 converts it into millivolts.
	//If we hadn't multiplied by 1000, the typecast would've truncated the voltage reading to just the one's place.

	delay_ms(delay);
}
    1978:	af 92       	push	r10
    197a:	bf 92       	push	r11
    197c:	cf 92       	push	r12
    197e:	df 92       	push	r13
    1980:	ef 92       	push	r14
    1982:	ff 92       	push	r15
    1984:	0f 93       	push	r16
    1986:	1f 93       	push	r17
    1988:	cf 93       	push	r28
    198a:	df 93       	push	r29
    198c:	91 e0       	ldi	r25, 0x01	; 1
    198e:	90 93 c0 20 	sts	0x20C0, r25	; 0x8020c0 <lightNumber>
    1992:	a1 2c       	mov	r10, r1
    1994:	0f 2e       	mov	r0, r31
    1996:	f8 e4       	ldi	r31, 0x48	; 72
    1998:	bf 2e       	mov	r11, r31
    199a:	f0 2d       	mov	r31, r0
    199c:	0f 2e       	mov	r0, r31
    199e:	f8 ee       	ldi	r31, 0xE8	; 232
    19a0:	cf 2e       	mov	r12, r31
    19a2:	f0 2d       	mov	r31, r0
    19a4:	dd 24       	eor	r13, r13
    19a6:	d3 94       	inc	r13
    19a8:	e1 2c       	mov	r14, r1
    19aa:	f1 2c       	mov	r15, r1
    19ac:	00 e0       	ldi	r16, 0x00	; 0
    19ae:	10 e0       	ldi	r17, 0x00	; 0
    19b0:	28 2f       	mov	r18, r24
    19b2:	30 e0       	ldi	r19, 0x00	; 0
    19b4:	40 e0       	ldi	r20, 0x00	; 0
    19b6:	50 e0       	ldi	r21, 0x00	; 0
    19b8:	60 e0       	ldi	r22, 0x00	; 0
    19ba:	70 e0       	ldi	r23, 0x00	; 0
    19bc:	80 e0       	ldi	r24, 0x00	; 0
    19be:	90 e0       	ldi	r25, 0x00	; 0
    19c0:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <__muldi3>
    19c4:	29 51       	subi	r18, 0x19	; 25
    19c6:	3c 4f       	sbci	r19, 0xFC	; 252
    19c8:	4f 4f       	sbci	r20, 0xFF	; 255
    19ca:	5f 4f       	sbci	r21, 0xFF	; 255
    19cc:	6f 4f       	sbci	r22, 0xFF	; 255
    19ce:	7f 4f       	sbci	r23, 0xFF	; 255
    19d0:	8f 4f       	sbci	r24, 0xFF	; 255
    19d2:	9f 4f       	sbci	r25, 0xFF	; 255
    19d4:	0e 94 94 18 	call	0x3128	; 0x3128 <__floatundisf>
    19d8:	20 e0       	ldi	r18, 0x00	; 0
    19da:	30 e8       	ldi	r19, 0x80	; 128
    19dc:	4b eb       	ldi	r20, 0xBB	; 187
    19de:	55 e4       	ldi	r21, 0x45	; 69
    19e0:	0e 94 b5 17 	call	0x2f6a	; 0x2f6a <__divsf3>
    19e4:	0e 94 22 18 	call	0x3044	; 0x3044 <__fixunssfdi>
    19e8:	72 2f       	mov	r23, r18
    19ea:	63 2f       	mov	r22, r19
    19ec:	94 2f       	mov	r25, r20
    19ee:	85 2f       	mov	r24, r21
    19f0:	54 2f       	mov	r21, r20
    19f2:	48 2f       	mov	r20, r24
    19f4:	24 e0       	ldi	r18, 0x04	; 4
    19f6:	30 e0       	ldi	r19, 0x00	; 0
    19f8:	c0 e8       	ldi	r28, 0x80	; 128
    19fa:	d6 e0       	ldi	r29, 0x06	; 6
    19fc:	07 2f       	mov	r16, r23
    19fe:	16 2f       	mov	r17, r22
    1a00:	f9 2f       	mov	r31, r25
    1a02:	e8 2f       	mov	r30, r24
    1a04:	80 91 c0 20 	lds	r24, 0x20C0	; 0x8020c0 <lightNumber>
    1a08:	98 2f       	mov	r25, r24
    1a0a:	90 95       	com	r25
    1a0c:	9c 83       	std	Y+4, r25	; 0x04
    1a0e:	88 0f       	add	r24, r24
    1a10:	80 93 c0 20 	sts	0x20C0, r24	; 0x8020c0 <lightNumber>
    1a14:	80 2f       	mov	r24, r16
    1a16:	91 2f       	mov	r25, r17
    1a18:	af 2f       	mov	r26, r31
    1a1a:	be 2f       	mov	r27, r30
    1a1c:	01 97       	sbiw	r24, 0x01	; 1
    1a1e:	a1 09       	sbc	r26, r1
    1a20:	b1 09       	sbc	r27, r1
    1a22:	e1 f7       	brne	.-8      	; 0x1a1c <lightChase+0xa4>
    1a24:	21 50       	subi	r18, 0x01	; 1
    1a26:	31 09       	sbc	r19, r1
    1a28:	69 f7       	brne	.-38     	; 0x1a04 <lightChase+0x8c>
    1a2a:	80 e8       	ldi	r24, 0x80	; 128
    1a2c:	80 93 c0 20 	sts	0x20C0, r24	; 0x8020c0 <lightNumber>
    1a30:	24 e0       	ldi	r18, 0x04	; 4
    1a32:	30 e0       	ldi	r19, 0x00	; 0
    1a34:	e0 e8       	ldi	r30, 0x80	; 128
    1a36:	f6 e0       	ldi	r31, 0x06	; 6
    1a38:	80 91 c0 20 	lds	r24, 0x20C0	; 0x8020c0 <lightNumber>
    1a3c:	98 2f       	mov	r25, r24
    1a3e:	90 95       	com	r25
    1a40:	94 83       	std	Z+4, r25	; 0x04
    1a42:	86 95       	lsr	r24
    1a44:	80 93 c0 20 	sts	0x20C0, r24	; 0x8020c0 <lightNumber>
    1a48:	87 2f       	mov	r24, r23
    1a4a:	96 2f       	mov	r25, r22
    1a4c:	a5 2f       	mov	r26, r21
    1a4e:	b4 2f       	mov	r27, r20
    1a50:	01 97       	sbiw	r24, 0x01	; 1
    1a52:	a1 09       	sbc	r26, r1
    1a54:	b1 09       	sbc	r27, r1
    1a56:	e1 f7       	brne	.-8      	; 0x1a50 <lightChase+0xd8>
    1a58:	21 50       	subi	r18, 0x01	; 1
    1a5a:	31 09       	sbc	r19, r1
    1a5c:	69 f7       	brne	.-38     	; 0x1a38 <lightChase+0xc0>
    1a5e:	df 91       	pop	r29
    1a60:	cf 91       	pop	r28
    1a62:	1f 91       	pop	r17
    1a64:	0f 91       	pop	r16
    1a66:	ff 90       	pop	r15
    1a68:	ef 90       	pop	r14
    1a6a:	df 90       	pop	r13
    1a6c:	cf 90       	pop	r12
    1a6e:	bf 90       	pop	r11
    1a70:	af 90       	pop	r10
    1a72:	08 95       	ret

00001a74 <test>:

void test(void){
	lightChase(100);
    1a74:	84 e6       	ldi	r24, 0x64	; 100
    1a76:	80 df       	rcall	.-256    	; 0x1978 <lightChase>
	printf("Test:\n");
    1a78:	8d e0       	ldi	r24, 0x0D	; 13
    1a7a:	90 e2       	ldi	r25, 0x20	; 32
    1a7c:	0e 94 14 20 	call	0x4028	; 0x4028 <puts>
	printf("Pressure is:%li\n",getPressure());
    1a80:	dd d5       	rcall	.+3002   	; 0x263c <getPressure>
    1a82:	9f 93       	push	r25
    1a84:	8f 93       	push	r24
    1a86:	7f 93       	push	r23
    1a88:	6f 93       	push	r22
    1a8a:	83 e1       	ldi	r24, 0x13	; 19
    1a8c:	90 e2       	ldi	r25, 0x20	; 32
    1a8e:	9f 93       	push	r25
    1a90:	8f 93       	push	r24
    1a92:	0e 94 01 20 	call	0x4002	; 0x4002 <printf>
	printf("Temperature is:%.2f\n",getTemperature());
    1a96:	87 d7       	rcall	.+3854   	; 0x29a6 <getTemperature>
    1a98:	9f 93       	push	r25
    1a9a:	8f 93       	push	r24
    1a9c:	7f 93       	push	r23
    1a9e:	6f 93       	push	r22
    1aa0:	84 e2       	ldi	r24, 0x24	; 36
    1aa2:	90 e2       	ldi	r25, 0x20	; 32
    1aa4:	9f 93       	push	r25
    1aa6:	8f 93       	push	r24
    1aa8:	0e 94 01 20 	call	0x4002	; 0x4002 <printf>
	printf("Altitude is:%.2f\n",getAltitude());
    1aac:	df dd       	rcall	.-1090   	; 0x166c <getAltitude>
    1aae:	9f 93       	push	r25
    1ab0:	8f 93       	push	r24
    1ab2:	7f 93       	push	r23
    1ab4:	6f 93       	push	r22
    1ab6:	89 e3       	ldi	r24, 0x39	; 57
    1ab8:	90 e2       	ldi	r25, 0x20	; 32
    1aba:	9f 93       	push	r25
    1abc:	8f 93       	push	r24
    1abe:	0e 94 01 20 	call	0x4002	; 0x4002 <printf>
	printf("and velocity is:%i\n",getVelocity());
    1ac2:	0a de       	rcall	.-1004   	; 0x16d8 <getVelocity>
    1ac4:	9f 93       	push	r25
    1ac6:	8f 93       	push	r24
    1ac8:	7f 93       	push	r23
    1aca:	6f 93       	push	r22
    1acc:	8b e4       	ldi	r24, 0x4B	; 75
    1ace:	90 e2       	ldi	r25, 0x20	; 32
    1ad0:	9f 93       	push	r25
    1ad2:	8f 93       	push	r24
    1ad4:	0e 94 01 20 	call	0x4002	; 0x4002 <printf>
    1ad8:	8d b7       	in	r24, 0x3d	; 61
    1ada:	9e b7       	in	r25, 0x3e	; 62
    1adc:	48 96       	adiw	r24, 0x18	; 24
    1ade:	8d bf       	out	0x3d, r24	; 61
    1ae0:	9e bf       	out	0x3e, r25	; 62
    1ae2:	08 95       	ret

00001ae4 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
    1ae4:	8f ef       	ldi	r24, 0xFF	; 255
    1ae6:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
    1aea:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
    1aee:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
    1af2:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
    1af6:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x700074>
    1afa:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <__TEXT_REGION_LENGTH__+0x700075>
    1afe:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__TEXT_REGION_LENGTH__+0x700076>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1b02:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    1b04:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL |= id;
    1b06:	e0 e5       	ldi	r30, 0x50	; 80
    1b08:	f0 e0       	ldi	r31, 0x00	; 0
    1b0a:	80 81       	ld	r24, Z
    1b0c:	82 60       	ori	r24, 0x02	; 2
    1b0e:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1b10:	9f bf       	out	0x3f, r25	; 63

static inline bool osc_is_ready(uint8_t id)
{
	Assert(id != OSC_ID_USBSOF);

	return OSC.STATUS & id;
    1b12:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
    1b14:	81 ff       	sbrs	r24, 1
    1b16:	fd cf       	rjmp	.-6      	; 0x1b12 <sysclk_init+0x2e>
		default:
			//unhandled_case(CONFIG_SYSCLK_SOURCE);
			return;
		}

		ccp_write_io((uint8_t *)&CLK.CTRL, CONFIG_SYSCLK_SOURCE);
    1b18:	61 e0       	ldi	r22, 0x01	; 1
    1b1a:	80 e4       	ldi	r24, 0x40	; 64
    1b1c:	90 e0       	ldi	r25, 0x00	; 0
    1b1e:	2b d2       	rcall	.+1110   	; 0x1f76 <ccp_write_io>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1b20:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    1b22:	f8 94       	cli
	irqflags_t flags;

	Assert(id != OSC_ID_USBSOF);

	flags = cpu_irq_save();
	OSC.CTRL &= ~id;
    1b24:	e0 e5       	ldi	r30, 0x50	; 80
    1b26:	f0 e0       	ldi	r31, 0x00	; 0
    1b28:	80 81       	ld	r24, Z
    1b2a:	8e 7f       	andi	r24, 0xFE	; 254
    1b2c:	80 83       	st	Z, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1b2e:	9f bf       	out	0x3f, r25	; 63
		osc_enable(OSC_ID_XOSC);
		osc_wait_ready(OSC_ID_XOSC);
		break;
	}

	CLK.RTCCTRL = id | CLK_RTCEN_bm;
    1b30:	81 e0       	ldi	r24, 0x01	; 1
    1b32:	80 93 43 00 	sts	0x0043, r24	; 0x800043 <__TEXT_REGION_LENGTH__+0x700043>
    1b36:	08 95       	ret

00001b38 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1b38:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    1b3a:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    1b3c:	e8 2f       	mov	r30, r24
    1b3e:	f0 e0       	ldi	r31, 0x00	; 0
    1b40:	e0 59       	subi	r30, 0x90	; 144
    1b42:	ff 4f       	sbci	r31, 0xFF	; 255
    1b44:	60 95       	com	r22
    1b46:	80 81       	ld	r24, Z
    1b48:	68 23       	and	r22, r24
    1b4a:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1b4c:	9f bf       	out	0x3f, r25	; 63
    1b4e:	08 95       	ret

00001b50 <_read>:
#elif (defined(__GNUC__) && (XMEGA || MEGA) )

int _read (int *f); // Remove GCC compiler warning

int _read (int *f)
{
    1b50:	cf 93       	push	r28
    1b52:	df 93       	push	r29
    1b54:	1f 92       	push	r1
    1b56:	cd b7       	in	r28, 0x3d	; 61
    1b58:	de b7       	in	r29, 0x3e	; 62
	char c;
	ptr_get(stdio_base,&c);
    1b5a:	80 91 c9 20 	lds	r24, 0x20C9	; 0x8020c9 <stdio_base>
    1b5e:	90 91 ca 20 	lds	r25, 0x20CA	; 0x8020ca <stdio_base+0x1>
    1b62:	e0 91 c5 20 	lds	r30, 0x20C5	; 0x8020c5 <ptr_get>
    1b66:	f0 91 c6 20 	lds	r31, 0x20C6	; 0x8020c6 <ptr_get+0x1>
    1b6a:	be 01       	movw	r22, r28
    1b6c:	6f 5f       	subi	r22, 0xFF	; 255
    1b6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b70:	19 95       	eicall
	return c;
    1b72:	89 81       	ldd	r24, Y+1	; 0x01
}
    1b74:	08 2e       	mov	r0, r24
    1b76:	00 0c       	add	r0, r0
    1b78:	99 0b       	sbc	r25, r25
    1b7a:	0f 90       	pop	r0
    1b7c:	df 91       	pop	r29
    1b7e:	cf 91       	pop	r28
    1b80:	08 95       	ret

00001b82 <_write>:
#elif (defined(__GNUC__) && (XMEGA || MEGA))

int _write (char c, int *f);

int _write (char c, int *f)
{
    1b82:	68 2f       	mov	r22, r24
	if (ptr_put(stdio_base, c) < 0) {
    1b84:	80 91 c9 20 	lds	r24, 0x20C9	; 0x8020c9 <stdio_base>
    1b88:	90 91 ca 20 	lds	r25, 0x20CA	; 0x8020ca <stdio_base+0x1>
    1b8c:	e0 91 c7 20 	lds	r30, 0x20C7	; 0x8020c7 <ptr_put>
    1b90:	f0 91 c8 20 	lds	r31, 0x20C8	; 0x8020c8 <ptr_put+0x1>
    1b94:	19 95       	eicall
    1b96:	99 23       	and	r25, r25
    1b98:	1c f0       	brlt	.+6      	; 0x1ba0 <_write+0x1e>
		return -1;
	}
	return 1;
    1b9a:	81 e0       	ldi	r24, 0x01	; 1
    1b9c:	90 e0       	ldi	r25, 0x00	; 0
    1b9e:	08 95       	ret
int _write (char c, int *f);

int _write (char c, int *f)
{
	if (ptr_put(stdio_base, c) < 0) {
		return -1;
    1ba0:	8f ef       	ldi	r24, 0xFF	; 255
    1ba2:	9f ef       	ldi	r25, 0xFF	; 255
	}
	return 1;
}
    1ba4:	08 95       	ret

00001ba6 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
    1ba6:	1f 92       	push	r1
    1ba8:	0f 92       	push	r0
    1baa:	0f b6       	in	r0, 0x3f	; 63
    1bac:	0f 92       	push	r0
    1bae:	11 24       	eor	r1, r1
    1bb0:	08 b6       	in	r0, 0x38	; 56
    1bb2:	0f 92       	push	r0
    1bb4:	18 be       	out	0x38, r1	; 56
    1bb6:	09 b6       	in	r0, 0x39	; 57
    1bb8:	0f 92       	push	r0
    1bba:	19 be       	out	0x39, r1	; 57
    1bbc:	0b b6       	in	r0, 0x3b	; 59
    1bbe:	0f 92       	push	r0
    1bc0:	1b be       	out	0x3b, r1	; 59
    1bc2:	2f 93       	push	r18
    1bc4:	3f 93       	push	r19
    1bc6:	4f 93       	push	r20
    1bc8:	5f 93       	push	r21
    1bca:	6f 93       	push	r22
    1bcc:	7f 93       	push	r23
    1bce:	8f 93       	push	r24
    1bd0:	9f 93       	push	r25
    1bd2:	af 93       	push	r26
    1bd4:	bf 93       	push	r27
    1bd6:	ef 93       	push	r30
    1bd8:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
    1bda:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
    1bde:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
    1be2:	e0 91 cd 20 	lds	r30, 0x20CD	; 0x8020cd <adca_callback>
    1be6:	f0 91 ce 20 	lds	r31, 0x20CE	; 0x8020ce <adca_callback+0x1>
    1bea:	61 e0       	ldi	r22, 0x01	; 1
    1bec:	80 e0       	ldi	r24, 0x00	; 0
    1bee:	92 e0       	ldi	r25, 0x02	; 2
    1bf0:	19 95       	eicall
}
    1bf2:	ff 91       	pop	r31
    1bf4:	ef 91       	pop	r30
    1bf6:	bf 91       	pop	r27
    1bf8:	af 91       	pop	r26
    1bfa:	9f 91       	pop	r25
    1bfc:	8f 91       	pop	r24
    1bfe:	7f 91       	pop	r23
    1c00:	6f 91       	pop	r22
    1c02:	5f 91       	pop	r21
    1c04:	4f 91       	pop	r20
    1c06:	3f 91       	pop	r19
    1c08:	2f 91       	pop	r18
    1c0a:	0f 90       	pop	r0
    1c0c:	0b be       	out	0x3b, r0	; 59
    1c0e:	0f 90       	pop	r0
    1c10:	09 be       	out	0x39, r0	; 57
    1c12:	0f 90       	pop	r0
    1c14:	08 be       	out	0x38, r0	; 56
    1c16:	0f 90       	pop	r0
    1c18:	0f be       	out	0x3f, r0	; 63
    1c1a:	0f 90       	pop	r0
    1c1c:	1f 90       	pop	r1
    1c1e:	18 95       	reti

00001c20 <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
    1c20:	1f 92       	push	r1
    1c22:	0f 92       	push	r0
    1c24:	0f b6       	in	r0, 0x3f	; 63
    1c26:	0f 92       	push	r0
    1c28:	11 24       	eor	r1, r1
    1c2a:	08 b6       	in	r0, 0x38	; 56
    1c2c:	0f 92       	push	r0
    1c2e:	18 be       	out	0x38, r1	; 56
    1c30:	09 b6       	in	r0, 0x39	; 57
    1c32:	0f 92       	push	r0
    1c34:	19 be       	out	0x39, r1	; 57
    1c36:	0b b6       	in	r0, 0x3b	; 59
    1c38:	0f 92       	push	r0
    1c3a:	1b be       	out	0x3b, r1	; 59
    1c3c:	2f 93       	push	r18
    1c3e:	3f 93       	push	r19
    1c40:	4f 93       	push	r20
    1c42:	5f 93       	push	r21
    1c44:	6f 93       	push	r22
    1c46:	7f 93       	push	r23
    1c48:	8f 93       	push	r24
    1c4a:	9f 93       	push	r25
    1c4c:	af 93       	push	r26
    1c4e:	bf 93       	push	r27
    1c50:	ef 93       	push	r30
    1c52:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
    1c54:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
    1c58:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
    1c5c:	e0 91 cd 20 	lds	r30, 0x20CD	; 0x8020cd <adca_callback>
    1c60:	f0 91 ce 20 	lds	r31, 0x20CE	; 0x8020ce <adca_callback+0x1>
    1c64:	62 e0       	ldi	r22, 0x02	; 2
    1c66:	80 e0       	ldi	r24, 0x00	; 0
    1c68:	92 e0       	ldi	r25, 0x02	; 2
    1c6a:	19 95       	eicall
}
    1c6c:	ff 91       	pop	r31
    1c6e:	ef 91       	pop	r30
    1c70:	bf 91       	pop	r27
    1c72:	af 91       	pop	r26
    1c74:	9f 91       	pop	r25
    1c76:	8f 91       	pop	r24
    1c78:	7f 91       	pop	r23
    1c7a:	6f 91       	pop	r22
    1c7c:	5f 91       	pop	r21
    1c7e:	4f 91       	pop	r20
    1c80:	3f 91       	pop	r19
    1c82:	2f 91       	pop	r18
    1c84:	0f 90       	pop	r0
    1c86:	0b be       	out	0x3b, r0	; 59
    1c88:	0f 90       	pop	r0
    1c8a:	09 be       	out	0x39, r0	; 57
    1c8c:	0f 90       	pop	r0
    1c8e:	08 be       	out	0x38, r0	; 56
    1c90:	0f 90       	pop	r0
    1c92:	0f be       	out	0x3f, r0	; 63
    1c94:	0f 90       	pop	r0
    1c96:	1f 90       	pop	r1
    1c98:	18 95       	reti

00001c9a <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
    1c9a:	1f 92       	push	r1
    1c9c:	0f 92       	push	r0
    1c9e:	0f b6       	in	r0, 0x3f	; 63
    1ca0:	0f 92       	push	r0
    1ca2:	11 24       	eor	r1, r1
    1ca4:	08 b6       	in	r0, 0x38	; 56
    1ca6:	0f 92       	push	r0
    1ca8:	18 be       	out	0x38, r1	; 56
    1caa:	09 b6       	in	r0, 0x39	; 57
    1cac:	0f 92       	push	r0
    1cae:	19 be       	out	0x39, r1	; 57
    1cb0:	0b b6       	in	r0, 0x3b	; 59
    1cb2:	0f 92       	push	r0
    1cb4:	1b be       	out	0x3b, r1	; 59
    1cb6:	2f 93       	push	r18
    1cb8:	3f 93       	push	r19
    1cba:	4f 93       	push	r20
    1cbc:	5f 93       	push	r21
    1cbe:	6f 93       	push	r22
    1cc0:	7f 93       	push	r23
    1cc2:	8f 93       	push	r24
    1cc4:	9f 93       	push	r25
    1cc6:	af 93       	push	r26
    1cc8:	bf 93       	push	r27
    1cca:	ef 93       	push	r30
    1ccc:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
    1cce:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
    1cd2:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
    1cd6:	e0 91 cd 20 	lds	r30, 0x20CD	; 0x8020cd <adca_callback>
    1cda:	f0 91 ce 20 	lds	r31, 0x20CE	; 0x8020ce <adca_callback+0x1>
    1cde:	64 e0       	ldi	r22, 0x04	; 4
    1ce0:	80 e0       	ldi	r24, 0x00	; 0
    1ce2:	92 e0       	ldi	r25, 0x02	; 2
    1ce4:	19 95       	eicall
}
    1ce6:	ff 91       	pop	r31
    1ce8:	ef 91       	pop	r30
    1cea:	bf 91       	pop	r27
    1cec:	af 91       	pop	r26
    1cee:	9f 91       	pop	r25
    1cf0:	8f 91       	pop	r24
    1cf2:	7f 91       	pop	r23
    1cf4:	6f 91       	pop	r22
    1cf6:	5f 91       	pop	r21
    1cf8:	4f 91       	pop	r20
    1cfa:	3f 91       	pop	r19
    1cfc:	2f 91       	pop	r18
    1cfe:	0f 90       	pop	r0
    1d00:	0b be       	out	0x3b, r0	; 59
    1d02:	0f 90       	pop	r0
    1d04:	09 be       	out	0x39, r0	; 57
    1d06:	0f 90       	pop	r0
    1d08:	08 be       	out	0x38, r0	; 56
    1d0a:	0f 90       	pop	r0
    1d0c:	0f be       	out	0x3f, r0	; 63
    1d0e:	0f 90       	pop	r0
    1d10:	1f 90       	pop	r1
    1d12:	18 95       	reti

00001d14 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    1d14:	1f 92       	push	r1
    1d16:	0f 92       	push	r0
    1d18:	0f b6       	in	r0, 0x3f	; 63
    1d1a:	0f 92       	push	r0
    1d1c:	11 24       	eor	r1, r1
    1d1e:	08 b6       	in	r0, 0x38	; 56
    1d20:	0f 92       	push	r0
    1d22:	18 be       	out	0x38, r1	; 56
    1d24:	09 b6       	in	r0, 0x39	; 57
    1d26:	0f 92       	push	r0
    1d28:	19 be       	out	0x39, r1	; 57
    1d2a:	0b b6       	in	r0, 0x3b	; 59
    1d2c:	0f 92       	push	r0
    1d2e:	1b be       	out	0x3b, r1	; 59
    1d30:	2f 93       	push	r18
    1d32:	3f 93       	push	r19
    1d34:	4f 93       	push	r20
    1d36:	5f 93       	push	r21
    1d38:	6f 93       	push	r22
    1d3a:	7f 93       	push	r23
    1d3c:	8f 93       	push	r24
    1d3e:	9f 93       	push	r25
    1d40:	af 93       	push	r26
    1d42:	bf 93       	push	r27
    1d44:	ef 93       	push	r30
    1d46:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    1d48:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
    1d4c:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
    1d50:	e0 91 cd 20 	lds	r30, 0x20CD	; 0x8020cd <adca_callback>
    1d54:	f0 91 ce 20 	lds	r31, 0x20CE	; 0x8020ce <adca_callback+0x1>
    1d58:	68 e0       	ldi	r22, 0x08	; 8
    1d5a:	80 e0       	ldi	r24, 0x00	; 0
    1d5c:	92 e0       	ldi	r25, 0x02	; 2
    1d5e:	19 95       	eicall
}
    1d60:	ff 91       	pop	r31
    1d62:	ef 91       	pop	r30
    1d64:	bf 91       	pop	r27
    1d66:	af 91       	pop	r26
    1d68:	9f 91       	pop	r25
    1d6a:	8f 91       	pop	r24
    1d6c:	7f 91       	pop	r23
    1d6e:	6f 91       	pop	r22
    1d70:	5f 91       	pop	r21
    1d72:	4f 91       	pop	r20
    1d74:	3f 91       	pop	r19
    1d76:	2f 91       	pop	r18
    1d78:	0f 90       	pop	r0
    1d7a:	0b be       	out	0x3b, r0	; 59
    1d7c:	0f 90       	pop	r0
    1d7e:	09 be       	out	0x39, r0	; 57
    1d80:	0f 90       	pop	r0
    1d82:	08 be       	out	0x38, r0	; 56
    1d84:	0f 90       	pop	r0
    1d86:	0f be       	out	0x3f, r0	; 63
    1d88:	0f 90       	pop	r0
    1d8a:	1f 90       	pop	r1
    1d8c:	18 95       	reti

00001d8e <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    1d8e:	1f 92       	push	r1
    1d90:	0f 92       	push	r0
    1d92:	0f b6       	in	r0, 0x3f	; 63
    1d94:	0f 92       	push	r0
    1d96:	11 24       	eor	r1, r1
    1d98:	08 b6       	in	r0, 0x38	; 56
    1d9a:	0f 92       	push	r0
    1d9c:	18 be       	out	0x38, r1	; 56
    1d9e:	09 b6       	in	r0, 0x39	; 57
    1da0:	0f 92       	push	r0
    1da2:	19 be       	out	0x39, r1	; 57
    1da4:	0b b6       	in	r0, 0x3b	; 59
    1da6:	0f 92       	push	r0
    1da8:	1b be       	out	0x3b, r1	; 59
    1daa:	2f 93       	push	r18
    1dac:	3f 93       	push	r19
    1dae:	4f 93       	push	r20
    1db0:	5f 93       	push	r21
    1db2:	6f 93       	push	r22
    1db4:	7f 93       	push	r23
    1db6:	8f 93       	push	r24
    1db8:	9f 93       	push	r25
    1dba:	af 93       	push	r26
    1dbc:	bf 93       	push	r27
    1dbe:	ef 93       	push	r30
    1dc0:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1dc2:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
    1dc6:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
    1dca:	e0 91 cb 20 	lds	r30, 0x20CB	; 0x8020cb <adcb_callback>
    1dce:	f0 91 cc 20 	lds	r31, 0x20CC	; 0x8020cc <adcb_callback+0x1>
    1dd2:	61 e0       	ldi	r22, 0x01	; 1
    1dd4:	80 e4       	ldi	r24, 0x40	; 64
    1dd6:	92 e0       	ldi	r25, 0x02	; 2
    1dd8:	19 95       	eicall
}
    1dda:	ff 91       	pop	r31
    1ddc:	ef 91       	pop	r30
    1dde:	bf 91       	pop	r27
    1de0:	af 91       	pop	r26
    1de2:	9f 91       	pop	r25
    1de4:	8f 91       	pop	r24
    1de6:	7f 91       	pop	r23
    1de8:	6f 91       	pop	r22
    1dea:	5f 91       	pop	r21
    1dec:	4f 91       	pop	r20
    1dee:	3f 91       	pop	r19
    1df0:	2f 91       	pop	r18
    1df2:	0f 90       	pop	r0
    1df4:	0b be       	out	0x3b, r0	; 59
    1df6:	0f 90       	pop	r0
    1df8:	09 be       	out	0x39, r0	; 57
    1dfa:	0f 90       	pop	r0
    1dfc:	08 be       	out	0x38, r0	; 56
    1dfe:	0f 90       	pop	r0
    1e00:	0f be       	out	0x3f, r0	; 63
    1e02:	0f 90       	pop	r0
    1e04:	1f 90       	pop	r1
    1e06:	18 95       	reti

00001e08 <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    1e08:	1f 92       	push	r1
    1e0a:	0f 92       	push	r0
    1e0c:	0f b6       	in	r0, 0x3f	; 63
    1e0e:	0f 92       	push	r0
    1e10:	11 24       	eor	r1, r1
    1e12:	08 b6       	in	r0, 0x38	; 56
    1e14:	0f 92       	push	r0
    1e16:	18 be       	out	0x38, r1	; 56
    1e18:	09 b6       	in	r0, 0x39	; 57
    1e1a:	0f 92       	push	r0
    1e1c:	19 be       	out	0x39, r1	; 57
    1e1e:	0b b6       	in	r0, 0x3b	; 59
    1e20:	0f 92       	push	r0
    1e22:	1b be       	out	0x3b, r1	; 59
    1e24:	2f 93       	push	r18
    1e26:	3f 93       	push	r19
    1e28:	4f 93       	push	r20
    1e2a:	5f 93       	push	r21
    1e2c:	6f 93       	push	r22
    1e2e:	7f 93       	push	r23
    1e30:	8f 93       	push	r24
    1e32:	9f 93       	push	r25
    1e34:	af 93       	push	r26
    1e36:	bf 93       	push	r27
    1e38:	ef 93       	push	r30
    1e3a:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    1e3c:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
    1e40:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
    1e44:	e0 91 cb 20 	lds	r30, 0x20CB	; 0x8020cb <adcb_callback>
    1e48:	f0 91 cc 20 	lds	r31, 0x20CC	; 0x8020cc <adcb_callback+0x1>
    1e4c:	62 e0       	ldi	r22, 0x02	; 2
    1e4e:	80 e4       	ldi	r24, 0x40	; 64
    1e50:	92 e0       	ldi	r25, 0x02	; 2
    1e52:	19 95       	eicall
}
    1e54:	ff 91       	pop	r31
    1e56:	ef 91       	pop	r30
    1e58:	bf 91       	pop	r27
    1e5a:	af 91       	pop	r26
    1e5c:	9f 91       	pop	r25
    1e5e:	8f 91       	pop	r24
    1e60:	7f 91       	pop	r23
    1e62:	6f 91       	pop	r22
    1e64:	5f 91       	pop	r21
    1e66:	4f 91       	pop	r20
    1e68:	3f 91       	pop	r19
    1e6a:	2f 91       	pop	r18
    1e6c:	0f 90       	pop	r0
    1e6e:	0b be       	out	0x3b, r0	; 59
    1e70:	0f 90       	pop	r0
    1e72:	09 be       	out	0x39, r0	; 57
    1e74:	0f 90       	pop	r0
    1e76:	08 be       	out	0x38, r0	; 56
    1e78:	0f 90       	pop	r0
    1e7a:	0f be       	out	0x3f, r0	; 63
    1e7c:	0f 90       	pop	r0
    1e7e:	1f 90       	pop	r1
    1e80:	18 95       	reti

00001e82 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1e82:	1f 92       	push	r1
    1e84:	0f 92       	push	r0
    1e86:	0f b6       	in	r0, 0x3f	; 63
    1e88:	0f 92       	push	r0
    1e8a:	11 24       	eor	r1, r1
    1e8c:	08 b6       	in	r0, 0x38	; 56
    1e8e:	0f 92       	push	r0
    1e90:	18 be       	out	0x38, r1	; 56
    1e92:	09 b6       	in	r0, 0x39	; 57
    1e94:	0f 92       	push	r0
    1e96:	19 be       	out	0x39, r1	; 57
    1e98:	0b b6       	in	r0, 0x3b	; 59
    1e9a:	0f 92       	push	r0
    1e9c:	1b be       	out	0x3b, r1	; 59
    1e9e:	2f 93       	push	r18
    1ea0:	3f 93       	push	r19
    1ea2:	4f 93       	push	r20
    1ea4:	5f 93       	push	r21
    1ea6:	6f 93       	push	r22
    1ea8:	7f 93       	push	r23
    1eaa:	8f 93       	push	r24
    1eac:	9f 93       	push	r25
    1eae:	af 93       	push	r26
    1eb0:	bf 93       	push	r27
    1eb2:	ef 93       	push	r30
    1eb4:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1eb6:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
    1eba:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
    1ebe:	e0 91 cb 20 	lds	r30, 0x20CB	; 0x8020cb <adcb_callback>
    1ec2:	f0 91 cc 20 	lds	r31, 0x20CC	; 0x8020cc <adcb_callback+0x1>
    1ec6:	64 e0       	ldi	r22, 0x04	; 4
    1ec8:	80 e4       	ldi	r24, 0x40	; 64
    1eca:	92 e0       	ldi	r25, 0x02	; 2
    1ecc:	19 95       	eicall
}
    1ece:	ff 91       	pop	r31
    1ed0:	ef 91       	pop	r30
    1ed2:	bf 91       	pop	r27
    1ed4:	af 91       	pop	r26
    1ed6:	9f 91       	pop	r25
    1ed8:	8f 91       	pop	r24
    1eda:	7f 91       	pop	r23
    1edc:	6f 91       	pop	r22
    1ede:	5f 91       	pop	r21
    1ee0:	4f 91       	pop	r20
    1ee2:	3f 91       	pop	r19
    1ee4:	2f 91       	pop	r18
    1ee6:	0f 90       	pop	r0
    1ee8:	0b be       	out	0x3b, r0	; 59
    1eea:	0f 90       	pop	r0
    1eec:	09 be       	out	0x39, r0	; 57
    1eee:	0f 90       	pop	r0
    1ef0:	08 be       	out	0x38, r0	; 56
    1ef2:	0f 90       	pop	r0
    1ef4:	0f be       	out	0x3f, r0	; 63
    1ef6:	0f 90       	pop	r0
    1ef8:	1f 90       	pop	r1
    1efa:	18 95       	reti

00001efc <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1efc:	1f 92       	push	r1
    1efe:	0f 92       	push	r0
    1f00:	0f b6       	in	r0, 0x3f	; 63
    1f02:	0f 92       	push	r0
    1f04:	11 24       	eor	r1, r1
    1f06:	08 b6       	in	r0, 0x38	; 56
    1f08:	0f 92       	push	r0
    1f0a:	18 be       	out	0x38, r1	; 56
    1f0c:	09 b6       	in	r0, 0x39	; 57
    1f0e:	0f 92       	push	r0
    1f10:	19 be       	out	0x39, r1	; 57
    1f12:	0b b6       	in	r0, 0x3b	; 59
    1f14:	0f 92       	push	r0
    1f16:	1b be       	out	0x3b, r1	; 59
    1f18:	2f 93       	push	r18
    1f1a:	3f 93       	push	r19
    1f1c:	4f 93       	push	r20
    1f1e:	5f 93       	push	r21
    1f20:	6f 93       	push	r22
    1f22:	7f 93       	push	r23
    1f24:	8f 93       	push	r24
    1f26:	9f 93       	push	r25
    1f28:	af 93       	push	r26
    1f2a:	bf 93       	push	r27
    1f2c:	ef 93       	push	r30
    1f2e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    1f30:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
    1f34:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
    1f38:	e0 91 cb 20 	lds	r30, 0x20CB	; 0x8020cb <adcb_callback>
    1f3c:	f0 91 cc 20 	lds	r31, 0x20CC	; 0x8020cc <adcb_callback+0x1>
    1f40:	68 e0       	ldi	r22, 0x08	; 8
    1f42:	80 e4       	ldi	r24, 0x40	; 64
    1f44:	92 e0       	ldi	r25, 0x02	; 2
    1f46:	19 95       	eicall
}
    1f48:	ff 91       	pop	r31
    1f4a:	ef 91       	pop	r30
    1f4c:	bf 91       	pop	r27
    1f4e:	af 91       	pop	r26
    1f50:	9f 91       	pop	r25
    1f52:	8f 91       	pop	r24
    1f54:	7f 91       	pop	r23
    1f56:	6f 91       	pop	r22
    1f58:	5f 91       	pop	r21
    1f5a:	4f 91       	pop	r20
    1f5c:	3f 91       	pop	r19
    1f5e:	2f 91       	pop	r18
    1f60:	0f 90       	pop	r0
    1f62:	0b be       	out	0x3b, r0	; 59
    1f64:	0f 90       	pop	r0
    1f66:	09 be       	out	0x39, r0	; 57
    1f68:	0f 90       	pop	r0
    1f6a:	08 be       	out	0x38, r0	; 56
    1f6c:	0f 90       	pop	r0
    1f6e:	0f be       	out	0x3f, r0	; 63
    1f70:	0f 90       	pop	r0
    1f72:	1f 90       	pop	r1
    1f74:	18 95       	reti

00001f76 <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
    1f76:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
    1f78:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
    1f7a:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
    1f7c:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
    1f7e:	60 83       	st	Z, r22
	ret                             // Return to caller
    1f80:	08 95       	ret

00001f82 <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    1f82:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    1f86:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    1f88:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    1f8a:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    1f8e:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    1f90:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    1f94:	08 95       	ret

00001f96 <usart_putchar>:

	if (baud_offset != USART_BAUD_UNDEFINED) {
		(usart)->BAUDCTRLB = (uint8_t)((uint16_t)baudctrl);
		(usart)->BAUDCTRLA = (uint8_t)((uint16_t)baudctrl >> 8);
	}
}
    1f96:	fc 01       	movw	r30, r24
    1f98:	91 81       	ldd	r25, Z+1	; 0x01
    1f9a:	95 ff       	sbrs	r25, 5
    1f9c:	fd cf       	rjmp	.-6      	; 0x1f98 <usart_putchar+0x2>
    1f9e:	60 83       	st	Z, r22
    1fa0:	80 e0       	ldi	r24, 0x00	; 0
    1fa2:	90 e0       	ldi	r25, 0x00	; 0
    1fa4:	08 95       	ret

00001fa6 <usart_getchar>:
    1fa6:	fc 01       	movw	r30, r24
    1fa8:	91 81       	ldd	r25, Z+1	; 0x01
    1faa:	99 23       	and	r25, r25
    1fac:	ec f7       	brge	.-6      	; 0x1fa8 <usart_getchar+0x2>
    1fae:	80 81       	ld	r24, Z
    1fb0:	08 95       	ret

00001fb2 <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1fb2:	2f 92       	push	r2
    1fb4:	3f 92       	push	r3
    1fb6:	4f 92       	push	r4
    1fb8:	5f 92       	push	r5
    1fba:	6f 92       	push	r6
    1fbc:	7f 92       	push	r7
    1fbe:	8f 92       	push	r8
    1fc0:	9f 92       	push	r9
    1fc2:	af 92       	push	r10
    1fc4:	bf 92       	push	r11
    1fc6:	cf 92       	push	r12
    1fc8:	df 92       	push	r13
    1fca:	ef 92       	push	r14
    1fcc:	ff 92       	push	r15
    1fce:	0f 93       	push	r16
    1fd0:	1f 93       	push	r17
    1fd2:	cf 93       	push	r28
    1fd4:	1c 01       	movw	r2, r24
    1fd6:	2a 01       	movw	r4, r20
    1fd8:	3b 01       	movw	r6, r22
    1fda:	48 01       	movw	r8, r16
    1fdc:	59 01       	movw	r10, r18

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
    1fde:	d9 01       	movw	r26, r18
    1fe0:	c8 01       	movw	r24, r16
    1fe2:	68 94       	set
    1fe4:	12 f8       	bld	r1, 2
    1fe6:	b6 95       	lsr	r27
    1fe8:	a7 95       	ror	r26
    1fea:	97 95       	ror	r25
    1fec:	87 95       	ror	r24
    1fee:	16 94       	lsr	r1
    1ff0:	d1 f7       	brne	.-12     	; 0x1fe6 <usart_set_baudrate+0x34>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
    1ff2:	b9 01       	movw	r22, r18
    1ff4:	a8 01       	movw	r20, r16
    1ff6:	03 2e       	mov	r0, r19
    1ff8:	36 e1       	ldi	r19, 0x16	; 22
    1ffa:	76 95       	lsr	r23
    1ffc:	67 95       	ror	r22
    1ffe:	57 95       	ror	r21
    2000:	47 95       	ror	r20
    2002:	3a 95       	dec	r19
    2004:	d1 f7       	brne	.-12     	; 0x1ffa <usart_set_baudrate+0x48>
    2006:	30 2d       	mov	r19, r0

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    2008:	f1 01       	movw	r30, r2
    200a:	24 81       	ldd	r18, Z+4	; 0x04
    200c:	22 fd       	sbrc	r18, 2
    200e:	08 c0       	rjmp	.+16     	; 0x2020 <usart_set_baudrate+0x6e>
		max_rate /= 2;
    2010:	b6 95       	lsr	r27
    2012:	a7 95       	ror	r26
    2014:	97 95       	ror	r25
    2016:	87 95       	ror	r24
		min_rate /= 2;
    2018:	76 95       	lsr	r23
    201a:	67 95       	ror	r22
    201c:	57 95       	ror	r21
    201e:	47 95       	ror	r20
	}

	if ((baud > max_rate) || (baud < min_rate)) {
    2020:	84 15       	cp	r24, r4
    2022:	95 05       	cpc	r25, r5
    2024:	a6 05       	cpc	r26, r6
    2026:	b7 05       	cpc	r27, r7
    2028:	08 f4       	brcc	.+2      	; 0x202c <usart_set_baudrate+0x7a>
    202a:	ae c0       	rjmp	.+348    	; 0x2188 <usart_set_baudrate+0x1d6>
    202c:	44 16       	cp	r4, r20
    202e:	55 06       	cpc	r5, r21
    2030:	66 06       	cpc	r6, r22
    2032:	77 06       	cpc	r7, r23
    2034:	08 f4       	brcc	.+2      	; 0x2038 <usart_set_baudrate+0x86>
    2036:	aa c0       	rjmp	.+340    	; 0x218c <usart_set_baudrate+0x1da>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    2038:	f1 01       	movw	r30, r2
    203a:	84 81       	ldd	r24, Z+4	; 0x04
    203c:	82 fd       	sbrc	r24, 2
    203e:	04 c0       	rjmp	.+8      	; 0x2048 <usart_set_baudrate+0x96>
		baud *= 2;
    2040:	44 0c       	add	r4, r4
    2042:	55 1c       	adc	r5, r5
    2044:	66 1c       	adc	r6, r6
    2046:	77 1c       	adc	r7, r7
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
    2048:	c5 01       	movw	r24, r10
    204a:	b4 01       	movw	r22, r8
    204c:	a3 01       	movw	r20, r6
    204e:	92 01       	movw	r18, r4
    2050:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
    2054:	2f 3f       	cpi	r18, 0xFF	; 255
    2056:	31 05       	cpc	r19, r1
    2058:	41 05       	cpc	r20, r1
    205a:	51 05       	cpc	r21, r1
    205c:	08 f4       	brcc	.+2      	; 0x2060 <usart_set_baudrate+0xae>
    205e:	98 c0       	rjmp	.+304    	; 0x2190 <usart_set_baudrate+0x1de>
    2060:	c1 2c       	mov	r12, r1
    2062:	d1 2c       	mov	r13, r1
    2064:	76 01       	movw	r14, r12
    2066:	ca 94       	dec	r12
    2068:	c9 ef       	ldi	r28, 0xF9	; 249
    206a:	05 c0       	rjmp	.+10     	; 0x2076 <usart_set_baudrate+0xc4>
    206c:	2c 15       	cp	r18, r12
    206e:	3d 05       	cpc	r19, r13
    2070:	4e 05       	cpc	r20, r14
    2072:	5f 05       	cpc	r21, r15
    2074:	68 f0       	brcs	.+26     	; 0x2090 <usart_set_baudrate+0xde>
			break;
		}

		limit <<= 1;
    2076:	cc 0c       	add	r12, r12
    2078:	dd 1c       	adc	r13, r13
    207a:	ee 1c       	adc	r14, r14
    207c:	ff 1c       	adc	r15, r15

		if (exp < -3) {
    207e:	cd 3f       	cpi	r28, 0xFD	; 253
    2080:	14 f4       	brge	.+4      	; 0x2086 <usart_set_baudrate+0xd4>
			limit |= 1;
    2082:	68 94       	set
    2084:	c0 f8       	bld	r12, 0
    2086:	cf 5f       	subi	r28, 0xFF	; 255

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    2088:	c7 30       	cpi	r28, 0x07	; 7
    208a:	81 f7       	brne	.-32     	; 0x206c <usart_set_baudrate+0xba>
    208c:	8c 2f       	mov	r24, r28
    208e:	56 c0       	rjmp	.+172    	; 0x213c <usart_set_baudrate+0x18a>
    2090:	8c 2f       	mov	r24, r28
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
    2092:	cc 23       	and	r28, r28
    2094:	0c f0       	brlt	.+2      	; 0x2098 <usart_set_baudrate+0xe6>
    2096:	52 c0       	rjmp	.+164    	; 0x213c <usart_set_baudrate+0x18a>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    2098:	d3 01       	movw	r26, r6
    209a:	c2 01       	movw	r24, r4
    209c:	88 0f       	add	r24, r24
    209e:	99 1f       	adc	r25, r25
    20a0:	aa 1f       	adc	r26, r26
    20a2:	bb 1f       	adc	r27, r27
    20a4:	88 0f       	add	r24, r24
    20a6:	99 1f       	adc	r25, r25
    20a8:	aa 1f       	adc	r26, r26
    20aa:	bb 1f       	adc	r27, r27
    20ac:	88 0f       	add	r24, r24
    20ae:	99 1f       	adc	r25, r25
    20b0:	aa 1f       	adc	r26, r26
    20b2:	bb 1f       	adc	r27, r27
    20b4:	85 01       	movw	r16, r10
    20b6:	74 01       	movw	r14, r8
    20b8:	e8 1a       	sub	r14, r24
    20ba:	f9 0a       	sbc	r15, r25
    20bc:	0a 0b       	sbc	r16, r26
    20be:	1b 0b       	sbc	r17, r27
    20c0:	d8 01       	movw	r26, r16
    20c2:	c7 01       	movw	r24, r14
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
    20c4:	ce 3f       	cpi	r28, 0xFE	; 254
    20c6:	f4 f4       	brge	.+60     	; 0x2104 <usart_set_baudrate+0x152>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
    20c8:	2d ef       	ldi	r18, 0xFD	; 253
    20ca:	3f ef       	ldi	r19, 0xFF	; 255
    20cc:	2c 1b       	sub	r18, r28
    20ce:	31 09       	sbc	r19, r1
    20d0:	c7 fd       	sbrc	r28, 7
    20d2:	33 95       	inc	r19
    20d4:	04 c0       	rjmp	.+8      	; 0x20de <usart_set_baudrate+0x12c>
    20d6:	88 0f       	add	r24, r24
    20d8:	99 1f       	adc	r25, r25
    20da:	aa 1f       	adc	r26, r26
    20dc:	bb 1f       	adc	r27, r27
    20de:	2a 95       	dec	r18
    20e0:	d2 f7       	brpl	.-12     	; 0x20d6 <usart_set_baudrate+0x124>
    20e2:	73 01       	movw	r14, r6
    20e4:	62 01       	movw	r12, r4
    20e6:	f6 94       	lsr	r15
    20e8:	e7 94       	ror	r14
    20ea:	d7 94       	ror	r13
    20ec:	c7 94       	ror	r12
    20ee:	bc 01       	movw	r22, r24
    20f0:	cd 01       	movw	r24, r26
    20f2:	6c 0d       	add	r22, r12
    20f4:	7d 1d       	adc	r23, r13
    20f6:	8e 1d       	adc	r24, r14
    20f8:	9f 1d       	adc	r25, r15
    20fa:	a3 01       	movw	r20, r6
    20fc:	92 01       	movw	r18, r4
    20fe:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <__udivmodsi4>
    2102:	38 c0       	rjmp	.+112    	; 0x2174 <usart_set_baudrate+0x1c2>
		} else {
			baud <<= exp + 3;
    2104:	23 e0       	ldi	r18, 0x03	; 3
    2106:	2c 0f       	add	r18, r28
    2108:	83 01       	movw	r16, r6
    210a:	72 01       	movw	r14, r4
    210c:	04 c0       	rjmp	.+8      	; 0x2116 <usart_set_baudrate+0x164>
    210e:	ee 0c       	add	r14, r14
    2110:	ff 1c       	adc	r15, r15
    2112:	00 1f       	adc	r16, r16
    2114:	11 1f       	adc	r17, r17
    2116:	2a 95       	dec	r18
    2118:	d2 f7       	brpl	.-12     	; 0x210e <usart_set_baudrate+0x15c>
    211a:	a8 01       	movw	r20, r16
    211c:	97 01       	movw	r18, r14
			div = (cpu_hz + baud / 2) / baud;
    211e:	67 01       	movw	r12, r14
    2120:	78 01       	movw	r14, r16
    2122:	f6 94       	lsr	r15
    2124:	e7 94       	ror	r14
    2126:	d7 94       	ror	r13
    2128:	c7 94       	ror	r12
    212a:	bc 01       	movw	r22, r24
    212c:	cd 01       	movw	r24, r26
    212e:	6c 0d       	add	r22, r12
    2130:	7d 1d       	adc	r23, r13
    2132:	8e 1d       	adc	r24, r14
    2134:	9f 1d       	adc	r25, r15
    2136:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <__udivmodsi4>
    213a:	1c c0       	rjmp	.+56     	; 0x2174 <usart_set_baudrate+0x1c2>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
    213c:	8d 5f       	subi	r24, 0xFD	; 253
    213e:	a3 01       	movw	r20, r6
    2140:	92 01       	movw	r18, r4
    2142:	04 c0       	rjmp	.+8      	; 0x214c <usart_set_baudrate+0x19a>
    2144:	22 0f       	add	r18, r18
    2146:	33 1f       	adc	r19, r19
    2148:	44 1f       	adc	r20, r20
    214a:	55 1f       	adc	r21, r21
    214c:	8a 95       	dec	r24
    214e:	d2 f7       	brpl	.-12     	; 0x2144 <usart_set_baudrate+0x192>
		div = (cpu_hz + baud / 2) / baud - 1;
    2150:	da 01       	movw	r26, r20
    2152:	c9 01       	movw	r24, r18
    2154:	b6 95       	lsr	r27
    2156:	a7 95       	ror	r26
    2158:	97 95       	ror	r25
    215a:	87 95       	ror	r24
    215c:	bc 01       	movw	r22, r24
    215e:	cd 01       	movw	r24, r26
    2160:	68 0d       	add	r22, r8
    2162:	79 1d       	adc	r23, r9
    2164:	8a 1d       	adc	r24, r10
    2166:	9b 1d       	adc	r25, r11
    2168:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <__udivmodsi4>
    216c:	21 50       	subi	r18, 0x01	; 1
    216e:	31 09       	sbc	r19, r1
    2170:	41 09       	sbc	r20, r1
    2172:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
    2174:	83 2f       	mov	r24, r19
    2176:	8f 70       	andi	r24, 0x0F	; 15
    2178:	c2 95       	swap	r28
    217a:	c0 7f       	andi	r28, 0xF0	; 240
    217c:	c8 2b       	or	r28, r24
    217e:	f1 01       	movw	r30, r2
    2180:	c7 83       	std	Z+7, r28	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
    2182:	26 83       	std	Z+6, r18	; 0x06

	return true;
    2184:	81 e0       	ldi	r24, 0x01	; 1
    2186:	1c c0       	rjmp	.+56     	; 0x21c0 <usart_set_baudrate+0x20e>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
    2188:	80 e0       	ldi	r24, 0x00	; 0
    218a:	1a c0       	rjmp	.+52     	; 0x21c0 <usart_set_baudrate+0x20e>
    218c:	80 e0       	ldi	r24, 0x00	; 0
    218e:	18 c0       	rjmp	.+48     	; 0x21c0 <usart_set_baudrate+0x20e>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    2190:	d3 01       	movw	r26, r6
    2192:	c2 01       	movw	r24, r4
    2194:	88 0f       	add	r24, r24
    2196:	99 1f       	adc	r25, r25
    2198:	aa 1f       	adc	r26, r26
    219a:	bb 1f       	adc	r27, r27
    219c:	88 0f       	add	r24, r24
    219e:	99 1f       	adc	r25, r25
    21a0:	aa 1f       	adc	r26, r26
    21a2:	bb 1f       	adc	r27, r27
    21a4:	88 0f       	add	r24, r24
    21a6:	99 1f       	adc	r25, r25
    21a8:	aa 1f       	adc	r26, r26
    21aa:	bb 1f       	adc	r27, r27
    21ac:	85 01       	movw	r16, r10
    21ae:	74 01       	movw	r14, r8
    21b0:	e8 1a       	sub	r14, r24
    21b2:	f9 0a       	sbc	r15, r25
    21b4:	0a 0b       	sbc	r16, r26
    21b6:	1b 0b       	sbc	r17, r27
    21b8:	d8 01       	movw	r26, r16
    21ba:	c7 01       	movw	r24, r14

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    21bc:	c9 ef       	ldi	r28, 0xF9	; 249
    21be:	84 cf       	rjmp	.-248    	; 0x20c8 <usart_set_baudrate+0x116>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
    21c0:	cf 91       	pop	r28
    21c2:	1f 91       	pop	r17
    21c4:	0f 91       	pop	r16
    21c6:	ff 90       	pop	r15
    21c8:	ef 90       	pop	r14
    21ca:	df 90       	pop	r13
    21cc:	cf 90       	pop	r12
    21ce:	bf 90       	pop	r11
    21d0:	af 90       	pop	r10
    21d2:	9f 90       	pop	r9
    21d4:	8f 90       	pop	r8
    21d6:	7f 90       	pop	r7
    21d8:	6f 90       	pop	r6
    21da:	5f 90       	pop	r5
    21dc:	4f 90       	pop	r4
    21de:	3f 90       	pop	r3
    21e0:	2f 90       	pop	r2
    21e2:	08 95       	ret

000021e4 <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
    21e4:	0f 93       	push	r16
    21e6:	1f 93       	push	r17
    21e8:	cf 93       	push	r28
    21ea:	df 93       	push	r29
    21ec:	ec 01       	movw	r28, r24
    21ee:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    21f0:	00 97       	sbiw	r24, 0x00	; 0
    21f2:	09 f4       	brne	.+2      	; 0x21f6 <usart_init_rs232+0x12>
    21f4:	36 c1       	rjmp	.+620    	; 0x2462 <usart_init_rs232+0x27e>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    21f6:	80 3c       	cpi	r24, 0xC0	; 192
    21f8:	91 05       	cpc	r25, r1
    21fa:	21 f4       	brne	.+8      	; 0x2204 <usart_init_rs232+0x20>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    21fc:	60 e1       	ldi	r22, 0x10	; 16
    21fe:	80 e0       	ldi	r24, 0x00	; 0
    2200:	9b dc       	rcall	.-1738   	; 0x1b38 <sysclk_enable_module>
    2202:	2f c1       	rjmp	.+606    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef EBI
	else if (module == &EBI) {
    2204:	c0 34       	cpi	r28, 0x40	; 64
    2206:	84 e0       	ldi	r24, 0x04	; 4
    2208:	d8 07       	cpc	r29, r24
    220a:	21 f4       	brne	.+8      	; 0x2214 <usart_init_rs232+0x30>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EBI);
    220c:	68 e0       	ldi	r22, 0x08	; 8
    220e:	80 e0       	ldi	r24, 0x00	; 0
    2210:	93 dc       	rcall	.-1754   	; 0x1b38 <sysclk_enable_module>
    2212:	27 c1       	rjmp	.+590    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef RTC
	else if (module == &RTC) {
    2214:	c1 15       	cp	r28, r1
    2216:	e4 e0       	ldi	r30, 0x04	; 4
    2218:	de 07       	cpc	r29, r30
    221a:	21 f4       	brne	.+8      	; 0x2224 <usart_init_rs232+0x40>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
    221c:	64 e0       	ldi	r22, 0x04	; 4
    221e:	80 e0       	ldi	r24, 0x00	; 0
    2220:	8b dc       	rcall	.-1770   	; 0x1b38 <sysclk_enable_module>
    2222:	1f c1       	rjmp	.+574    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    2224:	c0 38       	cpi	r28, 0x80	; 128
    2226:	f1 e0       	ldi	r31, 0x01	; 1
    2228:	df 07       	cpc	r29, r31
    222a:	21 f4       	brne	.+8      	; 0x2234 <usart_init_rs232+0x50>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    222c:	62 e0       	ldi	r22, 0x02	; 2
    222e:	80 e0       	ldi	r24, 0x00	; 0
    2230:	83 dc       	rcall	.-1786   	; 0x1b38 <sysclk_enable_module>
    2232:	17 c1       	rjmp	.+558    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    2234:	c1 15       	cp	r28, r1
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	d8 07       	cpc	r29, r24
    223a:	21 f4       	brne	.+8      	; 0x2244 <usart_init_rs232+0x60>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    223c:	61 e0       	ldi	r22, 0x01	; 1
    223e:	80 e0       	ldi	r24, 0x00	; 0
    2240:	7b dc       	rcall	.-1802   	; 0x1b38 <sysclk_enable_module>
    2242:	0f c1       	rjmp	.+542    	; 0x2462 <usart_init_rs232+0x27e>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    2244:	c0 38       	cpi	r28, 0x80	; 128
    2246:	e3 e0       	ldi	r30, 0x03	; 3
    2248:	de 07       	cpc	r29, r30
    224a:	21 f4       	brne	.+8      	; 0x2254 <usart_init_rs232+0x70>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    224c:	61 e0       	ldi	r22, 0x01	; 1
    224e:	81 e0       	ldi	r24, 0x01	; 1
    2250:	73 dc       	rcall	.-1818   	; 0x1b38 <sysclk_enable_module>
    2252:	07 c1       	rjmp	.+526    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    2254:	c0 39       	cpi	r28, 0x90	; 144
    2256:	f3 e0       	ldi	r31, 0x03	; 3
    2258:	df 07       	cpc	r29, r31
    225a:	21 f4       	brne	.+8      	; 0x2264 <usart_init_rs232+0x80>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    225c:	61 e0       	ldi	r22, 0x01	; 1
    225e:	82 e0       	ldi	r24, 0x02	; 2
    2260:	6b dc       	rcall	.-1834   	; 0x1b38 <sysclk_enable_module>
    2262:	ff c0       	rjmp	.+510    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    2264:	c1 15       	cp	r28, r1
    2266:	82 e0       	ldi	r24, 0x02	; 2
    2268:	d8 07       	cpc	r29, r24
    226a:	21 f4       	brne	.+8      	; 0x2274 <usart_init_rs232+0x90>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    226c:	62 e0       	ldi	r22, 0x02	; 2
    226e:	81 e0       	ldi	r24, 0x01	; 1
    2270:	63 dc       	rcall	.-1850   	; 0x1b38 <sysclk_enable_module>
    2272:	f7 c0       	rjmp	.+494    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    2274:	c0 34       	cpi	r28, 0x40	; 64
    2276:	e2 e0       	ldi	r30, 0x02	; 2
    2278:	de 07       	cpc	r29, r30
    227a:	21 f4       	brne	.+8      	; 0x2284 <usart_init_rs232+0xa0>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    227c:	62 e0       	ldi	r22, 0x02	; 2
    227e:	82 e0       	ldi	r24, 0x02	; 2
    2280:	5b dc       	rcall	.-1866   	; 0x1b38 <sysclk_enable_module>
    2282:	ef c0       	rjmp	.+478    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef DACA
	else if (module == &DACA) {
    2284:	c1 15       	cp	r28, r1
    2286:	f3 e0       	ldi	r31, 0x03	; 3
    2288:	df 07       	cpc	r29, r31
    228a:	21 f4       	brne	.+8      	; 0x2294 <usart_init_rs232+0xb0>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_DAC);
    228c:	64 e0       	ldi	r22, 0x04	; 4
    228e:	81 e0       	ldi	r24, 0x01	; 1
    2290:	53 dc       	rcall	.-1882   	; 0x1b38 <sysclk_enable_module>
    2292:	e7 c0       	rjmp	.+462    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    2294:	c0 32       	cpi	r28, 0x20	; 32
    2296:	83 e0       	ldi	r24, 0x03	; 3
    2298:	d8 07       	cpc	r29, r24
    229a:	21 f4       	brne	.+8      	; 0x22a4 <usart_init_rs232+0xc0>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    229c:	64 e0       	ldi	r22, 0x04	; 4
    229e:	82 e0       	ldi	r24, 0x02	; 2
    22a0:	4b dc       	rcall	.-1898   	; 0x1b38 <sysclk_enable_module>
    22a2:	df c0       	rjmp	.+446    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    22a4:	c1 15       	cp	r28, r1
    22a6:	e8 e0       	ldi	r30, 0x08	; 8
    22a8:	de 07       	cpc	r29, r30
    22aa:	21 f4       	brne	.+8      	; 0x22b4 <usart_init_rs232+0xd0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    22ac:	61 e0       	ldi	r22, 0x01	; 1
    22ae:	83 e0       	ldi	r24, 0x03	; 3
    22b0:	43 dc       	rcall	.-1914   	; 0x1b38 <sysclk_enable_module>
    22b2:	d7 c0       	rjmp	.+430    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    22b4:	c1 15       	cp	r28, r1
    22b6:	f9 e0       	ldi	r31, 0x09	; 9
    22b8:	df 07       	cpc	r29, r31
    22ba:	21 f4       	brne	.+8      	; 0x22c4 <usart_init_rs232+0xe0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    22bc:	61 e0       	ldi	r22, 0x01	; 1
    22be:	84 e0       	ldi	r24, 0x04	; 4
    22c0:	3b dc       	rcall	.-1930   	; 0x1b38 <sysclk_enable_module>
    22c2:	cf c0       	rjmp	.+414    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    22c4:	c1 15       	cp	r28, r1
    22c6:	8a e0       	ldi	r24, 0x0A	; 10
    22c8:	d8 07       	cpc	r29, r24
    22ca:	21 f4       	brne	.+8      	; 0x22d4 <usart_init_rs232+0xf0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    22cc:	61 e0       	ldi	r22, 0x01	; 1
    22ce:	85 e0       	ldi	r24, 0x05	; 5
    22d0:	33 dc       	rcall	.-1946   	; 0x1b38 <sysclk_enable_module>
    22d2:	c7 c0       	rjmp	.+398    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    22d4:	c1 15       	cp	r28, r1
    22d6:	eb e0       	ldi	r30, 0x0B	; 11
    22d8:	de 07       	cpc	r29, r30
    22da:	21 f4       	brne	.+8      	; 0x22e4 <usart_init_rs232+0x100>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    22dc:	61 e0       	ldi	r22, 0x01	; 1
    22de:	86 e0       	ldi	r24, 0x06	; 6
    22e0:	2b dc       	rcall	.-1962   	; 0x1b38 <sysclk_enable_module>
    22e2:	bf c0       	rjmp	.+382    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    22e4:	c0 34       	cpi	r28, 0x40	; 64
    22e6:	f8 e0       	ldi	r31, 0x08	; 8
    22e8:	df 07       	cpc	r29, r31
    22ea:	21 f4       	brne	.+8      	; 0x22f4 <usart_init_rs232+0x110>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    22ec:	62 e0       	ldi	r22, 0x02	; 2
    22ee:	83 e0       	ldi	r24, 0x03	; 3
    22f0:	23 dc       	rcall	.-1978   	; 0x1b38 <sysclk_enable_module>
    22f2:	b7 c0       	rjmp	.+366    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    22f4:	c0 34       	cpi	r28, 0x40	; 64
    22f6:	89 e0       	ldi	r24, 0x09	; 9
    22f8:	d8 07       	cpc	r29, r24
    22fa:	21 f4       	brne	.+8      	; 0x2304 <usart_init_rs232+0x120>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    22fc:	62 e0       	ldi	r22, 0x02	; 2
    22fe:	84 e0       	ldi	r24, 0x04	; 4
    2300:	1b dc       	rcall	.-1994   	; 0x1b38 <sysclk_enable_module>
    2302:	af c0       	rjmp	.+350    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    2304:	c0 34       	cpi	r28, 0x40	; 64
    2306:	ea e0       	ldi	r30, 0x0A	; 10
    2308:	de 07       	cpc	r29, r30
    230a:	21 f4       	brne	.+8      	; 0x2314 <usart_init_rs232+0x130>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    230c:	62 e0       	ldi	r22, 0x02	; 2
    230e:	85 e0       	ldi	r24, 0x05	; 5
    2310:	13 dc       	rcall	.-2010   	; 0x1b38 <sysclk_enable_module>
    2312:	a7 c0       	rjmp	.+334    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TCF1
	else if (module == &TCF1) {
    2314:	c0 34       	cpi	r28, 0x40	; 64
    2316:	fb e0       	ldi	r31, 0x0B	; 11
    2318:	df 07       	cpc	r29, r31
    231a:	21 f4       	brne	.+8      	; 0x2324 <usart_init_rs232+0x140>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC1);
    231c:	62 e0       	ldi	r22, 0x02	; 2
    231e:	86 e0       	ldi	r24, 0x06	; 6
    2320:	0b dc       	rcall	.-2026   	; 0x1b38 <sysclk_enable_module>
    2322:	9f c0       	rjmp	.+318    	; 0x2462 <usart_init_rs232+0x27e>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    2324:	c0 39       	cpi	r28, 0x90	; 144
    2326:	88 e0       	ldi	r24, 0x08	; 8
    2328:	d8 07       	cpc	r29, r24
    232a:	21 f4       	brne	.+8      	; 0x2334 <usart_init_rs232+0x150>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    232c:	64 e0       	ldi	r22, 0x04	; 4
    232e:	83 e0       	ldi	r24, 0x03	; 3
    2330:	03 dc       	rcall	.-2042   	; 0x1b38 <sysclk_enable_module>
    2332:	97 c0       	rjmp	.+302    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    2334:	c0 39       	cpi	r28, 0x90	; 144
    2336:	e9 e0       	ldi	r30, 0x09	; 9
    2338:	de 07       	cpc	r29, r30
    233a:	21 f4       	brne	.+8      	; 0x2344 <usart_init_rs232+0x160>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    233c:	64 e0       	ldi	r22, 0x04	; 4
    233e:	84 e0       	ldi	r24, 0x04	; 4
    2340:	fb db       	rcall	.-2058   	; 0x1b38 <sysclk_enable_module>
    2342:	8f c0       	rjmp	.+286    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    2344:	c0 39       	cpi	r28, 0x90	; 144
    2346:	fa e0       	ldi	r31, 0x0A	; 10
    2348:	df 07       	cpc	r29, r31
    234a:	21 f4       	brne	.+8      	; 0x2354 <usart_init_rs232+0x170>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    234c:	64 e0       	ldi	r22, 0x04	; 4
    234e:	85 e0       	ldi	r24, 0x05	; 5
    2350:	f3 db       	rcall	.-2074   	; 0x1b38 <sysclk_enable_module>
    2352:	87 c0       	rjmp	.+270    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    2354:	c0 39       	cpi	r28, 0x90	; 144
    2356:	8b e0       	ldi	r24, 0x0B	; 11
    2358:	d8 07       	cpc	r29, r24
    235a:	21 f4       	brne	.+8      	; 0x2364 <usart_init_rs232+0x180>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    235c:	64 e0       	ldi	r22, 0x04	; 4
    235e:	86 e0       	ldi	r24, 0x06	; 6
    2360:	eb db       	rcall	.-2090   	; 0x1b38 <sysclk_enable_module>
    2362:	7f c0       	rjmp	.+254    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    2364:	c0 3c       	cpi	r28, 0xC0	; 192
    2366:	e8 e0       	ldi	r30, 0x08	; 8
    2368:	de 07       	cpc	r29, r30
    236a:	21 f4       	brne	.+8      	; 0x2374 <usart_init_rs232+0x190>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    236c:	68 e0       	ldi	r22, 0x08	; 8
    236e:	83 e0       	ldi	r24, 0x03	; 3
    2370:	e3 db       	rcall	.-2106   	; 0x1b38 <sysclk_enable_module>
    2372:	77 c0       	rjmp	.+238    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    2374:	c0 3c       	cpi	r28, 0xC0	; 192
    2376:	f9 e0       	ldi	r31, 0x09	; 9
    2378:	df 07       	cpc	r29, r31
    237a:	21 f4       	brne	.+8      	; 0x2384 <usart_init_rs232+0x1a0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    237c:	68 e0       	ldi	r22, 0x08	; 8
    237e:	84 e0       	ldi	r24, 0x04	; 4
    2380:	db db       	rcall	.-2122   	; 0x1b38 <sysclk_enable_module>
    2382:	6f c0       	rjmp	.+222    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef SPIE
	else if (module == &SPIE) {
    2384:	c0 3c       	cpi	r28, 0xC0	; 192
    2386:	8a e0       	ldi	r24, 0x0A	; 10
    2388:	d8 07       	cpc	r29, r24
    238a:	21 f4       	brne	.+8      	; 0x2394 <usart_init_rs232+0x1b0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_SPI);
    238c:	68 e0       	ldi	r22, 0x08	; 8
    238e:	85 e0       	ldi	r24, 0x05	; 5
    2390:	d3 db       	rcall	.-2138   	; 0x1b38 <sysclk_enable_module>
    2392:	67 c0       	rjmp	.+206    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef SPIF
	else if (module == &SPIF) {
    2394:	c0 3c       	cpi	r28, 0xC0	; 192
    2396:	eb e0       	ldi	r30, 0x0B	; 11
    2398:	de 07       	cpc	r29, r30
    239a:	21 f4       	brne	.+8      	; 0x23a4 <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
    239c:	68 e0       	ldi	r22, 0x08	; 8
    239e:	86 e0       	ldi	r24, 0x06	; 6
    23a0:	cb db       	rcall	.-2154   	; 0x1b38 <sysclk_enable_module>
    23a2:	5f c0       	rjmp	.+190    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    23a4:	c0 3a       	cpi	r28, 0xA0	; 160
    23a6:	f8 e0       	ldi	r31, 0x08	; 8
    23a8:	df 07       	cpc	r29, r31
    23aa:	21 f4       	brne	.+8      	; 0x23b4 <usart_init_rs232+0x1d0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    23ac:	60 e1       	ldi	r22, 0x10	; 16
    23ae:	83 e0       	ldi	r24, 0x03	; 3
    23b0:	c3 db       	rcall	.-2170   	; 0x1b38 <sysclk_enable_module>
    23b2:	57 c0       	rjmp	.+174    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    23b4:	c0 3a       	cpi	r28, 0xA0	; 160
    23b6:	89 e0       	ldi	r24, 0x09	; 9
    23b8:	d8 07       	cpc	r29, r24
    23ba:	21 f4       	brne	.+8      	; 0x23c4 <usart_init_rs232+0x1e0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    23bc:	60 e1       	ldi	r22, 0x10	; 16
    23be:	84 e0       	ldi	r24, 0x04	; 4
    23c0:	bb db       	rcall	.-2186   	; 0x1b38 <sysclk_enable_module>
    23c2:	4f c0       	rjmp	.+158    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    23c4:	c0 3a       	cpi	r28, 0xA0	; 160
    23c6:	ea e0       	ldi	r30, 0x0A	; 10
    23c8:	de 07       	cpc	r29, r30
    23ca:	21 f4       	brne	.+8      	; 0x23d4 <usart_init_rs232+0x1f0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    23cc:	60 e1       	ldi	r22, 0x10	; 16
    23ce:	85 e0       	ldi	r24, 0x05	; 5
    23d0:	b3 db       	rcall	.-2202   	; 0x1b38 <sysclk_enable_module>
    23d2:	47 c0       	rjmp	.+142    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    23d4:	c0 3a       	cpi	r28, 0xA0	; 160
    23d6:	fb e0       	ldi	r31, 0x0B	; 11
    23d8:	df 07       	cpc	r29, r31
    23da:	21 f4       	brne	.+8      	; 0x23e4 <usart_init_rs232+0x200>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    23dc:	60 e1       	ldi	r22, 0x10	; 16
    23de:	86 e0       	ldi	r24, 0x06	; 6
    23e0:	ab db       	rcall	.-2218   	; 0x1b38 <sysclk_enable_module>
    23e2:	3f c0       	rjmp	.+126    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    23e4:	c0 3b       	cpi	r28, 0xB0	; 176
    23e6:	88 e0       	ldi	r24, 0x08	; 8
    23e8:	d8 07       	cpc	r29, r24
    23ea:	21 f4       	brne	.+8      	; 0x23f4 <usart_init_rs232+0x210>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    23ec:	60 e2       	ldi	r22, 0x20	; 32
    23ee:	83 e0       	ldi	r24, 0x03	; 3
    23f0:	a3 db       	rcall	.-2234   	; 0x1b38 <sysclk_enable_module>
    23f2:	37 c0       	rjmp	.+110    	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    23f4:	c0 3b       	cpi	r28, 0xB0	; 176
    23f6:	e9 e0       	ldi	r30, 0x09	; 9
    23f8:	de 07       	cpc	r29, r30
    23fa:	21 f4       	brne	.+8      	; 0x2404 <usart_init_rs232+0x220>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    23fc:	60 e2       	ldi	r22, 0x20	; 32
    23fe:	84 e0       	ldi	r24, 0x04	; 4
    2400:	9b db       	rcall	.-2250   	; 0x1b38 <sysclk_enable_module>
    2402:	2f c0       	rjmp	.+94     	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef USARTE1
	else if (module == &USARTE1) {
    2404:	c0 3b       	cpi	r28, 0xB0	; 176
    2406:	fa e0       	ldi	r31, 0x0A	; 10
    2408:	df 07       	cpc	r29, r31
    240a:	21 f4       	brne	.+8      	; 0x2414 <usart_init_rs232+0x230>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART1);
    240c:	60 e2       	ldi	r22, 0x20	; 32
    240e:	85 e0       	ldi	r24, 0x05	; 5
    2410:	93 db       	rcall	.-2266   	; 0x1b38 <sysclk_enable_module>
    2412:	27 c0       	rjmp	.+78     	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef USARTF1
	else if (module == &USARTF1) {
    2414:	c0 3b       	cpi	r28, 0xB0	; 176
    2416:	8b e0       	ldi	r24, 0x0B	; 11
    2418:	d8 07       	cpc	r29, r24
    241a:	21 f4       	brne	.+8      	; 0x2424 <usart_init_rs232+0x240>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
    241c:	60 e2       	ldi	r22, 0x20	; 32
    241e:	86 e0       	ldi	r24, 0x06	; 6
    2420:	8b db       	rcall	.-2282   	; 0x1b38 <sysclk_enable_module>
    2422:	1f c0       	rjmp	.+62     	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    2424:	c0 38       	cpi	r28, 0x80	; 128
    2426:	e4 e0       	ldi	r30, 0x04	; 4
    2428:	de 07       	cpc	r29, r30
    242a:	21 f4       	brne	.+8      	; 0x2434 <usart_init_rs232+0x250>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    242c:	60 e4       	ldi	r22, 0x40	; 64
    242e:	83 e0       	ldi	r24, 0x03	; 3
    2430:	83 db       	rcall	.-2298   	; 0x1b38 <sysclk_enable_module>
    2432:	17 c0       	rjmp	.+46     	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TWID
	else if (module == &TWID) {
    2434:	c0 39       	cpi	r28, 0x90	; 144
    2436:	f4 e0       	ldi	r31, 0x04	; 4
    2438:	df 07       	cpc	r29, r31
    243a:	21 f4       	brne	.+8      	; 0x2444 <usart_init_rs232+0x260>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
    243c:	60 e4       	ldi	r22, 0x40	; 64
    243e:	84 e0       	ldi	r24, 0x04	; 4
    2440:	7b db       	rcall	.-2314   	; 0x1b38 <sysclk_enable_module>
    2442:	0f c0       	rjmp	.+30     	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    2444:	c0 3a       	cpi	r28, 0xA0	; 160
    2446:	84 e0       	ldi	r24, 0x04	; 4
    2448:	d8 07       	cpc	r29, r24
    244a:	21 f4       	brne	.+8      	; 0x2454 <usart_init_rs232+0x270>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    244c:	60 e4       	ldi	r22, 0x40	; 64
    244e:	85 e0       	ldi	r24, 0x05	; 5
    2450:	73 db       	rcall	.-2330   	; 0x1b38 <sysclk_enable_module>
    2452:	07 c0       	rjmp	.+14     	; 0x2462 <usart_init_rs232+0x27e>
	}
#endif
#ifdef TWIF
	else if (module == &TWIF) {
    2454:	c0 3b       	cpi	r28, 0xB0	; 176
    2456:	e4 e0       	ldi	r30, 0x04	; 4
    2458:	de 07       	cpc	r29, r30
    245a:	19 f4       	brne	.+6      	; 0x2462 <usart_init_rs232+0x27e>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TWI);
    245c:	60 e4       	ldi	r22, 0x40	; 64
    245e:	86 e0       	ldi	r24, 0x06	; 6
    2460:	6b db       	rcall	.-2346   	; 0x1b38 <sysclk_enable_module>
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    2462:	8d 81       	ldd	r24, Y+5	; 0x05
    2464:	8f 73       	andi	r24, 0x3F	; 63
    2466:	8d 83       	std	Y+5, r24	; 0x05
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
    2468:	f8 01       	movw	r30, r16
    246a:	94 81       	ldd	r25, Z+4	; 0x04
    246c:	85 81       	ldd	r24, Z+5	; 0x05
    246e:	89 2b       	or	r24, r25
    2470:	96 81       	ldd	r25, Z+6	; 0x06
    2472:	91 11       	cpse	r25, r1
    2474:	98 e0       	ldi	r25, 0x08	; 8
    2476:	89 2b       	or	r24, r25
    2478:	8d 83       	std	Y+5, r24	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    247a:	f8 01       	movw	r30, r16
    247c:	40 81       	ld	r20, Z
    247e:	51 81       	ldd	r21, Z+1	; 0x01
    2480:	62 81       	ldd	r22, Z+2	; 0x02
    2482:	73 81       	ldd	r23, Z+3	; 0x03
    2484:	00 e0       	ldi	r16, 0x00	; 0
    2486:	18 e4       	ldi	r17, 0x48	; 72
    2488:	28 ee       	ldi	r18, 0xE8	; 232
    248a:	31 e0       	ldi	r19, 0x01	; 1
    248c:	ce 01       	movw	r24, r28
    248e:	91 dd       	rcall	.-1246   	; 0x1fb2 <usart_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    2490:	9c 81       	ldd	r25, Y+4	; 0x04
    2492:	98 60       	ori	r25, 0x08	; 8
    2494:	9c 83       	std	Y+4, r25	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    2496:	9c 81       	ldd	r25, Y+4	; 0x04
    2498:	90 61       	ori	r25, 0x10	; 16
    249a:	9c 83       	std	Y+4, r25	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    249c:	df 91       	pop	r29
    249e:	cf 91       	pop	r28
    24a0:	1f 91       	pop	r17
    24a2:	0f 91       	pop	r16
    24a4:	08 95       	ret

000024a6 <ADC_init>:
 */ 
#include <asf.h>
#include "Drivers/ADC/ADC_init.h"
/* This driver can be used to initialize any of the ADCs */

void ADC_init(void){
    24a6:	ff 92       	push	r15
    24a8:	0f 93       	push	r16
    24aa:	1f 93       	push	r17
    24ac:	cf 93       	push	r28
    24ae:	df 93       	push	r29
	ADCA.CTRLA = 0b00000001; //Enables the ADC.
    24b0:	c0 e0       	ldi	r28, 0x00	; 0
    24b2:	d2 e0       	ldi	r29, 0x02	; 2
    24b4:	ff 24       	eor	r15, r15
    24b6:	f3 94       	inc	r15
    24b8:	f8 82       	st	Y, r15
	ADCA.CTRLB = 0b00000000; //Unsigned 12 bit mode.
    24ba:	19 82       	std	Y+1, r1	; 0x01
	ADCA.REFCTRL = 0b00010000; //Voltage reference of Vcc/1.6V
    24bc:	80 e1       	ldi	r24, 0x10	; 16
    24be:	8a 83       	std	Y+2, r24	; 0x02
	ADCA.PRESCALER = 0b00000101; //This is automatic prescalar of 128 on the clock.
    24c0:	85 e0       	ldi	r24, 0x05	; 5
    24c2:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    24c4:	61 e2       	ldi	r22, 0x21	; 33
    24c6:	70 e0       	ldi	r23, 0x00	; 0
    24c8:	82 e0       	ldi	r24, 0x02	; 2
    24ca:	5b dd       	rcall	.-1354   	; 0x1f82 <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    24cc:	08 2f       	mov	r16, r24
    24ce:	10 e0       	ldi	r17, 0x00	; 0
		data <<= 8;
    24d0:	10 2f       	mov	r17, r16
    24d2:	00 27       	eor	r16, r16
    24d4:	60 e2       	ldi	r22, 0x20	; 32
    24d6:	70 e0       	ldi	r23, 0x00	; 0
    24d8:	82 e0       	ldi	r24, 0x02	; 2
    24da:	53 dd       	rcall	.-1370   	; 0x1f82 <nvm_read_byte>
		data |= nvm_read_production_signature_row(ADCACAL0);
    24dc:	08 2b       	or	r16, r24
	ADCA.CAL = adc_get_calibration_data(ADC_CAL_ADCA); //Retrieve stored calibration data about the ADC.
    24de:	0c 87       	std	Y+12, r16	; 0x0c
    24e0:	1d 87       	std	Y+13, r17	; 0x0d

	ADCA.CH0.CTRL = 0b00000001; //Single ended input
    24e2:	f8 a2       	std	Y+32, r15	; 0x20
	ADCA.CH0.MUXCTRL = 0b00000000; //Reading ADCA pin 0.
    24e4:	19 a2       	std	Y+33, r1	; 0x21
    24e6:	df 91       	pop	r29
    24e8:	cf 91       	pop	r28
    24ea:	1f 91       	pop	r17
    24ec:	0f 91       	pop	r16
    24ee:	ff 90       	pop	r15
    24f0:	08 95       	ret

000024f2 <spi_select>:
	 PORTC.DIR &= 0b10111111;
	 SPIC.CTRL = 0b01010000; //Clock Double off, enable SPI, MSB DORD, master mode, SPI transfer mode set to 0, prescalar set to clkper/4 (has no effect in slave mode).
	 calibratePressure();
 }
 void spi_select(void){
	PORTC.OUT &= 0b11101111;
    24f2:	e0 e4       	ldi	r30, 0x40	; 64
    24f4:	f6 e0       	ldi	r31, 0x06	; 6
    24f6:	84 81       	ldd	r24, Z+4	; 0x04
    24f8:	8f 7e       	andi	r24, 0xEF	; 239
    24fa:	84 83       	std	Z+4, r24	; 0x04
    24fc:	08 95       	ret

000024fe <spi_deselect>:
 }
 void spi_deselect(void){
	PORTC.OUT |= 0b00010000;
    24fe:	e0 e4       	ldi	r30, 0x40	; 64
    2500:	f6 e0       	ldi	r31, 0x06	; 6
    2502:	84 81       	ldd	r24, Z+4	; 0x04
    2504:	80 61       	ori	r24, 0x10	; 16
    2506:	84 83       	std	Z+4, r24	; 0x04
    2508:	08 95       	ret

0000250a <spi_read>:
 }
 uint8_t spi_read(void){
	 //printf("spi_read\n");
	 SPIC.DATA = 0xFF; //Set the data to something we know.
    250a:	8f ef       	ldi	r24, 0xFF	; 255
    250c:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	 while(!(SPIC.STATUS>>7)); //Wait until new data comes in by monitoring the interrupt flag.
    2510:	e0 ec       	ldi	r30, 0xC0	; 192
    2512:	f8 e0       	ldi	r31, 0x08	; 8
    2514:	82 81       	ldd	r24, Z+2	; 0x02
    2516:	88 23       	and	r24, r24
    2518:	ec f7       	brge	.-6      	; 0x2514 <spi_read+0xa>
	 return SPIC.DATA; //Return the data.
    251a:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
 }
    251e:	08 95       	ret

00002520 <spi_write>:

 void spi_write(uint8_t data){
	 //printf("spi_write\n");
	 SPIC.DATA = data; //Take data from function argument and write it.
    2520:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	 //printf("1\n");
	 while(!(SPIC.STATUS>>7)); //Wait until data has been sent.
    2524:	e0 ec       	ldi	r30, 0xC0	; 192
    2526:	f8 e0       	ldi	r31, 0x08	; 8
    2528:	82 81       	ldd	r24, Z+2	; 0x02
    252a:	88 23       	and	r24, r24
    252c:	ec f7       	brge	.-6      	; 0x2528 <spi_write+0x8>
	 //printf("2\n");
 }
    252e:	08 95       	ret

00002530 <calibratePressure>:
 uint16_t c5;
 uint16_t c6;
 
 void calibratePressure(void){
	//printf("cal_press\n");
	spi_select();
    2530:	e0 df       	rcall	.-64     	; 0x24f2 <spi_select>
	 spi_write(0b10100010); //prom read ad1
    2532:	82 ea       	ldi	r24, 0xA2	; 162
    2534:	f5 df       	rcall	.-22     	; 0x2520 <spi_write>
	 c1 = ((uint16_t)spi_read())<<8;
    2536:	e9 df       	rcall	.-46     	; 0x250a <spi_read>
    2538:	10 92 d7 20 	sts	0x20D7, r1	; 0x8020d7 <c1>
    253c:	80 93 d8 20 	sts	0x20D8, r24	; 0x8020d8 <c1+0x1>
	 c1 += ((uint16_t)spi_read());
    2540:	e4 df       	rcall	.-56     	; 0x250a <spi_read>
    2542:	20 91 d7 20 	lds	r18, 0x20D7	; 0x8020d7 <c1>
    2546:	30 91 d8 20 	lds	r19, 0x20D8	; 0x8020d8 <c1+0x1>
    254a:	28 0f       	add	r18, r24
    254c:	31 1d       	adc	r19, r1
    254e:	20 93 d7 20 	sts	0x20D7, r18	; 0x8020d7 <c1>
    2552:	30 93 d8 20 	sts	0x20D8, r19	; 0x8020d8 <c1+0x1>
	 spi_deselect();
    2556:	d3 df       	rcall	.-90     	; 0x24fe <spi_deselect>
	 //printf("c1: %u\n",c1);

	 spi_select();
    2558:	cc df       	rcall	.-104    	; 0x24f2 <spi_select>
	 spi_write(0b10100100); //prom read ad2
    255a:	84 ea       	ldi	r24, 0xA4	; 164
    255c:	e1 df       	rcall	.-62     	; 0x2520 <spi_write>
	 c2 = ((uint16_t)spi_read())<<8;
    255e:	d5 df       	rcall	.-86     	; 0x250a <spi_read>
    2560:	10 92 d3 20 	sts	0x20D3, r1	; 0x8020d3 <c2>
    2564:	80 93 d4 20 	sts	0x20D4, r24	; 0x8020d4 <c2+0x1>
	 c2 += ((uint16_t)spi_read());
    2568:	d0 df       	rcall	.-96     	; 0x250a <spi_read>
    256a:	20 91 d3 20 	lds	r18, 0x20D3	; 0x8020d3 <c2>
    256e:	30 91 d4 20 	lds	r19, 0x20D4	; 0x8020d4 <c2+0x1>
    2572:	28 0f       	add	r18, r24
    2574:	31 1d       	adc	r19, r1
    2576:	20 93 d3 20 	sts	0x20D3, r18	; 0x8020d3 <c2>
    257a:	30 93 d4 20 	sts	0x20D4, r19	; 0x8020d4 <c2+0x1>
	 spi_deselect();
    257e:	bf df       	rcall	.-130    	; 0x24fe <spi_deselect>
	 //printf("c2: %u\n",c2);

	 spi_select();
    2580:	b8 df       	rcall	.-144    	; 0x24f2 <spi_select>
	 spi_write(0b10100110); //prom read ad3
    2582:	86 ea       	ldi	r24, 0xA6	; 166
    2584:	cd df       	rcall	.-102    	; 0x2520 <spi_write>
	 c3 = ((uint16_t)spi_read())<<8;
    2586:	c1 df       	rcall	.-126    	; 0x250a <spi_read>
    2588:	10 92 d9 20 	sts	0x20D9, r1	; 0x8020d9 <c3>
    258c:	80 93 da 20 	sts	0x20DA, r24	; 0x8020da <c3+0x1>
	 c3 += ((uint16_t)spi_read());
    2590:	bc df       	rcall	.-136    	; 0x250a <spi_read>
    2592:	20 91 d9 20 	lds	r18, 0x20D9	; 0x8020d9 <c3>
    2596:	30 91 da 20 	lds	r19, 0x20DA	; 0x8020da <c3+0x1>
    259a:	28 0f       	add	r18, r24
    259c:	31 1d       	adc	r19, r1
    259e:	20 93 d9 20 	sts	0x20D9, r18	; 0x8020d9 <c3>
    25a2:	30 93 da 20 	sts	0x20DA, r19	; 0x8020da <c3+0x1>
	 spi_deselect();
    25a6:	ab df       	rcall	.-170    	; 0x24fe <spi_deselect>
	 //printf("c3: %u\n",c3);

	 spi_select();
    25a8:	a4 df       	rcall	.-184    	; 0x24f2 <spi_select>
	 spi_write(0b10101000); //prom read ad4
    25aa:	88 ea       	ldi	r24, 0xA8	; 168
    25ac:	b9 df       	rcall	.-142    	; 0x2520 <spi_write>
	 c4 = ((uint16_t)spi_read())<<8;
    25ae:	ad df       	rcall	.-166    	; 0x250a <spi_read>
    25b0:	10 92 d1 20 	sts	0x20D1, r1	; 0x8020d1 <c4>
    25b4:	80 93 d2 20 	sts	0x20D2, r24	; 0x8020d2 <c4+0x1>
	 c4 += ((uint16_t)spi_read());
    25b8:	a8 df       	rcall	.-176    	; 0x250a <spi_read>
    25ba:	20 91 d1 20 	lds	r18, 0x20D1	; 0x8020d1 <c4>
    25be:	30 91 d2 20 	lds	r19, 0x20D2	; 0x8020d2 <c4+0x1>
    25c2:	28 0f       	add	r18, r24
    25c4:	31 1d       	adc	r19, r1
    25c6:	20 93 d1 20 	sts	0x20D1, r18	; 0x8020d1 <c4>
    25ca:	30 93 d2 20 	sts	0x20D2, r19	; 0x8020d2 <c4+0x1>
	 spi_deselect();
    25ce:	97 df       	rcall	.-210    	; 0x24fe <spi_deselect>
	 //printf("c4: %u\n",c4);

	 spi_select();
    25d0:	90 df       	rcall	.-224    	; 0x24f2 <spi_select>
	 spi_write(0b10101010); //prom read ad5
    25d2:	8a ea       	ldi	r24, 0xAA	; 170
    25d4:	a5 df       	rcall	.-182    	; 0x2520 <spi_write>
	 c5 = ((uint16_t)spi_read())<<8;
    25d6:	99 df       	rcall	.-206    	; 0x250a <spi_read>
    25d8:	10 92 d5 20 	sts	0x20D5, r1	; 0x8020d5 <c5>
    25dc:	80 93 d6 20 	sts	0x20D6, r24	; 0x8020d6 <c5+0x1>
	 c5 += ((uint16_t)spi_read());
    25e0:	94 df       	rcall	.-216    	; 0x250a <spi_read>
    25e2:	20 91 d5 20 	lds	r18, 0x20D5	; 0x8020d5 <c5>
    25e6:	30 91 d6 20 	lds	r19, 0x20D6	; 0x8020d6 <c5+0x1>
    25ea:	28 0f       	add	r18, r24
    25ec:	31 1d       	adc	r19, r1
    25ee:	20 93 d5 20 	sts	0x20D5, r18	; 0x8020d5 <c5>
    25f2:	30 93 d6 20 	sts	0x20D6, r19	; 0x8020d6 <c5+0x1>
	 spi_deselect();
    25f6:	83 df       	rcall	.-250    	; 0x24fe <spi_deselect>
	 //printf("c5: %u\n",c5);

	 spi_select();
    25f8:	7c df       	rcall	.-264    	; 0x24f2 <spi_select>
	 spi_write(0b10101100); //prom read ad6
    25fa:	8c ea       	ldi	r24, 0xAC	; 172
    25fc:	91 df       	rcall	.-222    	; 0x2520 <spi_write>
	 c6 = ((uint16_t)spi_read())<<8;
    25fe:	85 df       	rcall	.-246    	; 0x250a <spi_read>
    2600:	10 92 cf 20 	sts	0x20CF, r1	; 0x8020cf <c6>
    2604:	80 93 d0 20 	sts	0x20D0, r24	; 0x8020d0 <c6+0x1>
	 c6 += ((uint16_t)spi_read());
    2608:	80 df       	rcall	.-256    	; 0x250a <spi_read>
    260a:	20 91 cf 20 	lds	r18, 0x20CF	; 0x8020cf <c6>
    260e:	30 91 d0 20 	lds	r19, 0x20D0	; 0x8020d0 <c6+0x1>
    2612:	28 0f       	add	r18, r24
    2614:	31 1d       	adc	r19, r1
    2616:	20 93 cf 20 	sts	0x20CF, r18	; 0x8020cf <c6>
    261a:	30 93 d0 20 	sts	0x20D0, r19	; 0x8020d0 <c6+0x1>
	 spi_deselect();
    261e:	6f cf       	rjmp	.-290    	; 0x24fe <spi_deselect>
    2620:	08 95       	ret

00002622 <SPI_init>:
	 //printf("c6: %u\n",c6);
 }
 
 void SPI_init(void){
	 //printf("spi_init\n");
	 PORTC.DIR |= 0b10110000; //Set port to input.
    2622:	e0 e4       	ldi	r30, 0x40	; 64
    2624:	f6 e0       	ldi	r31, 0x06	; 6
    2626:	80 81       	ld	r24, Z
    2628:	80 6b       	ori	r24, 0xB0	; 176
    262a:	80 83       	st	Z, r24
	 PORTC.DIR &= 0b10111111;
    262c:	80 81       	ld	r24, Z
    262e:	8f 7b       	andi	r24, 0xBF	; 191
    2630:	80 83       	st	Z, r24
	 SPIC.CTRL = 0b01010000; //Clock Double off, enable SPI, MSB DORD, master mode, SPI transfer mode set to 0, prescalar set to clkper/4 (has no effect in slave mode).
    2632:	80 e5       	ldi	r24, 0x50	; 80
    2634:	80 93 c0 08 	sts	0x08C0, r24	; 0x8008c0 <__TEXT_REGION_LENGTH__+0x7008c0>
	 calibratePressure();
    2638:	7b cf       	rjmp	.-266    	; 0x2530 <calibratePressure>
    263a:	08 95       	ret

0000263c <getPressure>:
	 //printf("1\n");
	 while(!(SPIC.STATUS>>7)); //Wait until data has been sent.
	 //printf("2\n");
 }
 
 int32_t getPressure(void){
    263c:	2f 92       	push	r2
    263e:	3f 92       	push	r3
    2640:	4f 92       	push	r4
    2642:	5f 92       	push	r5
    2644:	6f 92       	push	r6
    2646:	7f 92       	push	r7
    2648:	8f 92       	push	r8
    264a:	9f 92       	push	r9
    264c:	af 92       	push	r10
    264e:	bf 92       	push	r11
    2650:	cf 92       	push	r12
    2652:	df 92       	push	r13
    2654:	ef 92       	push	r14
    2656:	ff 92       	push	r15
    2658:	0f 93       	push	r16
    265a:	1f 93       	push	r17
    265c:	cf 93       	push	r28
    265e:	df 93       	push	r29
    2660:	cd b7       	in	r28, 0x3d	; 61
    2662:	de b7       	in	r29, 0x3e	; 62
    2664:	6f 97       	sbiw	r28, 0x1f	; 31
    2666:	cd bf       	out	0x3d, r28	; 61
    2668:	de bf       	out	0x3e, r29	; 62
	//printf("get_press\n");
	spi_select();
    266a:	43 df       	rcall	.-378    	; 0x24f2 <spi_select>
	spi_write(0x48); //Ask for pressure value
    266c:	88 e4       	ldi	r24, 0x48	; 72
    266e:	58 df       	rcall	.-336    	; 0x2520 <spi_write>
	spi_deselect();
    2670:	46 df       	rcall	.-372    	; 0x24fe <spi_deselect>
    2672:	80 e0       	ldi	r24, 0x00	; 0
    2674:	90 e0       	ldi	r25, 0x00	; 0
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	do { barrier(); } while (--n);
    2676:	01 96       	adiw	r24, 0x01	; 1
    2678:	85 35       	cpi	r24, 0x55	; 85
    267a:	00 ed       	ldi	r16, 0xD0	; 208
    267c:	90 07       	cpc	r25, r16
    267e:	d9 f7       	brne	.-10     	; 0x2676 <getPressure+0x3a>
	delay_ms(10);

	spi_select();
    2680:	38 df       	rcall	.-400    	; 0x24f2 <spi_select>
	spi_write(0x00);
    2682:	80 e0       	ldi	r24, 0x00	; 0
    2684:	4d df       	rcall	.-358    	; 0x2520 <spi_write>
	uint32_t d1 = ((uint32_t)spi_read())<<16; //Typecast the 8 bit data to 32 bit, then move it 16 places to the left. Stores in temp variable.
    2686:	41 df       	rcall	.-382    	; 0x250a <spi_read>
    2688:	c8 2e       	mov	r12, r24
    268a:	d1 2c       	mov	r13, r1
    268c:	e1 2c       	mov	r14, r1
    268e:	f1 2c       	mov	r15, r1
    2690:	76 01       	movw	r14, r12
    2692:	dd 24       	eor	r13, r13
    2694:	cc 24       	eor	r12, r12
	d1 += ((uint32_t)spi_read())<<8; //Assign data to data + the new data but in the lower 8 bits.
    2696:	39 df       	rcall	.-398    	; 0x250a <spi_read>
    2698:	90 e0       	ldi	r25, 0x00	; 0
    269a:	a0 e0       	ldi	r26, 0x00	; 0
    269c:	b0 e0       	ldi	r27, 0x00	; 0
    269e:	ba 2f       	mov	r27, r26
    26a0:	a9 2f       	mov	r26, r25
    26a2:	98 2f       	mov	r25, r24
    26a4:	88 27       	eor	r24, r24
    26a6:	c8 0e       	add	r12, r24
    26a8:	d9 1e       	adc	r13, r25
    26aa:	ea 1e       	adc	r14, r26
    26ac:	fb 1e       	adc	r15, r27
	d1 += ((uint32_t)spi_read());
    26ae:	2d df       	rcall	.-422    	; 0x250a <spi_read>
    26b0:	a7 01       	movw	r20, r14
    26b2:	96 01       	movw	r18, r12
    26b4:	28 0f       	add	r18, r24
    26b6:	31 1d       	adc	r19, r1
    26b8:	41 1d       	adc	r20, r1
    26ba:	51 1d       	adc	r21, r1
    26bc:	2d 83       	std	Y+5, r18	; 0x05
    26be:	3e 83       	std	Y+6, r19	; 0x06
    26c0:	4f 83       	std	Y+7, r20	; 0x07
    26c2:	58 87       	std	Y+8, r21	; 0x08
	spi_deselect();
    26c4:	1c df       	rcall	.-456    	; 0x24fe <spi_deselect>
	//printf("d1: %li\n",d1);
	
	spi_select();
    26c6:	15 df       	rcall	.-470    	; 0x24f2 <spi_select>
	spi_write(0x58); //Ask for temp value.
    26c8:	88 e5       	ldi	r24, 0x58	; 88
    26ca:	2a df       	rcall	.-428    	; 0x2520 <spi_write>
	spi_deselect();
    26cc:	18 df       	rcall	.-464    	; 0x24fe <spi_deselect>
    26ce:	80 e0       	ldi	r24, 0x00	; 0
    26d0:	90 e0       	ldi	r25, 0x00	; 0
    26d2:	01 96       	adiw	r24, 0x01	; 1
    26d4:	85 35       	cpi	r24, 0x55	; 85
    26d6:	30 ed       	ldi	r19, 0xD0	; 208
    26d8:	93 07       	cpc	r25, r19
    26da:	d9 f7       	brne	.-10     	; 0x26d2 <getPressure+0x96>
	delay_ms(10);
	
	spi_select();
    26dc:	0a df       	rcall	.-492    	; 0x24f2 <spi_select>
	spi_write(0x00);
    26de:	80 e0       	ldi	r24, 0x00	; 0
    26e0:	1f df       	rcall	.-450    	; 0x2520 <spi_write>
	uint32_t d2 = ((uint32_t)spi_read())<<16;
    26e2:	13 df       	rcall	.-474    	; 0x250a <spi_read>
    26e4:	08 2f       	mov	r16, r24
	d2 += ((uint32_t)spi_read())<<8;
    26e6:	11 df       	rcall	.-478    	; 0x250a <spi_read>
    26e8:	f8 2e       	mov	r15, r24
	d2 += ((uint32_t)spi_read());
    26ea:	0f df       	rcall	.-482    	; 0x250a <spi_read>
    26ec:	18 2f       	mov	r17, r24
	spi_deselect();
    26ee:	07 df       	rcall	.-498    	; 0x24fe <spi_deselect>
	//printf("d2: %li\n",d2);
	

	int32_t dT = (int64_t)d2 - (((int64_t)c5)*(256));
    26f0:	a0 91 d5 20 	lds	r26, 0x20D5	; 0x8020d5 <c5>
    26f4:	b0 91 d6 20 	lds	r27, 0x20D6	; 0x8020d6 <c5+0x1>
    26f8:	20 e0       	ldi	r18, 0x00	; 0
    26fa:	3f ef       	ldi	r19, 0xFF	; 255
    26fc:	4f ef       	ldi	r20, 0xFF	; 255
    26fe:	5f ef       	ldi	r21, 0xFF	; 255
    2700:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <__muluhisi3>
    2704:	2b 01       	movw	r4, r22
    2706:	3c 01       	movw	r6, r24
    2708:	41 0e       	add	r4, r17
    270a:	51 1c       	adc	r5, r1
    270c:	61 1c       	adc	r6, r1
    270e:	71 1c       	adc	r7, r1
	spi_deselect();
	delay_ms(10);
	
	spi_select();
	spi_write(0x00);
	uint32_t d2 = ((uint32_t)spi_read())<<16;
    2710:	40 2f       	mov	r20, r16
    2712:	50 e0       	ldi	r21, 0x00	; 0
    2714:	60 e0       	ldi	r22, 0x00	; 0
    2716:	70 e0       	ldi	r23, 0x00	; 0
    2718:	ba 01       	movw	r22, r20
    271a:	55 27       	eor	r21, r21
    271c:	44 27       	eor	r20, r20
    271e:	d3 01       	movw	r26, r6
    2720:	c2 01       	movw	r24, r4
    2722:	84 0f       	add	r24, r20
    2724:	95 1f       	adc	r25, r21
    2726:	a6 1f       	adc	r26, r22
    2728:	b7 1f       	adc	r27, r23
	d2 += ((uint32_t)spi_read())<<8;
    272a:	4f 2c       	mov	r4, r15
    272c:	51 2c       	mov	r5, r1
    272e:	61 2c       	mov	r6, r1
    2730:	71 2c       	mov	r7, r1
    2732:	76 2c       	mov	r7, r6
    2734:	65 2c       	mov	r6, r5
    2736:	54 2c       	mov	r5, r4
    2738:	44 24       	eor	r4, r4
	d2 += ((uint32_t)spi_read());
	spi_deselect();
	//printf("d2: %li\n",d2);
	

	int32_t dT = (int64_t)d2 - (((int64_t)c5)*(256));
    273a:	48 0e       	add	r4, r24
    273c:	59 1e       	adc	r5, r25
    273e:	6a 1e       	adc	r6, r26
    2740:	7b 1e       	adc	r7, r27
	int64_t offset = ((int64_t)c2)*(65536) + ((((int64_t)c4)*((int64_t)dT))/(128));
    2742:	d3 01       	movw	r26, r6
    2744:	c2 01       	movw	r24, r4
    2746:	bb 0f       	add	r27, r27
    2748:	88 0b       	sbc	r24, r24
    274a:	98 2f       	mov	r25, r24
    274c:	dc 01       	movw	r26, r24
    274e:	89 83       	std	Y+1, r24	; 0x01
    2750:	9a 83       	std	Y+2, r25	; 0x02
    2752:	ab 83       	std	Y+3, r26	; 0x03
    2754:	bc 83       	std	Y+4, r27	; 0x04
	int64_t sens = (((int64_t)c1)*(32768)) + ((((int64_t)c3)*((int64_t)dT))/256);
    2756:	80 91 d7 20 	lds	r24, 0x20D7	; 0x8020d7 <c1>
    275a:	90 91 d8 20 	lds	r25, 0x20D8	; 0x8020d8 <c1+0x1>
    275e:	4c 01       	movw	r8, r24
    2760:	28 2f       	mov	r18, r24
    2762:	39 2d       	mov	r19, r9
    2764:	40 e0       	ldi	r20, 0x00	; 0
    2766:	50 e0       	ldi	r21, 0x00	; 0
    2768:	60 e0       	ldi	r22, 0x00	; 0
    276a:	70 e0       	ldi	r23, 0x00	; 0
    276c:	80 e0       	ldi	r24, 0x00	; 0
    276e:	90 e0       	ldi	r25, 0x00	; 0
    2770:	0f e0       	ldi	r16, 0x0F	; 15
    2772:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <__ashldi3>
    2776:	22 2e       	mov	r2, r18
    2778:	3d 87       	std	Y+13, r19	; 0x0d
    277a:	4e 87       	std	Y+14, r20	; 0x0e
    277c:	5f 87       	std	Y+15, r21	; 0x0f
    277e:	68 8b       	std	Y+16, r22	; 0x10
    2780:	79 8b       	std	Y+17, r23	; 0x11
    2782:	8a 8b       	std	Y+18, r24	; 0x12
    2784:	9b 8b       	std	Y+19, r25	; 0x13
    2786:	00 91 d9 20 	lds	r16, 0x20D9	; 0x8020d9 <c3>
    278a:	10 91 da 20 	lds	r17, 0x20DA	; 0x8020da <c3+0x1>
    278e:	a0 2e       	mov	r10, r16
    2790:	b1 2e       	mov	r11, r17
    2792:	c1 2c       	mov	r12, r1
    2794:	d1 2c       	mov	r13, r1
    2796:	e1 2c       	mov	r14, r1
    2798:	f1 2c       	mov	r15, r1
    279a:	00 e0       	ldi	r16, 0x00	; 0
    279c:	10 e0       	ldi	r17, 0x00	; 0
    279e:	24 2d       	mov	r18, r4
    27a0:	35 2d       	mov	r19, r5
    27a2:	46 2d       	mov	r20, r6
    27a4:	57 2d       	mov	r21, r7
    27a6:	69 81       	ldd	r22, Y+1	; 0x01
    27a8:	76 2f       	mov	r23, r22
    27aa:	86 2f       	mov	r24, r22
    27ac:	96 2f       	mov	r25, r22
    27ae:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <__muldi3>
    27b2:	32 2e       	mov	r3, r18
    27b4:	83 2e       	mov	r8, r19
    27b6:	94 2e       	mov	r9, r20
    27b8:	e5 2f       	mov	r30, r21
    27ba:	6d 8b       	std	Y+21, r22	; 0x15
    27bc:	7c 8b       	std	Y+20, r23	; 0x14
    27be:	a8 2e       	mov	r10, r24
    27c0:	b9 2e       	mov	r11, r25
    27c2:	a0 e0       	ldi	r26, 0x00	; 0
    27c4:	0e 94 76 1e 	call	0x3cec	; 0x3cec <__cmpdi2_s8>
    27c8:	84 f4       	brge	.+32     	; 0x27ea <getPressure+0x1ae>
    27ca:	21 50       	subi	r18, 0x01	; 1
    27cc:	3f 4f       	sbci	r19, 0xFF	; 255
    27ce:	4f 4f       	sbci	r20, 0xFF	; 255
    27d0:	5f 4f       	sbci	r21, 0xFF	; 255
    27d2:	6f 4f       	sbci	r22, 0xFF	; 255
    27d4:	7f 4f       	sbci	r23, 0xFF	; 255
    27d6:	8f 4f       	sbci	r24, 0xFF	; 255
    27d8:	9f 4f       	sbci	r25, 0xFF	; 255
    27da:	32 2e       	mov	r3, r18
    27dc:	83 2e       	mov	r8, r19
    27de:	94 2e       	mov	r9, r20
    27e0:	e5 2f       	mov	r30, r21
    27e2:	6d 8b       	std	Y+21, r22	; 0x15
    27e4:	7c 8b       	std	Y+20, r23	; 0x14
    27e6:	a8 2e       	mov	r10, r24
    27e8:	b9 2e       	mov	r11, r25
    27ea:	23 2d       	mov	r18, r3
    27ec:	38 2d       	mov	r19, r8
    27ee:	49 2d       	mov	r20, r9
    27f0:	5e 2f       	mov	r21, r30
    27f2:	6d 89       	ldd	r22, Y+21	; 0x15
    27f4:	7c 89       	ldd	r23, Y+20	; 0x14
    27f6:	8a 2d       	mov	r24, r10
    27f8:	9b 2d       	mov	r25, r11
    27fa:	08 e0       	ldi	r16, 0x08	; 8
    27fc:	0e 94 3a 1e 	call	0x3c74	; 0x3c74 <__ashrdi3>
    2800:	a2 2e       	mov	r10, r18
    2802:	b3 2e       	mov	r11, r19
    2804:	c4 2e       	mov	r12, r20
    2806:	d5 2e       	mov	r13, r21
    2808:	e6 2e       	mov	r14, r22
    280a:	f7 2e       	mov	r15, r23
    280c:	08 2f       	mov	r16, r24
    280e:	19 2f       	mov	r17, r25
    2810:	22 2d       	mov	r18, r2
    2812:	3d 85       	ldd	r19, Y+13	; 0x0d
    2814:	4e 85       	ldd	r20, Y+14	; 0x0e
    2816:	5f 85       	ldd	r21, Y+15	; 0x0f
    2818:	68 89       	ldd	r22, Y+16	; 0x10
    281a:	79 89       	ldd	r23, Y+17	; 0x11
    281c:	8a 89       	ldd	r24, Y+18	; 0x12
    281e:	9b 89       	ldd	r25, Y+19	; 0x13
    2820:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <__adddi3>
	int32_t pressure = ((((int64_t)d1) * (((uint64_t)sens)/2097152)) - (int64_t)offset)/32768;
    2824:	05 e1       	ldi	r16, 0x15	; 21
    2826:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <__lshrdi3>
    282a:	cd 80       	ldd	r12, Y+5	; 0x05
    282c:	de 80       	ldd	r13, Y+6	; 0x06
    282e:	ef 80       	ldd	r14, Y+7	; 0x07
    2830:	f8 84       	ldd	r15, Y+8	; 0x08
    2832:	56 01       	movw	r10, r12
    2834:	67 01       	movw	r12, r14
    2836:	e1 2c       	mov	r14, r1
    2838:	f1 2c       	mov	r15, r1
    283a:	87 01       	movw	r16, r14
    283c:	ad 82       	std	Y+5, r10	; 0x05
    283e:	be 82       	std	Y+6, r11	; 0x06
    2840:	cf 82       	std	Y+7, r12	; 0x07
    2842:	d8 86       	std	Y+8, r13	; 0x08
    2844:	e9 86       	std	Y+9, r14	; 0x09
    2846:	fa 86       	std	Y+10, r15	; 0x0a
    2848:	0b 87       	std	Y+11, r16	; 0x0b
    284a:	1c 87       	std	Y+12, r17	; 0x0c
    284c:	e1 2c       	mov	r14, r1
    284e:	f1 2c       	mov	r15, r1
    2850:	00 e0       	ldi	r16, 0x00	; 0
    2852:	10 e0       	ldi	r17, 0x00	; 0
    2854:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <__muldi3>
    2858:	2d 83       	std	Y+5, r18	; 0x05
    285a:	3d 87       	std	Y+13, r19	; 0x0d
    285c:	4e 87       	std	Y+14, r20	; 0x0e
    285e:	5f 87       	std	Y+15, r21	; 0x0f
    2860:	68 8b       	std	Y+16, r22	; 0x10
    2862:	79 8b       	std	Y+17, r23	; 0x11
    2864:	8a 8b       	std	Y+18, r24	; 0x12
    2866:	9b 8b       	std	Y+19, r25	; 0x13
	spi_deselect();
	//printf("d2: %li\n",d2);
	

	int32_t dT = (int64_t)d2 - (((int64_t)c5)*(256));
	int64_t offset = ((int64_t)c2)*(65536) + ((((int64_t)c4)*((int64_t)dT))/(128));
    2868:	80 91 d3 20 	lds	r24, 0x20D3	; 0x8020d3 <c2>
    286c:	90 91 d4 20 	lds	r25, 0x20D4	; 0x8020d4 <c2+0x1>
    2870:	4c 01       	movw	r8, r24
    2872:	28 2f       	mov	r18, r24
    2874:	39 2d       	mov	r19, r9
    2876:	40 e0       	ldi	r20, 0x00	; 0
    2878:	50 e0       	ldi	r21, 0x00	; 0
    287a:	60 e0       	ldi	r22, 0x00	; 0
    287c:	70 e0       	ldi	r23, 0x00	; 0
    287e:	80 e0       	ldi	r24, 0x00	; 0
    2880:	90 e0       	ldi	r25, 0x00	; 0
    2882:	00 e1       	ldi	r16, 0x10	; 16
    2884:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <__ashldi3>
    2888:	22 2e       	mov	r2, r18
    288a:	33 2e       	mov	r3, r19
    288c:	84 2e       	mov	r8, r20
    288e:	95 2e       	mov	r9, r21
    2890:	6c 8b       	std	Y+20, r22	; 0x14
    2892:	7d 8b       	std	Y+21, r23	; 0x15
    2894:	8e 8b       	std	Y+22, r24	; 0x16
    2896:	9f 8b       	std	Y+23, r25	; 0x17
    2898:	40 91 d1 20 	lds	r20, 0x20D1	; 0x8020d1 <c4>
    289c:	50 91 d2 20 	lds	r21, 0x20D2	; 0x8020d2 <c4+0x1>
    28a0:	5a 01       	movw	r10, r20
    28a2:	c1 2c       	mov	r12, r1
    28a4:	d1 2c       	mov	r13, r1
    28a6:	e1 2c       	mov	r14, r1
    28a8:	f1 2c       	mov	r15, r1
    28aa:	87 01       	movw	r16, r14
    28ac:	48 8f       	std	Y+24, r20	; 0x18
    28ae:	b9 8e       	std	Y+25, r11	; 0x19
    28b0:	ca 8e       	std	Y+26, r12	; 0x1a
    28b2:	db 8e       	std	Y+27, r13	; 0x1b
    28b4:	ec 8e       	std	Y+28, r14	; 0x1c
    28b6:	fd 8e       	std	Y+29, r15	; 0x1d
    28b8:	0e 8f       	std	Y+30, r16	; 0x1e
    28ba:	1f 8f       	std	Y+31, r17	; 0x1f
    28bc:	a4 2c       	mov	r10, r4
    28be:	b5 2c       	mov	r11, r5
    28c0:	c6 2c       	mov	r12, r6
    28c2:	d7 2c       	mov	r13, r7
    28c4:	e9 80       	ldd	r14, Y+1	; 0x01
    28c6:	fe 2c       	mov	r15, r14
    28c8:	0e 2d       	mov	r16, r14
    28ca:	1e 2d       	mov	r17, r14
    28cc:	28 8d       	ldd	r18, Y+24	; 0x18
    28ce:	39 8d       	ldd	r19, Y+25	; 0x19
    28d0:	40 e0       	ldi	r20, 0x00	; 0
    28d2:	50 e0       	ldi	r21, 0x00	; 0
    28d4:	60 e0       	ldi	r22, 0x00	; 0
    28d6:	70 e0       	ldi	r23, 0x00	; 0
    28d8:	80 e0       	ldi	r24, 0x00	; 0
    28da:	90 e0       	ldi	r25, 0x00	; 0
    28dc:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <__muldi3>
    28e0:	e2 2f       	mov	r30, r18
    28e2:	73 2e       	mov	r7, r19
    28e4:	64 2e       	mov	r6, r20
    28e6:	55 2e       	mov	r5, r21
    28e8:	46 2e       	mov	r4, r22
    28ea:	79 83       	std	Y+1, r23	; 0x01
    28ec:	a8 2e       	mov	r10, r24
    28ee:	b9 2e       	mov	r11, r25
    28f0:	a0 e0       	ldi	r26, 0x00	; 0
    28f2:	0e 94 76 1e 	call	0x3cec	; 0x3cec <__cmpdi2_s8>
    28f6:	5c f4       	brge	.+22     	; 0x290e <getPressure+0x2d2>
    28f8:	af e7       	ldi	r26, 0x7F	; 127
    28fa:	0e 94 61 1e 	call	0x3cc2	; 0x3cc2 <__adddi3_s8>
    28fe:	e2 2f       	mov	r30, r18
    2900:	73 2e       	mov	r7, r19
    2902:	64 2e       	mov	r6, r20
    2904:	55 2e       	mov	r5, r21
    2906:	46 2e       	mov	r4, r22
    2908:	79 83       	std	Y+1, r23	; 0x01
    290a:	a8 2e       	mov	r10, r24
    290c:	b9 2e       	mov	r11, r25
    290e:	2e 2f       	mov	r18, r30
    2910:	37 2d       	mov	r19, r7
    2912:	46 2d       	mov	r20, r6
    2914:	55 2d       	mov	r21, r5
    2916:	64 2d       	mov	r22, r4
    2918:	79 81       	ldd	r23, Y+1	; 0x01
    291a:	8a 2d       	mov	r24, r10
    291c:	9b 2d       	mov	r25, r11
    291e:	07 e0       	ldi	r16, 0x07	; 7
    2920:	0e 94 3a 1e 	call	0x3c74	; 0x3c74 <__ashrdi3>
    2924:	a2 2e       	mov	r10, r18
    2926:	b3 2e       	mov	r11, r19
    2928:	c4 2e       	mov	r12, r20
    292a:	d5 2e       	mov	r13, r21
    292c:	e6 2e       	mov	r14, r22
    292e:	f7 2e       	mov	r15, r23
    2930:	08 2f       	mov	r16, r24
    2932:	19 2f       	mov	r17, r25
    2934:	22 2d       	mov	r18, r2
    2936:	33 2d       	mov	r19, r3
    2938:	48 2d       	mov	r20, r8
    293a:	59 2d       	mov	r21, r9
    293c:	6c 89       	ldd	r22, Y+20	; 0x14
    293e:	7d 89       	ldd	r23, Y+21	; 0x15
    2940:	8e 89       	ldd	r24, Y+22	; 0x16
    2942:	9f 89       	ldd	r25, Y+23	; 0x17
    2944:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <__adddi3>
    2948:	a2 2e       	mov	r10, r18
    294a:	b3 2e       	mov	r11, r19
    294c:	c4 2e       	mov	r12, r20
    294e:	d5 2e       	mov	r13, r21
    2950:	e6 2e       	mov	r14, r22
    2952:	f7 2e       	mov	r15, r23
    2954:	08 2f       	mov	r16, r24
    2956:	19 2f       	mov	r17, r25
	int64_t sens = (((int64_t)c1)*(32768)) + ((((int64_t)c3)*((int64_t)dT))/256);
	int32_t pressure = ((((int64_t)d1) * (((uint64_t)sens)/2097152)) - (int64_t)offset)/32768;
    2958:	2d 81       	ldd	r18, Y+5	; 0x05
    295a:	3d 85       	ldd	r19, Y+13	; 0x0d
    295c:	4e 85       	ldd	r20, Y+14	; 0x0e
    295e:	5f 85       	ldd	r21, Y+15	; 0x0f
    2960:	68 89       	ldd	r22, Y+16	; 0x10
    2962:	79 89       	ldd	r23, Y+17	; 0x11
    2964:	8a 89       	ldd	r24, Y+18	; 0x12
    2966:	9b 89       	ldd	r25, Y+19	; 0x13
    2968:	0e 94 6d 1e 	call	0x3cda	; 0x3cda <__subdi3>
    296c:	0f e0       	ldi	r16, 0x0F	; 15
    296e:	0e 94 3c 1e 	call	0x3c78	; 0x3c78 <__lshrdi3>
    2972:	62 2f       	mov	r22, r18
    2974:	73 2f       	mov	r23, r19
    2976:	84 2f       	mov	r24, r20
    2978:	95 2f       	mov	r25, r21
	
	return pressure;
    297a:	6f 96       	adiw	r28, 0x1f	; 31
    297c:	cd bf       	out	0x3d, r28	; 61
    297e:	de bf       	out	0x3e, r29	; 62
    2980:	df 91       	pop	r29
    2982:	cf 91       	pop	r28
    2984:	1f 91       	pop	r17
    2986:	0f 91       	pop	r16
    2988:	ff 90       	pop	r15
    298a:	ef 90       	pop	r14
    298c:	df 90       	pop	r13
    298e:	cf 90       	pop	r12
    2990:	bf 90       	pop	r11
    2992:	af 90       	pop	r10
    2994:	9f 90       	pop	r9
    2996:	8f 90       	pop	r8
    2998:	7f 90       	pop	r7
    299a:	6f 90       	pop	r6
    299c:	5f 90       	pop	r5
    299e:	4f 90       	pop	r4
    29a0:	3f 90       	pop	r3
    29a2:	2f 90       	pop	r2
    29a4:	08 95       	ret

000029a6 <getTemperature>:
 #include <math.h>
 #include "Drivers/Temperature/getTemperature.h"

 /* getTemperature method for NTC Thermistor 10k Bead */

 float getTemperature(void){
    29a6:	8f 92       	push	r8
    29a8:	9f 92       	push	r9
    29aa:	af 92       	push	r10
    29ac:	bf 92       	push	r11
    29ae:	cf 92       	push	r12
    29b0:	df 92       	push	r13
    29b2:	ef 92       	push	r14
    29b4:	ff 92       	push	r15
	ADCA.CH0.CTRL |= 0b10000000; //Start the conversion.. FOR THOMAS: THIS IS A BITWISE OPERATOR THAT KEEPS 1's and MODIFIES ZEROES.
    29b6:	e0 e0       	ldi	r30, 0x00	; 0
    29b8:	f2 e0       	ldi	r31, 0x02	; 2
    29ba:	80 a1       	ldd	r24, Z+32	; 0x20
    29bc:	80 68       	ori	r24, 0x80	; 128
    29be:	80 a3       	std	Z+32, r24	; 0x20
		
	while(ADCA.CH0.INTFLAGS == 0); //Wait until conversion is done.
    29c0:	83 a1       	ldd	r24, Z+35	; 0x23
    29c2:	88 23       	and	r24, r24
    29c4:	e9 f3       	breq	.-6      	; 0x29c0 <getTemperature+0x1a>
		
	uint16_t read_adc = ADCA.CH0.RES; // save reading
    29c6:	60 91 24 02 	lds	r22, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
    29ca:	70 91 25 02 	lds	r23, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
	//printf("read adc: %i\n",read_adc);
	float voltage = (0.000502512562*read_adc - 0.095979899); //converts the adc reading into an actual voltage based off of slope.
    29ce:	80 e0       	ldi	r24, 0x00	; 0
    29d0:	90 e0       	ldi	r25, 0x00	; 0
    29d2:	6d d3       	rcall	.+1754   	; 0x30ae <__floatunsisf>
    29d4:	2c e0       	ldi	r18, 0x0C	; 12
    29d6:	3b eb       	ldi	r19, 0xBB	; 187
    29d8:	43 e0       	ldi	r20, 0x03	; 3
    29da:	5a e3       	ldi	r21, 0x3A	; 58
    29dc:	89 d4       	rcall	.+2322   	; 0x32f0 <__mulsf3>
    29de:	2c e1       	ldi	r18, 0x1C	; 28
    29e0:	31 e9       	ldi	r19, 0x91	; 145
    29e2:	44 ec       	ldi	r20, 0xC4	; 196
    29e4:	5d e3       	ldi	r21, 0x3D	; 61
    29e6:	5c d2       	rcall	.+1208   	; 0x2ea0 <__subsf3>
    29e8:	9b 01       	movw	r18, r22
    29ea:	ac 01       	movw	r20, r24

	float resistance = (3.3*10000)/(3.3 - voltage) - 10000; //Need to convert our voltage reading into the resistance across the thermistor. To find this we use 3.3(R1)/(3.3-vadc) - R1
    29ec:	63 e3       	ldi	r22, 0x33	; 51
    29ee:	73 e3       	ldi	r23, 0x33	; 51
    29f0:	83 e5       	ldi	r24, 0x53	; 83
    29f2:	90 e4       	ldi	r25, 0x40	; 64
    29f4:	55 d2       	rcall	.+1194   	; 0x2ea0 <__subsf3>
    29f6:	9b 01       	movw	r18, r22
    29f8:	ac 01       	movw	r20, r24
    29fa:	60 e0       	ldi	r22, 0x00	; 0
    29fc:	78 ee       	ldi	r23, 0xE8	; 232
    29fe:	80 e0       	ldi	r24, 0x00	; 0
    2a00:	97 e4       	ldi	r25, 0x47	; 71
    2a02:	b3 d2       	rcall	.+1382   	; 0x2f6a <__divsf3>
    2a04:	20 e0       	ldi	r18, 0x00	; 0
    2a06:	30 e4       	ldi	r19, 0x40	; 64
    2a08:	4c e1       	ldi	r20, 0x1C	; 28
    2a0a:	56 e4       	ldi	r21, 0x46	; 70
    2a0c:	49 d2       	rcall	.+1170   	; 0x2ea0 <__subsf3>
	
	float a_const = 0.003354016; //A value for the NTCLE100E3103HT1 in the Steinhart-Hart equation (T = 1/(A + Bln(resistance) + Dln^3(resistance))
	float b_const = 0.000256985; //B value
	float d_const = 0.00000006383091; //D value.
	return 1/(a_const+ b_const*log(resistance/10000) + d_const*log(resistance/10000)*log(resistance/10000)*log(resistance/10000)); //Steinhart-Hart to find temperature then return it.
    2a0e:	20 e0       	ldi	r18, 0x00	; 0
    2a10:	30 e4       	ldi	r19, 0x40	; 64
    2a12:	4c e1       	ldi	r20, 0x1C	; 28
    2a14:	56 e4       	ldi	r21, 0x46	; 70
    2a16:	a9 d2       	rcall	.+1362   	; 0x2f6a <__divsf3>
    2a18:	2b d4       	rcall	.+2134   	; 0x3270 <log>
    2a1a:	6b 01       	movw	r12, r22
    2a1c:	7c 01       	movw	r14, r24
    2a1e:	21 ef       	ldi	r18, 0xF1	; 241
    2a20:	3b eb       	ldi	r19, 0xBB	; 187
    2a22:	46 e8       	ldi	r20, 0x86	; 134
    2a24:	59 e3       	ldi	r21, 0x39	; 57
    2a26:	64 d4       	rcall	.+2248   	; 0x32f0 <__mulsf3>
    2a28:	2d e0       	ldi	r18, 0x0D	; 13
    2a2a:	3f ec       	ldi	r19, 0xCF	; 207
    2a2c:	4b e5       	ldi	r20, 0x5B	; 91
    2a2e:	5b e3       	ldi	r21, 0x3B	; 59
    2a30:	38 d2       	rcall	.+1136   	; 0x2ea2 <__addsf3>
    2a32:	4b 01       	movw	r8, r22
    2a34:	5c 01       	movw	r10, r24
    2a36:	2a e6       	ldi	r18, 0x6A	; 106
    2a38:	33 e1       	ldi	r19, 0x13	; 19
    2a3a:	49 e8       	ldi	r20, 0x89	; 137
    2a3c:	53 e3       	ldi	r21, 0x33	; 51
    2a3e:	c7 01       	movw	r24, r14
    2a40:	b6 01       	movw	r22, r12
    2a42:	56 d4       	rcall	.+2220   	; 0x32f0 <__mulsf3>
    2a44:	9b 01       	movw	r18, r22
    2a46:	ac 01       	movw	r20, r24
    2a48:	c7 01       	movw	r24, r14
    2a4a:	b6 01       	movw	r22, r12
    2a4c:	51 d4       	rcall	.+2210   	; 0x32f0 <__mulsf3>
    2a4e:	9b 01       	movw	r18, r22
    2a50:	ac 01       	movw	r20, r24
    2a52:	c7 01       	movw	r24, r14
    2a54:	b6 01       	movw	r22, r12
    2a56:	4c d4       	rcall	.+2200   	; 0x32f0 <__mulsf3>
    2a58:	9b 01       	movw	r18, r22
    2a5a:	ac 01       	movw	r20, r24
    2a5c:	c5 01       	movw	r24, r10
    2a5e:	b4 01       	movw	r22, r8
    2a60:	20 d2       	rcall	.+1088   	; 0x2ea2 <__addsf3>
    2a62:	9b 01       	movw	r18, r22
    2a64:	ac 01       	movw	r20, r24
    2a66:	60 e0       	ldi	r22, 0x00	; 0
    2a68:	70 e0       	ldi	r23, 0x00	; 0
    2a6a:	80 e8       	ldi	r24, 0x80	; 128
    2a6c:	9f e3       	ldi	r25, 0x3F	; 63
    2a6e:	7d d2       	rcall	.+1274   	; 0x2f6a <__divsf3>
    2a70:	ff 90       	pop	r15
    2a72:	ef 90       	pop	r14
    2a74:	df 90       	pop	r13
    2a76:	cf 90       	pop	r12
    2a78:	bf 90       	pop	r11
    2a7a:	af 90       	pop	r10
    2a7c:	9f 90       	pop	r9
    2a7e:	8f 90       	pop	r8
    2a80:	08 95       	ret

00002a82 <TCD0_init>:
	TCE0.CCB = TCE0.PER - (TCE0.PER/duty_cycle);
	TCE0.CCC = TCE0.PER - (TCE0.PER/duty_cycle);
	TCE0.CCD = TCE0.PER - (TCE0.PER/duty_cycle);
}
void TCD0_init(void){
	PORTD.DIR = 0b11111111; //sets to output.
    2a82:	8f ef       	ldi	r24, 0xFF	; 255
    2a84:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <__TEXT_REGION_LENGTH__+0x700660>
	TCD0.CTRLA = 0b00000110; //0110 is prescalar 256.
    2a88:	e0 e0       	ldi	r30, 0x00	; 0
    2a8a:	f9 e0       	ldi	r31, 0x09	; 9
    2a8c:	86 e0       	ldi	r24, 0x06	; 6
    2a8e:	80 83       	st	Z, r24
	TCD0.CTRLB = 0b10110011; //OCn output pin (currently set at 0) and single slope PWM.
    2a90:	83 eb       	ldi	r24, 0xB3	; 179
    2a92:	81 83       	std	Z+1, r24	; 0x01
    2a94:	08 95       	ret

00002a96 <TCF0_init>:
}

void TCF0_init(void){
	TCF0.CTRLA = 0b00000111; //presc 1024
    2a96:	e0 e0       	ldi	r30, 0x00	; 0
    2a98:	fb e0       	ldi	r31, 0x0B	; 11
    2a9a:	87 e0       	ldi	r24, 0x07	; 7
    2a9c:	80 83       	st	Z, r24
	TCF0.CTRLB = 0b00000000;
    2a9e:	11 82       	std	Z+1, r1	; 0x01
	TCF0.CNT = 0;
    2aa0:	10 a2       	std	Z+32, r1	; 0x20
    2aa2:	11 a2       	std	Z+33, r1	; 0x21
	TCF0.PER = 312; //period of 312 = ~100Hz = ~10ms before overflow
    2aa4:	88 e3       	ldi	r24, 0x38	; 56
    2aa6:	91 e0       	ldi	r25, 0x01	; 1
    2aa8:	86 a3       	std	Z+38, r24	; 0x26
    2aaa:	97 a3       	std	Z+39, r25	; 0x27
    2aac:	08 95       	ret

00002aae <usart_serial_getchar>:
 * \param usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if usart, uint8_t *data)
{
    2aae:	cf 93       	push	r28
    2ab0:	df 93       	push	r29
    2ab2:	eb 01       	movw	r28, r22
	*data = usart_getchar(usart);
    2ab4:	78 da       	rcall	.-2832   	; 0x1fa6 <usart_getchar>
    2ab6:	88 83       	st	Y, r24
}
    2ab8:	df 91       	pop	r29
    2aba:	cf 91       	pop	r28
    2abc:	08 95       	ret

00002abe <usart_serial_putchar>:
 *
 * \return Status code
 */
static inline enum status_code usart_serial_putchar(usart_if usart, uint8_t c)
{
	return usart_putchar(usart, c);
    2abe:	6b ca       	rjmp	.-2858   	; 0x1f96 <usart_putchar>
}
    2ac0:	08 95       	ret

00002ac2 <UART_Comms_Init>:
   to start the uart communications */

#include "conf_usart_serial.h" //Includes the information in the config file
#include <asf.h>

void UART_Comms_Init(void){
    2ac2:	cf 93       	push	r28
    2ac4:	df 93       	push	r29
    2ac6:	cd b7       	in	r28, 0x3d	; 61
    2ac8:	de b7       	in	r29, 0x3e	; 62
    2aca:	27 97       	sbiw	r28, 0x07	; 7
    2acc:	cd bf       	out	0x3d, r28	; 61
    2ace:	de bf       	out	0x3e, r29	; 62
		.paritytype = USART_SERIAL_PARITY,
		.stopbits = USART_SERIAL_STOP_BIT
	};

	//Must set TX pin as output
	PORTC.DIRSET=0b00001000;
    2ad0:	e0 e4       	ldi	r30, 0x40	; 64
    2ad2:	f6 e0       	ldi	r31, 0x06	; 6
    2ad4:	88 e0       	ldi	r24, 0x08	; 8
    2ad6:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET=0b00001000;
    2ad8:	85 83       	std	Z+5, r24	; 0x05
	PORTC.OUT=0xFF;
    2ada:	8f ef       	ldi	r24, 0xFF	; 255
    2adc:	84 83       	std	Z+4, r24	; 0x04
 * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
	stdio_base = (void *)usart;
    2ade:	80 ea       	ldi	r24, 0xA0	; 160
    2ae0:	98 e0       	ldi	r25, 0x08	; 8
    2ae2:	80 93 c9 20 	sts	0x20C9, r24	; 0x8020c9 <stdio_base>
    2ae6:	90 93 ca 20 	sts	0x20CA, r25	; 0x8020ca <stdio_base+0x1>
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
    2aea:	8f e5       	ldi	r24, 0x5F	; 95
    2aec:	95 e1       	ldi	r25, 0x15	; 21
    2aee:	80 93 c7 20 	sts	0x20C7, r24	; 0x8020c7 <ptr_put>
    2af2:	90 93 c8 20 	sts	0x20C8, r25	; 0x8020c8 <ptr_put+0x1>
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
    2af6:	87 e5       	ldi	r24, 0x57	; 87
    2af8:	95 e1       	ldi	r25, 0x15	; 21
    2afa:	80 93 c5 20 	sts	0x20C5, r24	; 0x8020c5 <ptr_get>
    2afe:	90 93 c6 20 	sts	0x20C6, r25	; 0x8020c6 <ptr_get+0x1>
static inline bool usart_serial_init(usart_if usart, const
		usart_serial_options_t *options)
{
	// USART options.
	usart_rs232_options_t usart_rs232_options;
	usart_rs232_options.charlength   = options->charlength;
    2b02:	e6 e0       	ldi	r30, 0x06	; 6
    2b04:	f0 e2       	ldi	r31, 0x20	; 32
    2b06:	84 81       	ldd	r24, Z+4	; 0x04
    2b08:	8d 83       	std	Y+5, r24	; 0x05
	usart_rs232_options.paritytype   = options->paritytype;
    2b0a:	85 81       	ldd	r24, Z+5	; 0x05
    2b0c:	8e 83       	std	Y+6, r24	; 0x06
	usart_rs232_options.stopbits     = options->stopbits;
    2b0e:	86 81       	ldd	r24, Z+6	; 0x06
    2b10:	8f 83       	std	Y+7, r24	; 0x07
	usart_rs232_options.baudrate     = options->baudrate;
    2b12:	80 81       	ld	r24, Z
    2b14:	91 81       	ldd	r25, Z+1	; 0x01
    2b16:	a2 81       	ldd	r26, Z+2	; 0x02
    2b18:	b3 81       	ldd	r27, Z+3	; 0x03
    2b1a:	89 83       	std	Y+1, r24	; 0x01
    2b1c:	9a 83       	std	Y+2, r25	; 0x02
    2b1e:	ab 83       	std	Y+3, r26	; 0x03
    2b20:	bc 83       	std	Y+4, r27	; 0x04

#ifdef USARTC0
	if((uint16_t)usart == (uint16_t)&USARTC0) {
		sysclk_enable_module(SYSCLK_PORT_C,PR_USART0_bm);
    2b22:	60 e1       	ldi	r22, 0x10	; 16
    2b24:	83 e0       	ldi	r24, 0x03	; 3
    2b26:	08 d8       	rcall	.-4080   	; 0x1b38 <sysclk_enable_module>
#ifdef USARTF1
	if((uint16_t)usart == (uint16_t)&USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F,PR_USART1_bm);
	}
#endif
	if (usart_init_rs232(usart, &usart_rs232_options)) {
    2b28:	be 01       	movw	r22, r28
    2b2a:	6f 5f       	subi	r22, 0xFF	; 255
    2b2c:	7f 4f       	sbci	r23, 0xFF	; 255
    2b2e:	80 ea       	ldi	r24, 0xA0	; 160
    2b30:	98 e0       	ldi	r25, 0x08	; 8
    2b32:	58 db       	rcall	.-2384   	; 0x21e4 <usart_init_rs232>
# endif

# if defined(__GNUC__)
#  if (XMEGA || MEGA_RF)
	// For AVR GCC libc print redirection uses fdevopen.
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
    2b34:	68 ea       	ldi	r22, 0xA8	; 168
    2b36:	7d e0       	ldi	r23, 0x0D	; 13
    2b38:	81 ec       	ldi	r24, 0xC1	; 193
    2b3a:	9d e0       	ldi	r25, 0x0D	; 13
    2b3c:	0e 94 7f 1f 	call	0x3efe	; 0x3efe <fdevopen>

	stdio_serial_init(&USARTC0, &usart_options); //ASF function that initializes the UART peripheral
}
    2b40:	27 96       	adiw	r28, 0x07	; 7
    2b42:	cd bf       	out	0x3d, r28	; 61
    2b44:	de bf       	out	0x3e, r29	; 62
    2b46:	df 91       	pop	r29
    2b48:	cf 91       	pop	r28
    2b4a:	08 95       	ret

00002b4c <sysclk_enable_peripheral_clock>:
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    2b4c:	00 97       	sbiw	r24, 0x00	; 0
    2b4e:	09 f4       	brne	.+2      	; 0x2b52 <sysclk_enable_peripheral_clock+0x6>
    2b50:	5c c1       	rjmp	.+696    	; 0x2e0a <sysclk_enable_peripheral_clock+0x2be>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    2b52:	80 3c       	cpi	r24, 0xC0	; 192
    2b54:	91 05       	cpc	r25, r1
    2b56:	29 f4       	brne	.+10     	; 0x2b62 <sysclk_enable_peripheral_clock+0x16>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    2b58:	60 e1       	ldi	r22, 0x10	; 16
    2b5a:	80 e0       	ldi	r24, 0x00	; 0
    2b5c:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2b60:	08 95       	ret
	}
#endif
#ifdef EBI
	else if (module == &EBI) {
    2b62:	80 34       	cpi	r24, 0x40	; 64
    2b64:	24 e0       	ldi	r18, 0x04	; 4
    2b66:	92 07       	cpc	r25, r18
    2b68:	29 f4       	brne	.+10     	; 0x2b74 <sysclk_enable_peripheral_clock+0x28>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EBI);
    2b6a:	68 e0       	ldi	r22, 0x08	; 8
    2b6c:	80 e0       	ldi	r24, 0x00	; 0
    2b6e:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2b72:	08 95       	ret
	}
#endif
#ifdef RTC
	else if (module == &RTC) {
    2b74:	81 15       	cp	r24, r1
    2b76:	24 e0       	ldi	r18, 0x04	; 4
    2b78:	92 07       	cpc	r25, r18
    2b7a:	29 f4       	brne	.+10     	; 0x2b86 <sysclk_enable_peripheral_clock+0x3a>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
    2b7c:	64 e0       	ldi	r22, 0x04	; 4
    2b7e:	80 e0       	ldi	r24, 0x00	; 0
    2b80:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2b84:	08 95       	ret
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    2b86:	80 38       	cpi	r24, 0x80	; 128
    2b88:	21 e0       	ldi	r18, 0x01	; 1
    2b8a:	92 07       	cpc	r25, r18
    2b8c:	29 f4       	brne	.+10     	; 0x2b98 <sysclk_enable_peripheral_clock+0x4c>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    2b8e:	62 e0       	ldi	r22, 0x02	; 2
    2b90:	80 e0       	ldi	r24, 0x00	; 0
    2b92:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2b96:	08 95       	ret
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    2b98:	81 15       	cp	r24, r1
    2b9a:	21 e0       	ldi	r18, 0x01	; 1
    2b9c:	92 07       	cpc	r25, r18
    2b9e:	29 f4       	brne	.+10     	; 0x2baa <sysclk_enable_peripheral_clock+0x5e>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    2ba0:	61 e0       	ldi	r22, 0x01	; 1
    2ba2:	80 e0       	ldi	r24, 0x00	; 0
    2ba4:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2ba8:	08 95       	ret
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    2baa:	80 38       	cpi	r24, 0x80	; 128
    2bac:	23 e0       	ldi	r18, 0x03	; 3
    2bae:	92 07       	cpc	r25, r18
    2bb0:	29 f4       	brne	.+10     	; 0x2bbc <sysclk_enable_peripheral_clock+0x70>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    2bb2:	61 e0       	ldi	r22, 0x01	; 1
    2bb4:	81 e0       	ldi	r24, 0x01	; 1
    2bb6:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2bba:	08 95       	ret
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    2bbc:	80 39       	cpi	r24, 0x90	; 144
    2bbe:	23 e0       	ldi	r18, 0x03	; 3
    2bc0:	92 07       	cpc	r25, r18
    2bc2:	29 f4       	brne	.+10     	; 0x2bce <sysclk_enable_peripheral_clock+0x82>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    2bc4:	61 e0       	ldi	r22, 0x01	; 1
    2bc6:	82 e0       	ldi	r24, 0x02	; 2
    2bc8:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2bcc:	08 95       	ret
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    2bce:	81 15       	cp	r24, r1
    2bd0:	22 e0       	ldi	r18, 0x02	; 2
    2bd2:	92 07       	cpc	r25, r18
    2bd4:	29 f4       	brne	.+10     	; 0x2be0 <sysclk_enable_peripheral_clock+0x94>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    2bd6:	62 e0       	ldi	r22, 0x02	; 2
    2bd8:	81 e0       	ldi	r24, 0x01	; 1
    2bda:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2bde:	08 95       	ret
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    2be0:	80 34       	cpi	r24, 0x40	; 64
    2be2:	22 e0       	ldi	r18, 0x02	; 2
    2be4:	92 07       	cpc	r25, r18
    2be6:	29 f4       	brne	.+10     	; 0x2bf2 <sysclk_enable_peripheral_clock+0xa6>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    2be8:	62 e0       	ldi	r22, 0x02	; 2
    2bea:	82 e0       	ldi	r24, 0x02	; 2
    2bec:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2bf0:	08 95       	ret
	}
#endif
#ifdef DACA
	else if (module == &DACA) {
    2bf2:	81 15       	cp	r24, r1
    2bf4:	23 e0       	ldi	r18, 0x03	; 3
    2bf6:	92 07       	cpc	r25, r18
    2bf8:	29 f4       	brne	.+10     	; 0x2c04 <sysclk_enable_peripheral_clock+0xb8>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_DAC);
    2bfa:	64 e0       	ldi	r22, 0x04	; 4
    2bfc:	81 e0       	ldi	r24, 0x01	; 1
    2bfe:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2c02:	08 95       	ret
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    2c04:	80 32       	cpi	r24, 0x20	; 32
    2c06:	23 e0       	ldi	r18, 0x03	; 3
    2c08:	92 07       	cpc	r25, r18
    2c0a:	29 f4       	brne	.+10     	; 0x2c16 <sysclk_enable_peripheral_clock+0xca>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    2c0c:	64 e0       	ldi	r22, 0x04	; 4
    2c0e:	82 e0       	ldi	r24, 0x02	; 2
    2c10:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2c14:	08 95       	ret
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    2c16:	81 15       	cp	r24, r1
    2c18:	28 e0       	ldi	r18, 0x08	; 8
    2c1a:	92 07       	cpc	r25, r18
    2c1c:	29 f4       	brne	.+10     	; 0x2c28 <sysclk_enable_peripheral_clock+0xdc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    2c1e:	61 e0       	ldi	r22, 0x01	; 1
    2c20:	83 e0       	ldi	r24, 0x03	; 3
    2c22:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2c26:	08 95       	ret
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    2c28:	81 15       	cp	r24, r1
    2c2a:	29 e0       	ldi	r18, 0x09	; 9
    2c2c:	92 07       	cpc	r25, r18
    2c2e:	29 f4       	brne	.+10     	; 0x2c3a <sysclk_enable_peripheral_clock+0xee>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    2c30:	61 e0       	ldi	r22, 0x01	; 1
    2c32:	84 e0       	ldi	r24, 0x04	; 4
    2c34:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2c38:	08 95       	ret
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    2c3a:	81 15       	cp	r24, r1
    2c3c:	2a e0       	ldi	r18, 0x0A	; 10
    2c3e:	92 07       	cpc	r25, r18
    2c40:	29 f4       	brne	.+10     	; 0x2c4c <sysclk_enable_peripheral_clock+0x100>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    2c42:	61 e0       	ldi	r22, 0x01	; 1
    2c44:	85 e0       	ldi	r24, 0x05	; 5
    2c46:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2c4a:	08 95       	ret
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    2c4c:	81 15       	cp	r24, r1
    2c4e:	2b e0       	ldi	r18, 0x0B	; 11
    2c50:	92 07       	cpc	r25, r18
    2c52:	29 f4       	brne	.+10     	; 0x2c5e <sysclk_enable_peripheral_clock+0x112>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    2c54:	61 e0       	ldi	r22, 0x01	; 1
    2c56:	86 e0       	ldi	r24, 0x06	; 6
    2c58:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2c5c:	08 95       	ret
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    2c5e:	80 34       	cpi	r24, 0x40	; 64
    2c60:	28 e0       	ldi	r18, 0x08	; 8
    2c62:	92 07       	cpc	r25, r18
    2c64:	29 f4       	brne	.+10     	; 0x2c70 <sysclk_enable_peripheral_clock+0x124>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    2c66:	62 e0       	ldi	r22, 0x02	; 2
    2c68:	83 e0       	ldi	r24, 0x03	; 3
    2c6a:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2c6e:	08 95       	ret
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    2c70:	80 34       	cpi	r24, 0x40	; 64
    2c72:	29 e0       	ldi	r18, 0x09	; 9
    2c74:	92 07       	cpc	r25, r18
    2c76:	29 f4       	brne	.+10     	; 0x2c82 <sysclk_enable_peripheral_clock+0x136>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    2c78:	62 e0       	ldi	r22, 0x02	; 2
    2c7a:	84 e0       	ldi	r24, 0x04	; 4
    2c7c:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2c80:	08 95       	ret
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    2c82:	80 34       	cpi	r24, 0x40	; 64
    2c84:	2a e0       	ldi	r18, 0x0A	; 10
    2c86:	92 07       	cpc	r25, r18
    2c88:	29 f4       	brne	.+10     	; 0x2c94 <sysclk_enable_peripheral_clock+0x148>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    2c8a:	62 e0       	ldi	r22, 0x02	; 2
    2c8c:	85 e0       	ldi	r24, 0x05	; 5
    2c8e:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2c92:	08 95       	ret
	}
#endif
#ifdef TCF1
	else if (module == &TCF1) {
    2c94:	80 34       	cpi	r24, 0x40	; 64
    2c96:	2b e0       	ldi	r18, 0x0B	; 11
    2c98:	92 07       	cpc	r25, r18
    2c9a:	29 f4       	brne	.+10     	; 0x2ca6 <sysclk_enable_peripheral_clock+0x15a>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC1);
    2c9c:	62 e0       	ldi	r22, 0x02	; 2
    2c9e:	86 e0       	ldi	r24, 0x06	; 6
    2ca0:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2ca4:	08 95       	ret
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    2ca6:	80 39       	cpi	r24, 0x90	; 144
    2ca8:	28 e0       	ldi	r18, 0x08	; 8
    2caa:	92 07       	cpc	r25, r18
    2cac:	29 f4       	brne	.+10     	; 0x2cb8 <sysclk_enable_peripheral_clock+0x16c>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    2cae:	64 e0       	ldi	r22, 0x04	; 4
    2cb0:	83 e0       	ldi	r24, 0x03	; 3
    2cb2:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2cb6:	08 95       	ret
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    2cb8:	80 39       	cpi	r24, 0x90	; 144
    2cba:	29 e0       	ldi	r18, 0x09	; 9
    2cbc:	92 07       	cpc	r25, r18
    2cbe:	29 f4       	brne	.+10     	; 0x2cca <sysclk_enable_peripheral_clock+0x17e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    2cc0:	64 e0       	ldi	r22, 0x04	; 4
    2cc2:	84 e0       	ldi	r24, 0x04	; 4
    2cc4:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2cc8:	08 95       	ret
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    2cca:	80 39       	cpi	r24, 0x90	; 144
    2ccc:	2a e0       	ldi	r18, 0x0A	; 10
    2cce:	92 07       	cpc	r25, r18
    2cd0:	29 f4       	brne	.+10     	; 0x2cdc <sysclk_enable_peripheral_clock+0x190>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    2cd2:	64 e0       	ldi	r22, 0x04	; 4
    2cd4:	85 e0       	ldi	r24, 0x05	; 5
    2cd6:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2cda:	08 95       	ret
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    2cdc:	80 39       	cpi	r24, 0x90	; 144
    2cde:	2b e0       	ldi	r18, 0x0B	; 11
    2ce0:	92 07       	cpc	r25, r18
    2ce2:	29 f4       	brne	.+10     	; 0x2cee <sysclk_enable_peripheral_clock+0x1a2>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    2ce4:	64 e0       	ldi	r22, 0x04	; 4
    2ce6:	86 e0       	ldi	r24, 0x06	; 6
    2ce8:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2cec:	08 95       	ret
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    2cee:	80 3c       	cpi	r24, 0xC0	; 192
    2cf0:	28 e0       	ldi	r18, 0x08	; 8
    2cf2:	92 07       	cpc	r25, r18
    2cf4:	29 f4       	brne	.+10     	; 0x2d00 <sysclk_enable_peripheral_clock+0x1b4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    2cf6:	68 e0       	ldi	r22, 0x08	; 8
    2cf8:	83 e0       	ldi	r24, 0x03	; 3
    2cfa:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2cfe:	08 95       	ret
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    2d00:	80 3c       	cpi	r24, 0xC0	; 192
    2d02:	29 e0       	ldi	r18, 0x09	; 9
    2d04:	92 07       	cpc	r25, r18
    2d06:	29 f4       	brne	.+10     	; 0x2d12 <sysclk_enable_peripheral_clock+0x1c6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    2d08:	68 e0       	ldi	r22, 0x08	; 8
    2d0a:	84 e0       	ldi	r24, 0x04	; 4
    2d0c:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2d10:	08 95       	ret
	}
#endif
#ifdef SPIE
	else if (module == &SPIE) {
    2d12:	80 3c       	cpi	r24, 0xC0	; 192
    2d14:	2a e0       	ldi	r18, 0x0A	; 10
    2d16:	92 07       	cpc	r25, r18
    2d18:	29 f4       	brne	.+10     	; 0x2d24 <sysclk_enable_peripheral_clock+0x1d8>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_SPI);
    2d1a:	68 e0       	ldi	r22, 0x08	; 8
    2d1c:	85 e0       	ldi	r24, 0x05	; 5
    2d1e:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2d22:	08 95       	ret
	}
#endif
#ifdef SPIF
	else if (module == &SPIF) {
    2d24:	80 3c       	cpi	r24, 0xC0	; 192
    2d26:	2b e0       	ldi	r18, 0x0B	; 11
    2d28:	92 07       	cpc	r25, r18
    2d2a:	29 f4       	brne	.+10     	; 0x2d36 <sysclk_enable_peripheral_clock+0x1ea>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
    2d2c:	68 e0       	ldi	r22, 0x08	; 8
    2d2e:	86 e0       	ldi	r24, 0x06	; 6
    2d30:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2d34:	08 95       	ret
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    2d36:	80 3a       	cpi	r24, 0xA0	; 160
    2d38:	28 e0       	ldi	r18, 0x08	; 8
    2d3a:	92 07       	cpc	r25, r18
    2d3c:	29 f4       	brne	.+10     	; 0x2d48 <sysclk_enable_peripheral_clock+0x1fc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    2d3e:	60 e1       	ldi	r22, 0x10	; 16
    2d40:	83 e0       	ldi	r24, 0x03	; 3
    2d42:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2d46:	08 95       	ret
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    2d48:	80 3a       	cpi	r24, 0xA0	; 160
    2d4a:	29 e0       	ldi	r18, 0x09	; 9
    2d4c:	92 07       	cpc	r25, r18
    2d4e:	29 f4       	brne	.+10     	; 0x2d5a <sysclk_enable_peripheral_clock+0x20e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    2d50:	60 e1       	ldi	r22, 0x10	; 16
    2d52:	84 e0       	ldi	r24, 0x04	; 4
    2d54:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2d58:	08 95       	ret
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    2d5a:	80 3a       	cpi	r24, 0xA0	; 160
    2d5c:	2a e0       	ldi	r18, 0x0A	; 10
    2d5e:	92 07       	cpc	r25, r18
    2d60:	29 f4       	brne	.+10     	; 0x2d6c <sysclk_enable_peripheral_clock+0x220>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    2d62:	60 e1       	ldi	r22, 0x10	; 16
    2d64:	85 e0       	ldi	r24, 0x05	; 5
    2d66:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2d6a:	08 95       	ret
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    2d6c:	80 3a       	cpi	r24, 0xA0	; 160
    2d6e:	2b e0       	ldi	r18, 0x0B	; 11
    2d70:	92 07       	cpc	r25, r18
    2d72:	29 f4       	brne	.+10     	; 0x2d7e <sysclk_enable_peripheral_clock+0x232>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    2d74:	60 e1       	ldi	r22, 0x10	; 16
    2d76:	86 e0       	ldi	r24, 0x06	; 6
    2d78:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2d7c:	08 95       	ret
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    2d7e:	80 3b       	cpi	r24, 0xB0	; 176
    2d80:	28 e0       	ldi	r18, 0x08	; 8
    2d82:	92 07       	cpc	r25, r18
    2d84:	29 f4       	brne	.+10     	; 0x2d90 <sysclk_enable_peripheral_clock+0x244>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    2d86:	60 e2       	ldi	r22, 0x20	; 32
    2d88:	83 e0       	ldi	r24, 0x03	; 3
    2d8a:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2d8e:	08 95       	ret
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    2d90:	80 3b       	cpi	r24, 0xB0	; 176
    2d92:	29 e0       	ldi	r18, 0x09	; 9
    2d94:	92 07       	cpc	r25, r18
    2d96:	29 f4       	brne	.+10     	; 0x2da2 <sysclk_enable_peripheral_clock+0x256>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    2d98:	60 e2       	ldi	r22, 0x20	; 32
    2d9a:	84 e0       	ldi	r24, 0x04	; 4
    2d9c:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2da0:	08 95       	ret
	}
#endif
#ifdef USARTE1
	else if (module == &USARTE1) {
    2da2:	80 3b       	cpi	r24, 0xB0	; 176
    2da4:	2a e0       	ldi	r18, 0x0A	; 10
    2da6:	92 07       	cpc	r25, r18
    2da8:	29 f4       	brne	.+10     	; 0x2db4 <sysclk_enable_peripheral_clock+0x268>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART1);
    2daa:	60 e2       	ldi	r22, 0x20	; 32
    2dac:	85 e0       	ldi	r24, 0x05	; 5
    2dae:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2db2:	08 95       	ret
	}
#endif
#ifdef USARTF1
	else if (module == &USARTF1) {
    2db4:	80 3b       	cpi	r24, 0xB0	; 176
    2db6:	2b e0       	ldi	r18, 0x0B	; 11
    2db8:	92 07       	cpc	r25, r18
    2dba:	29 f4       	brne	.+10     	; 0x2dc6 <sysclk_enable_peripheral_clock+0x27a>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
    2dbc:	60 e2       	ldi	r22, 0x20	; 32
    2dbe:	86 e0       	ldi	r24, 0x06	; 6
    2dc0:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2dc4:	08 95       	ret
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    2dc6:	80 38       	cpi	r24, 0x80	; 128
    2dc8:	24 e0       	ldi	r18, 0x04	; 4
    2dca:	92 07       	cpc	r25, r18
    2dcc:	29 f4       	brne	.+10     	; 0x2dd8 <sysclk_enable_peripheral_clock+0x28c>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    2dce:	60 e4       	ldi	r22, 0x40	; 64
    2dd0:	83 e0       	ldi	r24, 0x03	; 3
    2dd2:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2dd6:	08 95       	ret
	}
#endif
#ifdef TWID
	else if (module == &TWID) {
    2dd8:	80 39       	cpi	r24, 0x90	; 144
    2dda:	24 e0       	ldi	r18, 0x04	; 4
    2ddc:	92 07       	cpc	r25, r18
    2dde:	29 f4       	brne	.+10     	; 0x2dea <sysclk_enable_peripheral_clock+0x29e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
    2de0:	60 e4       	ldi	r22, 0x40	; 64
    2de2:	84 e0       	ldi	r24, 0x04	; 4
    2de4:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2de8:	08 95       	ret
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    2dea:	80 3a       	cpi	r24, 0xA0	; 160
    2dec:	24 e0       	ldi	r18, 0x04	; 4
    2dee:	92 07       	cpc	r25, r18
    2df0:	29 f4       	brne	.+10     	; 0x2dfc <sysclk_enable_peripheral_clock+0x2b0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    2df2:	60 e4       	ldi	r22, 0x40	; 64
    2df4:	85 e0       	ldi	r24, 0x05	; 5
    2df6:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2dfa:	08 95       	ret
	}
#endif
#ifdef TWIF
	else if (module == &TWIF) {
    2dfc:	80 3b       	cpi	r24, 0xB0	; 176
    2dfe:	94 40       	sbci	r25, 0x04	; 4
    2e00:	21 f4       	brne	.+8      	; 0x2e0a <sysclk_enable_peripheral_clock+0x2be>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TWI);
    2e02:	60 e4       	ldi	r22, 0x40	; 64
    2e04:	86 e0       	ldi	r24, 0x06	; 6
    2e06:	0c 94 9c 0d 	jmp	0x1b38	; 0x1b38 <sysclk_enable_module>
    2e0a:	08 95       	ret

00002e0c <main>:
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int main (void)
{
	/* Initialize the system clock, 32MHz, this also turns off all peripheral clocks */
	sysclk_init();
    2e0c:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <sysclk_init>
	//rtc_init();

	/* Peripheral clock inits */
	sysclk_enable_peripheral_clock(&USARTC0); //For every peripheral, you must enable the clock like shown here. Ex. Timer counters, SPI, ADCs
    2e10:	80 ea       	ldi	r24, 0xA0	; 160
    2e12:	98 e0       	ldi	r25, 0x08	; 8
    2e14:	9b de       	rcall	.-714    	; 0x2b4c <sysclk_enable_peripheral_clock>
	sysclk_enable_peripheral_clock(&ADCA); //Analog to Digital Converter clock initialization.
    2e16:	80 e0       	ldi	r24, 0x00	; 0
    2e18:	92 e0       	ldi	r25, 0x02	; 2
    2e1a:	98 de       	rcall	.-720    	; 0x2b4c <sysclk_enable_peripheral_clock>
	sysclk_enable_peripheral_clock(&TCE0); //Timer Counter clock initialization
    2e1c:	80 e0       	ldi	r24, 0x00	; 0
    2e1e:	9a e0       	ldi	r25, 0x0A	; 10
    2e20:	95 de       	rcall	.-726    	; 0x2b4c <sysclk_enable_peripheral_clock>
	sysclk_enable_peripheral_clock(&TCD0);
    2e22:	80 e0       	ldi	r24, 0x00	; 0
    2e24:	99 e0       	ldi	r25, 0x09	; 9
    2e26:	92 de       	rcall	.-732    	; 0x2b4c <sysclk_enable_peripheral_clock>
	sysclk_enable_peripheral_clock(&TCC0);
    2e28:	80 e0       	ldi	r24, 0x00	; 0
    2e2a:	98 e0       	ldi	r25, 0x08	; 8
    2e2c:	8f de       	rcall	.-738    	; 0x2b4c <sysclk_enable_peripheral_clock>
	sysclk_enable_peripheral_clock(&TCF0);
    2e2e:	80 e0       	ldi	r24, 0x00	; 0
    2e30:	9b e0       	ldi	r25, 0x0B	; 11
    2e32:	8c de       	rcall	.-744    	; 0x2b4c <sysclk_enable_peripheral_clock>
	sysclk_enable_peripheral_clock(&SPIC); //Serial Port Interface initialization.
    2e34:	80 ec       	ldi	r24, 0xC0	; 192
    2e36:	98 e0       	ldi	r25, 0x08	; 8
    2e38:	89 de       	rcall	.-750    	; 0x2b4c <sysclk_enable_peripheral_clock>
	
	/* Example, Timer Counter on PORTE */

	sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES); //You must have this line for every timer counter due to a flaw in the design of the chip **************************
    2e3a:	64 e0       	ldi	r22, 0x04	; 4
    2e3c:	85 e0       	ldi	r24, 0x05	; 5
    2e3e:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    2e42:	64 e0       	ldi	r22, 0x04	; 4
    2e44:	84 e0       	ldi	r24, 0x04	; 4
    2e46:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    2e4a:	64 e0       	ldi	r22, 0x04	; 4
    2e4c:	86 e0       	ldi	r24, 0x06	; 6
    2e4e:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <sysclk_enable_module>
	sysclk_enable_module(SYSCLK_PORT_C,PR_SPI_bm);
    2e52:	68 e0       	ldi	r22, 0x08	; 8
    2e54:	83 e0       	ldi	r24, 0x03	; 3
    2e56:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <sysclk_enable_module>
	
	/* Initializations */

	UART_Comms_Init();
    2e5a:	33 de       	rcall	.-922    	; 0x2ac2 <UART_Comms_Init>
	SPI_init();
    2e5c:	e2 db       	rcall	.-2108   	; 0x2622 <SPI_init>
	//TCE0_init(12499,100);
	TCD0_init();
    2e5e:	11 de       	rcall	.-990    	; 0x2a82 <TCD0_init>
	TCF0_init();
    2e60:	1a de       	rcall	.-972    	; 0x2a96 <TCF0_init>
	ADC_init();
    2e62:	21 db       	rcall	.-2494   	; 0x24a6 <ADC_init>
	EP_address = 0;
    2e64:	10 92 b5 20 	sts	0x20B5, r1	; 0x8020b5 <EP_address>
	alt = 0;
    2e68:	10 92 b4 20 	sts	0x20B4, r1	; 0x8020b4 <alt>
	t = 0;
    2e6c:	10 92 b0 20 	sts	0x20B0, r1	; 0x8020b0 <t>
    2e70:	10 92 b1 20 	sts	0x20B1, r1	; 0x8020b1 <t+0x1>
    2e74:	10 92 b2 20 	sts	0x20B2, r1	; 0x8020b2 <t+0x2>
    2e78:	10 92 b3 20 	sts	0x20B3, r1	; 0x8020b3 <t+0x3>

	PORTD.DIR = 0b11111111;
    2e7c:	8f ef       	ldi	r24, 0xFF	; 255
    2e7e:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <__TEXT_REGION_LENGTH__+0x700660>
	PORTE.DIR = 0b11111111;
    2e82:	e0 e8       	ldi	r30, 0x80	; 128
    2e84:	f6 e0       	ldi	r31, 0x06	; 6
    2e86:	80 83       	st	Z, r24
	PORTF.DIR = 0b00000011;
    2e88:	83 e0       	ldi	r24, 0x03	; 3
    2e8a:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	
	PORTE.OUT = 0b00000000;
    2e8e:	14 82       	std	Z+4, r1	; 0x04
	//flightStateZero();
	//flightStateOne();
	//flightStateTwo();
	// flightStateThree();

	LED(12499,100);
    2e90:	64 e6       	ldi	r22, 0x64	; 100
    2e92:	83 ed       	ldi	r24, 0xD3	; 211
    2e94:	90 e3       	ldi	r25, 0x30	; 48
    2e96:	0e 94 a6 0c 	call	0x194c	; 0x194c <LED>
		//printf("%.2f\n",t);
		//delay_ms(10);


		//while ((TCF0.INTFLAGS<<7)!=0b10000000); //wait until TCF0 overflows
		test();
    2e9a:	0e 94 3a 0d 	call	0x1a74	; 0x1a74 <test>
		lightChase(50);

			if(EP_address >= 2047)
				EP_address = 0;
				*/
	}
    2e9e:	fd cf       	rjmp	.-6      	; 0x2e9a <main+0x8e>

00002ea0 <__subsf3>:
    2ea0:	50 58       	subi	r21, 0x80	; 128

00002ea2 <__addsf3>:
    2ea2:	bb 27       	eor	r27, r27
    2ea4:	aa 27       	eor	r26, r26
    2ea6:	0e d0       	rcall	.+28     	; 0x2ec4 <__addsf3x>
    2ea8:	a4 c1       	rjmp	.+840    	; 0x31f2 <__fp_round>
    2eaa:	95 d1       	rcall	.+810    	; 0x31d6 <__fp_pscA>
    2eac:	30 f0       	brcs	.+12     	; 0x2eba <__addsf3+0x18>
    2eae:	9a d1       	rcall	.+820    	; 0x31e4 <__fp_pscB>
    2eb0:	20 f0       	brcs	.+8      	; 0x2eba <__addsf3+0x18>
    2eb2:	31 f4       	brne	.+12     	; 0x2ec0 <__addsf3+0x1e>
    2eb4:	9f 3f       	cpi	r25, 0xFF	; 255
    2eb6:	11 f4       	brne	.+4      	; 0x2ebc <__addsf3+0x1a>
    2eb8:	1e f4       	brtc	.+6      	; 0x2ec0 <__addsf3+0x1e>
    2eba:	7a c1       	rjmp	.+756    	; 0x31b0 <__fp_nan>
    2ebc:	0e f4       	brtc	.+2      	; 0x2ec0 <__addsf3+0x1e>
    2ebe:	e0 95       	com	r30
    2ec0:	e7 fb       	bst	r30, 7
    2ec2:	70 c1       	rjmp	.+736    	; 0x31a4 <__fp_inf>

00002ec4 <__addsf3x>:
    2ec4:	e9 2f       	mov	r30, r25
    2ec6:	a6 d1       	rcall	.+844    	; 0x3214 <__fp_split3>
    2ec8:	80 f3       	brcs	.-32     	; 0x2eaa <__addsf3+0x8>
    2eca:	ba 17       	cp	r27, r26
    2ecc:	62 07       	cpc	r22, r18
    2ece:	73 07       	cpc	r23, r19
    2ed0:	84 07       	cpc	r24, r20
    2ed2:	95 07       	cpc	r25, r21
    2ed4:	18 f0       	brcs	.+6      	; 0x2edc <__addsf3x+0x18>
    2ed6:	71 f4       	brne	.+28     	; 0x2ef4 <__addsf3x+0x30>
    2ed8:	9e f5       	brtc	.+102    	; 0x2f40 <__addsf3x+0x7c>
    2eda:	be c1       	rjmp	.+892    	; 0x3258 <__fp_zero>
    2edc:	0e f4       	brtc	.+2      	; 0x2ee0 <__addsf3x+0x1c>
    2ede:	e0 95       	com	r30
    2ee0:	0b 2e       	mov	r0, r27
    2ee2:	ba 2f       	mov	r27, r26
    2ee4:	a0 2d       	mov	r26, r0
    2ee6:	0b 01       	movw	r0, r22
    2ee8:	b9 01       	movw	r22, r18
    2eea:	90 01       	movw	r18, r0
    2eec:	0c 01       	movw	r0, r24
    2eee:	ca 01       	movw	r24, r20
    2ef0:	a0 01       	movw	r20, r0
    2ef2:	11 24       	eor	r1, r1
    2ef4:	ff 27       	eor	r31, r31
    2ef6:	59 1b       	sub	r21, r25
    2ef8:	99 f0       	breq	.+38     	; 0x2f20 <__addsf3x+0x5c>
    2efa:	59 3f       	cpi	r21, 0xF9	; 249
    2efc:	50 f4       	brcc	.+20     	; 0x2f12 <__addsf3x+0x4e>
    2efe:	50 3e       	cpi	r21, 0xE0	; 224
    2f00:	68 f1       	brcs	.+90     	; 0x2f5c <__addsf3x+0x98>
    2f02:	1a 16       	cp	r1, r26
    2f04:	f0 40       	sbci	r31, 0x00	; 0
    2f06:	a2 2f       	mov	r26, r18
    2f08:	23 2f       	mov	r18, r19
    2f0a:	34 2f       	mov	r19, r20
    2f0c:	44 27       	eor	r20, r20
    2f0e:	58 5f       	subi	r21, 0xF8	; 248
    2f10:	f3 cf       	rjmp	.-26     	; 0x2ef8 <__addsf3x+0x34>
    2f12:	46 95       	lsr	r20
    2f14:	37 95       	ror	r19
    2f16:	27 95       	ror	r18
    2f18:	a7 95       	ror	r26
    2f1a:	f0 40       	sbci	r31, 0x00	; 0
    2f1c:	53 95       	inc	r21
    2f1e:	c9 f7       	brne	.-14     	; 0x2f12 <__addsf3x+0x4e>
    2f20:	7e f4       	brtc	.+30     	; 0x2f40 <__addsf3x+0x7c>
    2f22:	1f 16       	cp	r1, r31
    2f24:	ba 0b       	sbc	r27, r26
    2f26:	62 0b       	sbc	r22, r18
    2f28:	73 0b       	sbc	r23, r19
    2f2a:	84 0b       	sbc	r24, r20
    2f2c:	ba f0       	brmi	.+46     	; 0x2f5c <__addsf3x+0x98>
    2f2e:	91 50       	subi	r25, 0x01	; 1
    2f30:	a1 f0       	breq	.+40     	; 0x2f5a <__addsf3x+0x96>
    2f32:	ff 0f       	add	r31, r31
    2f34:	bb 1f       	adc	r27, r27
    2f36:	66 1f       	adc	r22, r22
    2f38:	77 1f       	adc	r23, r23
    2f3a:	88 1f       	adc	r24, r24
    2f3c:	c2 f7       	brpl	.-16     	; 0x2f2e <__addsf3x+0x6a>
    2f3e:	0e c0       	rjmp	.+28     	; 0x2f5c <__addsf3x+0x98>
    2f40:	ba 0f       	add	r27, r26
    2f42:	62 1f       	adc	r22, r18
    2f44:	73 1f       	adc	r23, r19
    2f46:	84 1f       	adc	r24, r20
    2f48:	48 f4       	brcc	.+18     	; 0x2f5c <__addsf3x+0x98>
    2f4a:	87 95       	ror	r24
    2f4c:	77 95       	ror	r23
    2f4e:	67 95       	ror	r22
    2f50:	b7 95       	ror	r27
    2f52:	f7 95       	ror	r31
    2f54:	9e 3f       	cpi	r25, 0xFE	; 254
    2f56:	08 f0       	brcs	.+2      	; 0x2f5a <__addsf3x+0x96>
    2f58:	b3 cf       	rjmp	.-154    	; 0x2ec0 <__addsf3+0x1e>
    2f5a:	93 95       	inc	r25
    2f5c:	88 0f       	add	r24, r24
    2f5e:	08 f0       	brcs	.+2      	; 0x2f62 <__addsf3x+0x9e>
    2f60:	99 27       	eor	r25, r25
    2f62:	ee 0f       	add	r30, r30
    2f64:	97 95       	ror	r25
    2f66:	87 95       	ror	r24
    2f68:	08 95       	ret

00002f6a <__divsf3>:
    2f6a:	0c d0       	rcall	.+24     	; 0x2f84 <__divsf3x>
    2f6c:	42 c1       	rjmp	.+644    	; 0x31f2 <__fp_round>
    2f6e:	3a d1       	rcall	.+628    	; 0x31e4 <__fp_pscB>
    2f70:	40 f0       	brcs	.+16     	; 0x2f82 <__divsf3+0x18>
    2f72:	31 d1       	rcall	.+610    	; 0x31d6 <__fp_pscA>
    2f74:	30 f0       	brcs	.+12     	; 0x2f82 <__divsf3+0x18>
    2f76:	21 f4       	brne	.+8      	; 0x2f80 <__divsf3+0x16>
    2f78:	5f 3f       	cpi	r21, 0xFF	; 255
    2f7a:	19 f0       	breq	.+6      	; 0x2f82 <__divsf3+0x18>
    2f7c:	13 c1       	rjmp	.+550    	; 0x31a4 <__fp_inf>
    2f7e:	51 11       	cpse	r21, r1
    2f80:	6c c1       	rjmp	.+728    	; 0x325a <__fp_szero>
    2f82:	16 c1       	rjmp	.+556    	; 0x31b0 <__fp_nan>

00002f84 <__divsf3x>:
    2f84:	47 d1       	rcall	.+654    	; 0x3214 <__fp_split3>
    2f86:	98 f3       	brcs	.-26     	; 0x2f6e <__divsf3+0x4>

00002f88 <__divsf3_pse>:
    2f88:	99 23       	and	r25, r25
    2f8a:	c9 f3       	breq	.-14     	; 0x2f7e <__divsf3+0x14>
    2f8c:	55 23       	and	r21, r21
    2f8e:	b1 f3       	breq	.-20     	; 0x2f7c <__divsf3+0x12>
    2f90:	95 1b       	sub	r25, r21
    2f92:	55 0b       	sbc	r21, r21
    2f94:	bb 27       	eor	r27, r27
    2f96:	aa 27       	eor	r26, r26
    2f98:	62 17       	cp	r22, r18
    2f9a:	73 07       	cpc	r23, r19
    2f9c:	84 07       	cpc	r24, r20
    2f9e:	38 f0       	brcs	.+14     	; 0x2fae <__divsf3_pse+0x26>
    2fa0:	9f 5f       	subi	r25, 0xFF	; 255
    2fa2:	5f 4f       	sbci	r21, 0xFF	; 255
    2fa4:	22 0f       	add	r18, r18
    2fa6:	33 1f       	adc	r19, r19
    2fa8:	44 1f       	adc	r20, r20
    2faa:	aa 1f       	adc	r26, r26
    2fac:	a9 f3       	breq	.-22     	; 0x2f98 <__divsf3_pse+0x10>
    2fae:	33 d0       	rcall	.+102    	; 0x3016 <__divsf3_pse+0x8e>
    2fb0:	0e 2e       	mov	r0, r30
    2fb2:	3a f0       	brmi	.+14     	; 0x2fc2 <__divsf3_pse+0x3a>
    2fb4:	e0 e8       	ldi	r30, 0x80	; 128
    2fb6:	30 d0       	rcall	.+96     	; 0x3018 <__divsf3_pse+0x90>
    2fb8:	91 50       	subi	r25, 0x01	; 1
    2fba:	50 40       	sbci	r21, 0x00	; 0
    2fbc:	e6 95       	lsr	r30
    2fbe:	00 1c       	adc	r0, r0
    2fc0:	ca f7       	brpl	.-14     	; 0x2fb4 <__divsf3_pse+0x2c>
    2fc2:	29 d0       	rcall	.+82     	; 0x3016 <__divsf3_pse+0x8e>
    2fc4:	fe 2f       	mov	r31, r30
    2fc6:	27 d0       	rcall	.+78     	; 0x3016 <__divsf3_pse+0x8e>
    2fc8:	66 0f       	add	r22, r22
    2fca:	77 1f       	adc	r23, r23
    2fcc:	88 1f       	adc	r24, r24
    2fce:	bb 1f       	adc	r27, r27
    2fd0:	26 17       	cp	r18, r22
    2fd2:	37 07       	cpc	r19, r23
    2fd4:	48 07       	cpc	r20, r24
    2fd6:	ab 07       	cpc	r26, r27
    2fd8:	b0 e8       	ldi	r27, 0x80	; 128
    2fda:	09 f0       	breq	.+2      	; 0x2fde <__divsf3_pse+0x56>
    2fdc:	bb 0b       	sbc	r27, r27
    2fde:	80 2d       	mov	r24, r0
    2fe0:	bf 01       	movw	r22, r30
    2fe2:	ff 27       	eor	r31, r31
    2fe4:	93 58       	subi	r25, 0x83	; 131
    2fe6:	5f 4f       	sbci	r21, 0xFF	; 255
    2fe8:	2a f0       	brmi	.+10     	; 0x2ff4 <__divsf3_pse+0x6c>
    2fea:	9e 3f       	cpi	r25, 0xFE	; 254
    2fec:	51 05       	cpc	r21, r1
    2fee:	68 f0       	brcs	.+26     	; 0x300a <__divsf3_pse+0x82>
    2ff0:	d9 c0       	rjmp	.+434    	; 0x31a4 <__fp_inf>
    2ff2:	33 c1       	rjmp	.+614    	; 0x325a <__fp_szero>
    2ff4:	5f 3f       	cpi	r21, 0xFF	; 255
    2ff6:	ec f3       	brlt	.-6      	; 0x2ff2 <__divsf3_pse+0x6a>
    2ff8:	98 3e       	cpi	r25, 0xE8	; 232
    2ffa:	dc f3       	brlt	.-10     	; 0x2ff2 <__divsf3_pse+0x6a>
    2ffc:	86 95       	lsr	r24
    2ffe:	77 95       	ror	r23
    3000:	67 95       	ror	r22
    3002:	b7 95       	ror	r27
    3004:	f7 95       	ror	r31
    3006:	9f 5f       	subi	r25, 0xFF	; 255
    3008:	c9 f7       	brne	.-14     	; 0x2ffc <__divsf3_pse+0x74>
    300a:	88 0f       	add	r24, r24
    300c:	91 1d       	adc	r25, r1
    300e:	96 95       	lsr	r25
    3010:	87 95       	ror	r24
    3012:	97 f9       	bld	r25, 7
    3014:	08 95       	ret
    3016:	e1 e0       	ldi	r30, 0x01	; 1
    3018:	66 0f       	add	r22, r22
    301a:	77 1f       	adc	r23, r23
    301c:	88 1f       	adc	r24, r24
    301e:	bb 1f       	adc	r27, r27
    3020:	62 17       	cp	r22, r18
    3022:	73 07       	cpc	r23, r19
    3024:	84 07       	cpc	r24, r20
    3026:	ba 07       	cpc	r27, r26
    3028:	20 f0       	brcs	.+8      	; 0x3032 <__divsf3_pse+0xaa>
    302a:	62 1b       	sub	r22, r18
    302c:	73 0b       	sbc	r23, r19
    302e:	84 0b       	sbc	r24, r20
    3030:	ba 0b       	sbc	r27, r26
    3032:	ee 1f       	adc	r30, r30
    3034:	88 f7       	brcc	.-30     	; 0x3018 <__divsf3_pse+0x90>
    3036:	e0 95       	com	r30
    3038:	08 95       	ret

0000303a <__fixsfdi>:
    303a:	be e3       	ldi	r27, 0x3E	; 62
    303c:	04 d0       	rcall	.+8      	; 0x3046 <__fixunssfdi+0x2>
    303e:	08 f4       	brcc	.+2      	; 0x3042 <__fixsfdi+0x8>
    3040:	90 e8       	ldi	r25, 0x80	; 128
    3042:	08 95       	ret

00003044 <__fixunssfdi>:
    3044:	bf e3       	ldi	r27, 0x3F	; 63
    3046:	22 27       	eor	r18, r18
    3048:	33 27       	eor	r19, r19
    304a:	a9 01       	movw	r20, r18
    304c:	eb d0       	rcall	.+470    	; 0x3224 <__fp_splitA>
    304e:	58 f1       	brcs	.+86     	; 0x30a6 <__fixunssfdi+0x62>
    3050:	9f 57       	subi	r25, 0x7F	; 127
    3052:	40 f1       	brcs	.+80     	; 0x30a4 <__fixunssfdi+0x60>
    3054:	b9 17       	cp	r27, r25
    3056:	38 f1       	brcs	.+78     	; 0x30a6 <__fixunssfdi+0x62>
    3058:	bf e3       	ldi	r27, 0x3F	; 63
    305a:	b9 1b       	sub	r27, r25
    305c:	99 27       	eor	r25, r25
    305e:	b8 50       	subi	r27, 0x08	; 8
    3060:	3a f4       	brpl	.+14     	; 0x3070 <__fixunssfdi+0x2c>
    3062:	66 0f       	add	r22, r22
    3064:	77 1f       	adc	r23, r23
    3066:	88 1f       	adc	r24, r24
    3068:	99 1f       	adc	r25, r25
    306a:	b3 95       	inc	r27
    306c:	d2 f3       	brmi	.-12     	; 0x3062 <__fixunssfdi+0x1e>
    306e:	16 c0       	rjmp	.+44     	; 0x309c <__fixunssfdi+0x58>
    3070:	b8 50       	subi	r27, 0x08	; 8
    3072:	4a f0       	brmi	.+18     	; 0x3086 <__fixunssfdi+0x42>
    3074:	23 2f       	mov	r18, r19
    3076:	34 2f       	mov	r19, r20
    3078:	45 2f       	mov	r20, r21
    307a:	56 2f       	mov	r21, r22
    307c:	67 2f       	mov	r22, r23
    307e:	78 2f       	mov	r23, r24
    3080:	88 27       	eor	r24, r24
    3082:	b8 50       	subi	r27, 0x08	; 8
    3084:	ba f7       	brpl	.-18     	; 0x3074 <__fixunssfdi+0x30>
    3086:	b8 5f       	subi	r27, 0xF8	; 248
    3088:	49 f0       	breq	.+18     	; 0x309c <__fixunssfdi+0x58>
    308a:	86 95       	lsr	r24
    308c:	77 95       	ror	r23
    308e:	67 95       	ror	r22
    3090:	57 95       	ror	r21
    3092:	47 95       	ror	r20
    3094:	37 95       	ror	r19
    3096:	27 95       	ror	r18
    3098:	ba 95       	dec	r27
    309a:	b9 f7       	brne	.-18     	; 0x308a <__fixunssfdi+0x46>
    309c:	0e f4       	brtc	.+2      	; 0x30a0 <__fixunssfdi+0x5c>
    309e:	8b d0       	rcall	.+278    	; 0x31b6 <__fp_negdi>
    30a0:	88 94       	clc
    30a2:	08 95       	ret
    30a4:	88 94       	clc
    30a6:	60 e0       	ldi	r22, 0x00	; 0
    30a8:	70 e0       	ldi	r23, 0x00	; 0
    30aa:	cb 01       	movw	r24, r22
    30ac:	08 95       	ret

000030ae <__floatunsisf>:
    30ae:	e8 94       	clt
    30b0:	09 c0       	rjmp	.+18     	; 0x30c4 <__floatsisf+0x12>

000030b2 <__floatsisf>:
    30b2:	97 fb       	bst	r25, 7
    30b4:	3e f4       	brtc	.+14     	; 0x30c4 <__floatsisf+0x12>
    30b6:	90 95       	com	r25
    30b8:	80 95       	com	r24
    30ba:	70 95       	com	r23
    30bc:	61 95       	neg	r22
    30be:	7f 4f       	sbci	r23, 0xFF	; 255
    30c0:	8f 4f       	sbci	r24, 0xFF	; 255
    30c2:	9f 4f       	sbci	r25, 0xFF	; 255
    30c4:	99 23       	and	r25, r25
    30c6:	a9 f0       	breq	.+42     	; 0x30f2 <__floatsisf+0x40>
    30c8:	f9 2f       	mov	r31, r25
    30ca:	96 e9       	ldi	r25, 0x96	; 150
    30cc:	bb 27       	eor	r27, r27
    30ce:	93 95       	inc	r25
    30d0:	f6 95       	lsr	r31
    30d2:	87 95       	ror	r24
    30d4:	77 95       	ror	r23
    30d6:	67 95       	ror	r22
    30d8:	b7 95       	ror	r27
    30da:	f1 11       	cpse	r31, r1
    30dc:	f8 cf       	rjmp	.-16     	; 0x30ce <__floatsisf+0x1c>
    30de:	fa f4       	brpl	.+62     	; 0x311e <__floatsisf+0x6c>
    30e0:	bb 0f       	add	r27, r27
    30e2:	11 f4       	brne	.+4      	; 0x30e8 <__floatsisf+0x36>
    30e4:	60 ff       	sbrs	r22, 0
    30e6:	1b c0       	rjmp	.+54     	; 0x311e <__floatsisf+0x6c>
    30e8:	6f 5f       	subi	r22, 0xFF	; 255
    30ea:	7f 4f       	sbci	r23, 0xFF	; 255
    30ec:	8f 4f       	sbci	r24, 0xFF	; 255
    30ee:	9f 4f       	sbci	r25, 0xFF	; 255
    30f0:	16 c0       	rjmp	.+44     	; 0x311e <__floatsisf+0x6c>
    30f2:	88 23       	and	r24, r24
    30f4:	11 f0       	breq	.+4      	; 0x30fa <__floatsisf+0x48>
    30f6:	96 e9       	ldi	r25, 0x96	; 150
    30f8:	11 c0       	rjmp	.+34     	; 0x311c <__floatsisf+0x6a>
    30fa:	77 23       	and	r23, r23
    30fc:	21 f0       	breq	.+8      	; 0x3106 <__floatsisf+0x54>
    30fe:	9e e8       	ldi	r25, 0x8E	; 142
    3100:	87 2f       	mov	r24, r23
    3102:	76 2f       	mov	r23, r22
    3104:	05 c0       	rjmp	.+10     	; 0x3110 <__floatsisf+0x5e>
    3106:	66 23       	and	r22, r22
    3108:	71 f0       	breq	.+28     	; 0x3126 <__floatsisf+0x74>
    310a:	96 e8       	ldi	r25, 0x86	; 134
    310c:	86 2f       	mov	r24, r22
    310e:	70 e0       	ldi	r23, 0x00	; 0
    3110:	60 e0       	ldi	r22, 0x00	; 0
    3112:	2a f0       	brmi	.+10     	; 0x311e <__floatsisf+0x6c>
    3114:	9a 95       	dec	r25
    3116:	66 0f       	add	r22, r22
    3118:	77 1f       	adc	r23, r23
    311a:	88 1f       	adc	r24, r24
    311c:	da f7       	brpl	.-10     	; 0x3114 <__floatsisf+0x62>
    311e:	88 0f       	add	r24, r24
    3120:	96 95       	lsr	r25
    3122:	87 95       	ror	r24
    3124:	97 f9       	bld	r25, 7
    3126:	08 95       	ret

00003128 <__floatundisf>:
    3128:	e8 94       	clt

0000312a <__fp_di2sf>:
    312a:	f9 2f       	mov	r31, r25
    312c:	96 eb       	ldi	r25, 0xB6	; 182
    312e:	ff 23       	and	r31, r31
    3130:	81 f0       	breq	.+32     	; 0x3152 <__fp_di2sf+0x28>
    3132:	12 16       	cp	r1, r18
    3134:	13 06       	cpc	r1, r19
    3136:	14 06       	cpc	r1, r20
    3138:	44 0b       	sbc	r20, r20
    313a:	93 95       	inc	r25
    313c:	f6 95       	lsr	r31
    313e:	87 95       	ror	r24
    3140:	77 95       	ror	r23
    3142:	67 95       	ror	r22
    3144:	57 95       	ror	r21
    3146:	40 40       	sbci	r20, 0x00	; 0
    3148:	ff 23       	and	r31, r31
    314a:	b9 f7       	brne	.-18     	; 0x313a <__fp_di2sf+0x10>
    314c:	1b c0       	rjmp	.+54     	; 0x3184 <__fp_di2sf+0x5a>
    314e:	99 27       	eor	r25, r25
    3150:	08 95       	ret
    3152:	88 23       	and	r24, r24
    3154:	51 f4       	brne	.+20     	; 0x316a <__fp_di2sf+0x40>
    3156:	98 50       	subi	r25, 0x08	; 8
    3158:	d2 f7       	brpl	.-12     	; 0x314e <__fp_di2sf+0x24>
    315a:	87 2b       	or	r24, r23
    315c:	76 2f       	mov	r23, r22
    315e:	65 2f       	mov	r22, r21
    3160:	54 2f       	mov	r21, r20
    3162:	43 2f       	mov	r20, r19
    3164:	32 2f       	mov	r19, r18
    3166:	20 e0       	ldi	r18, 0x00	; 0
    3168:	b1 f3       	breq	.-20     	; 0x3156 <__fp_di2sf+0x2c>
    316a:	12 16       	cp	r1, r18
    316c:	13 06       	cpc	r1, r19
    316e:	14 06       	cpc	r1, r20
    3170:	44 0b       	sbc	r20, r20
    3172:	88 23       	and	r24, r24
    3174:	3a f0       	brmi	.+14     	; 0x3184 <__fp_di2sf+0x5a>
    3176:	9a 95       	dec	r25
    3178:	44 0f       	add	r20, r20
    317a:	55 1f       	adc	r21, r21
    317c:	66 1f       	adc	r22, r22
    317e:	77 1f       	adc	r23, r23
    3180:	88 1f       	adc	r24, r24
    3182:	ca f7       	brpl	.-14     	; 0x3176 <__fp_di2sf+0x4c>
    3184:	55 23       	and	r21, r21
    3186:	4a f4       	brpl	.+18     	; 0x319a <__fp_di2sf+0x70>
    3188:	44 0f       	add	r20, r20
    318a:	55 1f       	adc	r21, r21
    318c:	11 f4       	brne	.+4      	; 0x3192 <__fp_di2sf+0x68>
    318e:	60 ff       	sbrs	r22, 0
    3190:	04 c0       	rjmp	.+8      	; 0x319a <__fp_di2sf+0x70>
    3192:	6f 5f       	subi	r22, 0xFF	; 255
    3194:	7f 4f       	sbci	r23, 0xFF	; 255
    3196:	8f 4f       	sbci	r24, 0xFF	; 255
    3198:	9f 4f       	sbci	r25, 0xFF	; 255
    319a:	88 0f       	add	r24, r24
    319c:	96 95       	lsr	r25
    319e:	87 95       	ror	r24
    31a0:	97 f9       	bld	r25, 7
    31a2:	08 95       	ret

000031a4 <__fp_inf>:
    31a4:	97 f9       	bld	r25, 7
    31a6:	9f 67       	ori	r25, 0x7F	; 127
    31a8:	80 e8       	ldi	r24, 0x80	; 128
    31aa:	70 e0       	ldi	r23, 0x00	; 0
    31ac:	60 e0       	ldi	r22, 0x00	; 0
    31ae:	08 95       	ret

000031b0 <__fp_nan>:
    31b0:	9f ef       	ldi	r25, 0xFF	; 255
    31b2:	80 ec       	ldi	r24, 0xC0	; 192
    31b4:	08 95       	ret

000031b6 <__fp_negdi>:
    31b6:	90 95       	com	r25
    31b8:	80 95       	com	r24
    31ba:	70 95       	com	r23
    31bc:	60 95       	com	r22
    31be:	50 95       	com	r21
    31c0:	40 95       	com	r20
    31c2:	30 95       	com	r19
    31c4:	21 95       	neg	r18
    31c6:	3f 4f       	sbci	r19, 0xFF	; 255
    31c8:	4f 4f       	sbci	r20, 0xFF	; 255
    31ca:	5f 4f       	sbci	r21, 0xFF	; 255
    31cc:	6f 4f       	sbci	r22, 0xFF	; 255
    31ce:	7f 4f       	sbci	r23, 0xFF	; 255
    31d0:	8f 4f       	sbci	r24, 0xFF	; 255
    31d2:	9f 4f       	sbci	r25, 0xFF	; 255
    31d4:	08 95       	ret

000031d6 <__fp_pscA>:
    31d6:	00 24       	eor	r0, r0
    31d8:	0a 94       	dec	r0
    31da:	16 16       	cp	r1, r22
    31dc:	17 06       	cpc	r1, r23
    31de:	18 06       	cpc	r1, r24
    31e0:	09 06       	cpc	r0, r25
    31e2:	08 95       	ret

000031e4 <__fp_pscB>:
    31e4:	00 24       	eor	r0, r0
    31e6:	0a 94       	dec	r0
    31e8:	12 16       	cp	r1, r18
    31ea:	13 06       	cpc	r1, r19
    31ec:	14 06       	cpc	r1, r20
    31ee:	05 06       	cpc	r0, r21
    31f0:	08 95       	ret

000031f2 <__fp_round>:
    31f2:	09 2e       	mov	r0, r25
    31f4:	03 94       	inc	r0
    31f6:	00 0c       	add	r0, r0
    31f8:	11 f4       	brne	.+4      	; 0x31fe <__fp_round+0xc>
    31fa:	88 23       	and	r24, r24
    31fc:	52 f0       	brmi	.+20     	; 0x3212 <__fp_round+0x20>
    31fe:	bb 0f       	add	r27, r27
    3200:	40 f4       	brcc	.+16     	; 0x3212 <__fp_round+0x20>
    3202:	bf 2b       	or	r27, r31
    3204:	11 f4       	brne	.+4      	; 0x320a <__fp_round+0x18>
    3206:	60 ff       	sbrs	r22, 0
    3208:	04 c0       	rjmp	.+8      	; 0x3212 <__fp_round+0x20>
    320a:	6f 5f       	subi	r22, 0xFF	; 255
    320c:	7f 4f       	sbci	r23, 0xFF	; 255
    320e:	8f 4f       	sbci	r24, 0xFF	; 255
    3210:	9f 4f       	sbci	r25, 0xFF	; 255
    3212:	08 95       	ret

00003214 <__fp_split3>:
    3214:	57 fd       	sbrc	r21, 7
    3216:	90 58       	subi	r25, 0x80	; 128
    3218:	44 0f       	add	r20, r20
    321a:	55 1f       	adc	r21, r21
    321c:	59 f0       	breq	.+22     	; 0x3234 <__fp_splitA+0x10>
    321e:	5f 3f       	cpi	r21, 0xFF	; 255
    3220:	71 f0       	breq	.+28     	; 0x323e <__fp_splitA+0x1a>
    3222:	47 95       	ror	r20

00003224 <__fp_splitA>:
    3224:	88 0f       	add	r24, r24
    3226:	97 fb       	bst	r25, 7
    3228:	99 1f       	adc	r25, r25
    322a:	61 f0       	breq	.+24     	; 0x3244 <__fp_splitA+0x20>
    322c:	9f 3f       	cpi	r25, 0xFF	; 255
    322e:	79 f0       	breq	.+30     	; 0x324e <__fp_splitA+0x2a>
    3230:	87 95       	ror	r24
    3232:	08 95       	ret
    3234:	12 16       	cp	r1, r18
    3236:	13 06       	cpc	r1, r19
    3238:	14 06       	cpc	r1, r20
    323a:	55 1f       	adc	r21, r21
    323c:	f2 cf       	rjmp	.-28     	; 0x3222 <__fp_split3+0xe>
    323e:	46 95       	lsr	r20
    3240:	f1 df       	rcall	.-30     	; 0x3224 <__fp_splitA>
    3242:	08 c0       	rjmp	.+16     	; 0x3254 <__fp_splitA+0x30>
    3244:	16 16       	cp	r1, r22
    3246:	17 06       	cpc	r1, r23
    3248:	18 06       	cpc	r1, r24
    324a:	99 1f       	adc	r25, r25
    324c:	f1 cf       	rjmp	.-30     	; 0x3230 <__fp_splitA+0xc>
    324e:	86 95       	lsr	r24
    3250:	71 05       	cpc	r23, r1
    3252:	61 05       	cpc	r22, r1
    3254:	08 94       	sec
    3256:	08 95       	ret

00003258 <__fp_zero>:
    3258:	e8 94       	clt

0000325a <__fp_szero>:
    325a:	bb 27       	eor	r27, r27
    325c:	66 27       	eor	r22, r22
    325e:	77 27       	eor	r23, r23
    3260:	cb 01       	movw	r24, r22
    3262:	97 f9       	bld	r25, 7
    3264:	08 95       	ret
    3266:	0e f0       	brts	.+2      	; 0x326a <__fp_szero+0x10>
    3268:	a6 c0       	rjmp	.+332    	; 0x33b6 <__fp_mpack>
    326a:	a2 cf       	rjmp	.-188    	; 0x31b0 <__fp_nan>
    326c:	68 94       	set
    326e:	9a cf       	rjmp	.-204    	; 0x31a4 <__fp_inf>

00003270 <log>:
    3270:	d9 df       	rcall	.-78     	; 0x3224 <__fp_splitA>
    3272:	c8 f3       	brcs	.-14     	; 0x3266 <__fp_szero+0xc>
    3274:	99 23       	and	r25, r25
    3276:	d1 f3       	breq	.-12     	; 0x326c <__fp_szero+0x12>
    3278:	c6 f3       	brts	.-16     	; 0x326a <__fp_szero+0x10>
    327a:	df 93       	push	r29
    327c:	cf 93       	push	r28
    327e:	1f 93       	push	r17
    3280:	0f 93       	push	r16
    3282:	ff 92       	push	r15
    3284:	c9 2f       	mov	r28, r25
    3286:	dd 27       	eor	r29, r29
    3288:	88 23       	and	r24, r24
    328a:	2a f0       	brmi	.+10     	; 0x3296 <log+0x26>
    328c:	21 97       	sbiw	r28, 0x01	; 1
    328e:	66 0f       	add	r22, r22
    3290:	77 1f       	adc	r23, r23
    3292:	88 1f       	adc	r24, r24
    3294:	da f7       	brpl	.-10     	; 0x328c <log+0x1c>
    3296:	20 e0       	ldi	r18, 0x00	; 0
    3298:	30 e0       	ldi	r19, 0x00	; 0
    329a:	40 e8       	ldi	r20, 0x80	; 128
    329c:	5f eb       	ldi	r21, 0xBF	; 191
    329e:	9f e3       	ldi	r25, 0x3F	; 63
    32a0:	88 39       	cpi	r24, 0x98	; 152
    32a2:	20 f0       	brcs	.+8      	; 0x32ac <log+0x3c>
    32a4:	80 3e       	cpi	r24, 0xE0	; 224
    32a6:	30 f0       	brcs	.+12     	; 0x32b4 <log+0x44>
    32a8:	21 96       	adiw	r28, 0x01	; 1
    32aa:	8f 77       	andi	r24, 0x7F	; 127
    32ac:	fa dd       	rcall	.-1036   	; 0x2ea2 <__addsf3>
    32ae:	e4 ef       	ldi	r30, 0xF4	; 244
    32b0:	f1 e0       	ldi	r31, 0x01	; 1
    32b2:	03 c0       	rjmp	.+6      	; 0x32ba <log+0x4a>
    32b4:	f6 dd       	rcall	.-1044   	; 0x2ea2 <__addsf3>
    32b6:	e1 e2       	ldi	r30, 0x21	; 33
    32b8:	f2 e0       	ldi	r31, 0x02	; 2
    32ba:	8b d0       	rcall	.+278    	; 0x33d2 <__fp_powser>
    32bc:	8b 01       	movw	r16, r22
    32be:	be 01       	movw	r22, r28
    32c0:	ec 01       	movw	r28, r24
    32c2:	fb 2e       	mov	r15, r27
    32c4:	6f 57       	subi	r22, 0x7F	; 127
    32c6:	71 09       	sbc	r23, r1
    32c8:	75 95       	asr	r23
    32ca:	77 1f       	adc	r23, r23
    32cc:	88 0b       	sbc	r24, r24
    32ce:	99 0b       	sbc	r25, r25
    32d0:	f0 de       	rcall	.-544    	; 0x30b2 <__floatsisf>
    32d2:	28 e1       	ldi	r18, 0x18	; 24
    32d4:	32 e7       	ldi	r19, 0x72	; 114
    32d6:	41 e3       	ldi	r20, 0x31	; 49
    32d8:	5f e3       	ldi	r21, 0x3F	; 63
    32da:	16 d0       	rcall	.+44     	; 0x3308 <__mulsf3x>
    32dc:	af 2d       	mov	r26, r15
    32de:	98 01       	movw	r18, r16
    32e0:	ae 01       	movw	r20, r28
    32e2:	ff 90       	pop	r15
    32e4:	0f 91       	pop	r16
    32e6:	1f 91       	pop	r17
    32e8:	cf 91       	pop	r28
    32ea:	df 91       	pop	r29
    32ec:	eb dd       	rcall	.-1066   	; 0x2ec4 <__addsf3x>
    32ee:	81 cf       	rjmp	.-254    	; 0x31f2 <__fp_round>

000032f0 <__mulsf3>:
    32f0:	0b d0       	rcall	.+22     	; 0x3308 <__mulsf3x>
    32f2:	7f cf       	rjmp	.-258    	; 0x31f2 <__fp_round>
    32f4:	70 df       	rcall	.-288    	; 0x31d6 <__fp_pscA>
    32f6:	28 f0       	brcs	.+10     	; 0x3302 <__mulsf3+0x12>
    32f8:	75 df       	rcall	.-278    	; 0x31e4 <__fp_pscB>
    32fa:	18 f0       	brcs	.+6      	; 0x3302 <__mulsf3+0x12>
    32fc:	95 23       	and	r25, r21
    32fe:	09 f0       	breq	.+2      	; 0x3302 <__mulsf3+0x12>
    3300:	51 cf       	rjmp	.-350    	; 0x31a4 <__fp_inf>
    3302:	56 cf       	rjmp	.-340    	; 0x31b0 <__fp_nan>
    3304:	11 24       	eor	r1, r1
    3306:	a9 cf       	rjmp	.-174    	; 0x325a <__fp_szero>

00003308 <__mulsf3x>:
    3308:	85 df       	rcall	.-246    	; 0x3214 <__fp_split3>
    330a:	a0 f3       	brcs	.-24     	; 0x32f4 <__mulsf3+0x4>

0000330c <__mulsf3_pse>:
    330c:	95 9f       	mul	r25, r21
    330e:	d1 f3       	breq	.-12     	; 0x3304 <__mulsf3+0x14>
    3310:	95 0f       	add	r25, r21
    3312:	50 e0       	ldi	r21, 0x00	; 0
    3314:	55 1f       	adc	r21, r21
    3316:	62 9f       	mul	r22, r18
    3318:	f0 01       	movw	r30, r0
    331a:	72 9f       	mul	r23, r18
    331c:	bb 27       	eor	r27, r27
    331e:	f0 0d       	add	r31, r0
    3320:	b1 1d       	adc	r27, r1
    3322:	63 9f       	mul	r22, r19
    3324:	aa 27       	eor	r26, r26
    3326:	f0 0d       	add	r31, r0
    3328:	b1 1d       	adc	r27, r1
    332a:	aa 1f       	adc	r26, r26
    332c:	64 9f       	mul	r22, r20
    332e:	66 27       	eor	r22, r22
    3330:	b0 0d       	add	r27, r0
    3332:	a1 1d       	adc	r26, r1
    3334:	66 1f       	adc	r22, r22
    3336:	82 9f       	mul	r24, r18
    3338:	22 27       	eor	r18, r18
    333a:	b0 0d       	add	r27, r0
    333c:	a1 1d       	adc	r26, r1
    333e:	62 1f       	adc	r22, r18
    3340:	73 9f       	mul	r23, r19
    3342:	b0 0d       	add	r27, r0
    3344:	a1 1d       	adc	r26, r1
    3346:	62 1f       	adc	r22, r18
    3348:	83 9f       	mul	r24, r19
    334a:	a0 0d       	add	r26, r0
    334c:	61 1d       	adc	r22, r1
    334e:	22 1f       	adc	r18, r18
    3350:	74 9f       	mul	r23, r20
    3352:	33 27       	eor	r19, r19
    3354:	a0 0d       	add	r26, r0
    3356:	61 1d       	adc	r22, r1
    3358:	23 1f       	adc	r18, r19
    335a:	84 9f       	mul	r24, r20
    335c:	60 0d       	add	r22, r0
    335e:	21 1d       	adc	r18, r1
    3360:	82 2f       	mov	r24, r18
    3362:	76 2f       	mov	r23, r22
    3364:	6a 2f       	mov	r22, r26
    3366:	11 24       	eor	r1, r1
    3368:	9f 57       	subi	r25, 0x7F	; 127
    336a:	50 40       	sbci	r21, 0x00	; 0
    336c:	8a f0       	brmi	.+34     	; 0x3390 <__mulsf3_pse+0x84>
    336e:	e1 f0       	breq	.+56     	; 0x33a8 <__mulsf3_pse+0x9c>
    3370:	88 23       	and	r24, r24
    3372:	4a f0       	brmi	.+18     	; 0x3386 <__mulsf3_pse+0x7a>
    3374:	ee 0f       	add	r30, r30
    3376:	ff 1f       	adc	r31, r31
    3378:	bb 1f       	adc	r27, r27
    337a:	66 1f       	adc	r22, r22
    337c:	77 1f       	adc	r23, r23
    337e:	88 1f       	adc	r24, r24
    3380:	91 50       	subi	r25, 0x01	; 1
    3382:	50 40       	sbci	r21, 0x00	; 0
    3384:	a9 f7       	brne	.-22     	; 0x3370 <__mulsf3_pse+0x64>
    3386:	9e 3f       	cpi	r25, 0xFE	; 254
    3388:	51 05       	cpc	r21, r1
    338a:	70 f0       	brcs	.+28     	; 0x33a8 <__mulsf3_pse+0x9c>
    338c:	0b cf       	rjmp	.-490    	; 0x31a4 <__fp_inf>
    338e:	65 cf       	rjmp	.-310    	; 0x325a <__fp_szero>
    3390:	5f 3f       	cpi	r21, 0xFF	; 255
    3392:	ec f3       	brlt	.-6      	; 0x338e <__mulsf3_pse+0x82>
    3394:	98 3e       	cpi	r25, 0xE8	; 232
    3396:	dc f3       	brlt	.-10     	; 0x338e <__mulsf3_pse+0x82>
    3398:	86 95       	lsr	r24
    339a:	77 95       	ror	r23
    339c:	67 95       	ror	r22
    339e:	b7 95       	ror	r27
    33a0:	f7 95       	ror	r31
    33a2:	e7 95       	ror	r30
    33a4:	9f 5f       	subi	r25, 0xFF	; 255
    33a6:	c1 f7       	brne	.-16     	; 0x3398 <__mulsf3_pse+0x8c>
    33a8:	fe 2b       	or	r31, r30
    33aa:	88 0f       	add	r24, r24
    33ac:	91 1d       	adc	r25, r1
    33ae:	96 95       	lsr	r25
    33b0:	87 95       	ror	r24
    33b2:	97 f9       	bld	r25, 7
    33b4:	08 95       	ret

000033b6 <__fp_mpack>:
    33b6:	9f 3f       	cpi	r25, 0xFF	; 255
    33b8:	31 f0       	breq	.+12     	; 0x33c6 <__fp_mpack_finite+0xc>

000033ba <__fp_mpack_finite>:
    33ba:	91 50       	subi	r25, 0x01	; 1
    33bc:	20 f4       	brcc	.+8      	; 0x33c6 <__fp_mpack_finite+0xc>
    33be:	87 95       	ror	r24
    33c0:	77 95       	ror	r23
    33c2:	67 95       	ror	r22
    33c4:	b7 95       	ror	r27
    33c6:	88 0f       	add	r24, r24
    33c8:	91 1d       	adc	r25, r1
    33ca:	96 95       	lsr	r25
    33cc:	87 95       	ror	r24
    33ce:	97 f9       	bld	r25, 7
    33d0:	08 95       	ret

000033d2 <__fp_powser>:
    33d2:	df 93       	push	r29
    33d4:	cf 93       	push	r28
    33d6:	1f 93       	push	r17
    33d8:	0f 93       	push	r16
    33da:	ff 92       	push	r15
    33dc:	ef 92       	push	r14
    33de:	df 92       	push	r13
    33e0:	7b 01       	movw	r14, r22
    33e2:	8c 01       	movw	r16, r24
    33e4:	68 94       	set
    33e6:	05 c0       	rjmp	.+10     	; 0x33f2 <__fp_powser+0x20>
    33e8:	da 2e       	mov	r13, r26
    33ea:	ef 01       	movw	r28, r30
    33ec:	8d df       	rcall	.-230    	; 0x3308 <__mulsf3x>
    33ee:	fe 01       	movw	r30, r28
    33f0:	e8 94       	clt
    33f2:	a5 91       	lpm	r26, Z+
    33f4:	25 91       	lpm	r18, Z+
    33f6:	35 91       	lpm	r19, Z+
    33f8:	45 91       	lpm	r20, Z+
    33fa:	55 91       	lpm	r21, Z+
    33fc:	ae f3       	brts	.-22     	; 0x33e8 <__fp_powser+0x16>
    33fe:	ef 01       	movw	r28, r30
    3400:	61 dd       	rcall	.-1342   	; 0x2ec4 <__addsf3x>
    3402:	fe 01       	movw	r30, r28
    3404:	97 01       	movw	r18, r14
    3406:	a8 01       	movw	r20, r16
    3408:	da 94       	dec	r13
    340a:	79 f7       	brne	.-34     	; 0x33ea <__fp_powser+0x18>
    340c:	df 90       	pop	r13
    340e:	ef 90       	pop	r14
    3410:	ff 90       	pop	r15
    3412:	0f 91       	pop	r16
    3414:	1f 91       	pop	r17
    3416:	cf 91       	pop	r28
    3418:	df 91       	pop	r29
    341a:	08 95       	ret

0000341c <vfprintf>:
    341c:	2f 92       	push	r2
    341e:	3f 92       	push	r3
    3420:	4f 92       	push	r4
    3422:	5f 92       	push	r5
    3424:	6f 92       	push	r6
    3426:	7f 92       	push	r7
    3428:	8f 92       	push	r8
    342a:	9f 92       	push	r9
    342c:	af 92       	push	r10
    342e:	bf 92       	push	r11
    3430:	cf 92       	push	r12
    3432:	df 92       	push	r13
    3434:	ef 92       	push	r14
    3436:	ff 92       	push	r15
    3438:	0f 93       	push	r16
    343a:	1f 93       	push	r17
    343c:	cf 93       	push	r28
    343e:	df 93       	push	r29
    3440:	cd b7       	in	r28, 0x3d	; 61
    3442:	de b7       	in	r29, 0x3e	; 62
    3444:	63 97       	sbiw	r28, 0x13	; 19
    3446:	cd bf       	out	0x3d, r28	; 61
    3448:	de bf       	out	0x3e, r29	; 62
    344a:	6c 01       	movw	r12, r24
    344c:	4b 01       	movw	r8, r22
    344e:	2a 01       	movw	r4, r20
    3450:	fc 01       	movw	r30, r24
    3452:	16 82       	std	Z+6, r1	; 0x06
    3454:	17 82       	std	Z+7, r1	; 0x07
    3456:	83 81       	ldd	r24, Z+3	; 0x03
    3458:	81 ff       	sbrs	r24, 1
    345a:	29 c3       	rjmp	.+1618   	; 0x3aae <vfprintf+0x692>
    345c:	ae 01       	movw	r20, r28
    345e:	4f 5f       	subi	r20, 0xFF	; 255
    3460:	5f 4f       	sbci	r21, 0xFF	; 255
    3462:	3a 01       	movw	r6, r20
    3464:	f6 01       	movw	r30, r12
    3466:	93 81       	ldd	r25, Z+3	; 0x03
    3468:	f4 01       	movw	r30, r8
    346a:	93 fd       	sbrc	r25, 3
    346c:	85 91       	lpm	r24, Z+
    346e:	93 ff       	sbrs	r25, 3
    3470:	81 91       	ld	r24, Z+
    3472:	4f 01       	movw	r8, r30
    3474:	88 23       	and	r24, r24
    3476:	09 f4       	brne	.+2      	; 0x347a <vfprintf+0x5e>
    3478:	16 c3       	rjmp	.+1580   	; 0x3aa6 <vfprintf+0x68a>
    347a:	85 32       	cpi	r24, 0x25	; 37
    347c:	39 f4       	brne	.+14     	; 0x348c <vfprintf+0x70>
    347e:	93 fd       	sbrc	r25, 3
    3480:	85 91       	lpm	r24, Z+
    3482:	93 ff       	sbrs	r25, 3
    3484:	81 91       	ld	r24, Z+
    3486:	4f 01       	movw	r8, r30
    3488:	85 32       	cpi	r24, 0x25	; 37
    348a:	31 f4       	brne	.+12     	; 0x3498 <vfprintf+0x7c>
    348c:	b6 01       	movw	r22, r12
    348e:	90 e0       	ldi	r25, 0x00	; 0
    3490:	80 d5       	rcall	.+2816   	; 0x3f92 <fputc>
    3492:	52 01       	movw	r10, r4
    3494:	25 01       	movw	r4, r10
    3496:	e6 cf       	rjmp	.-52     	; 0x3464 <vfprintf+0x48>
    3498:	10 e0       	ldi	r17, 0x00	; 0
    349a:	f1 2c       	mov	r15, r1
    349c:	20 e0       	ldi	r18, 0x00	; 0
    349e:	20 32       	cpi	r18, 0x20	; 32
    34a0:	a0 f4       	brcc	.+40     	; 0x34ca <vfprintf+0xae>
    34a2:	8b 32       	cpi	r24, 0x2B	; 43
    34a4:	69 f0       	breq	.+26     	; 0x34c0 <vfprintf+0xa4>
    34a6:	30 f4       	brcc	.+12     	; 0x34b4 <vfprintf+0x98>
    34a8:	80 32       	cpi	r24, 0x20	; 32
    34aa:	59 f0       	breq	.+22     	; 0x34c2 <vfprintf+0xa6>
    34ac:	83 32       	cpi	r24, 0x23	; 35
    34ae:	69 f4       	brne	.+26     	; 0x34ca <vfprintf+0xae>
    34b0:	20 61       	ori	r18, 0x10	; 16
    34b2:	2c c0       	rjmp	.+88     	; 0x350c <vfprintf+0xf0>
    34b4:	8d 32       	cpi	r24, 0x2D	; 45
    34b6:	39 f0       	breq	.+14     	; 0x34c6 <vfprintf+0xaa>
    34b8:	80 33       	cpi	r24, 0x30	; 48
    34ba:	39 f4       	brne	.+14     	; 0x34ca <vfprintf+0xae>
    34bc:	21 60       	ori	r18, 0x01	; 1
    34be:	26 c0       	rjmp	.+76     	; 0x350c <vfprintf+0xf0>
    34c0:	22 60       	ori	r18, 0x02	; 2
    34c2:	24 60       	ori	r18, 0x04	; 4
    34c4:	23 c0       	rjmp	.+70     	; 0x350c <vfprintf+0xf0>
    34c6:	28 60       	ori	r18, 0x08	; 8
    34c8:	21 c0       	rjmp	.+66     	; 0x350c <vfprintf+0xf0>
    34ca:	27 fd       	sbrc	r18, 7
    34cc:	27 c0       	rjmp	.+78     	; 0x351c <vfprintf+0x100>
    34ce:	30 ed       	ldi	r19, 0xD0	; 208
    34d0:	38 0f       	add	r19, r24
    34d2:	3a 30       	cpi	r19, 0x0A	; 10
    34d4:	78 f4       	brcc	.+30     	; 0x34f4 <vfprintf+0xd8>
    34d6:	26 ff       	sbrs	r18, 6
    34d8:	06 c0       	rjmp	.+12     	; 0x34e6 <vfprintf+0xca>
    34da:	fa e0       	ldi	r31, 0x0A	; 10
    34dc:	1f 9f       	mul	r17, r31
    34de:	30 0d       	add	r19, r0
    34e0:	11 24       	eor	r1, r1
    34e2:	13 2f       	mov	r17, r19
    34e4:	13 c0       	rjmp	.+38     	; 0x350c <vfprintf+0xf0>
    34e6:	4a e0       	ldi	r20, 0x0A	; 10
    34e8:	f4 9e       	mul	r15, r20
    34ea:	30 0d       	add	r19, r0
    34ec:	11 24       	eor	r1, r1
    34ee:	f3 2e       	mov	r15, r19
    34f0:	20 62       	ori	r18, 0x20	; 32
    34f2:	0c c0       	rjmp	.+24     	; 0x350c <vfprintf+0xf0>
    34f4:	8e 32       	cpi	r24, 0x2E	; 46
    34f6:	21 f4       	brne	.+8      	; 0x3500 <vfprintf+0xe4>
    34f8:	26 fd       	sbrc	r18, 6
    34fa:	d5 c2       	rjmp	.+1450   	; 0x3aa6 <vfprintf+0x68a>
    34fc:	20 64       	ori	r18, 0x40	; 64
    34fe:	06 c0       	rjmp	.+12     	; 0x350c <vfprintf+0xf0>
    3500:	8c 36       	cpi	r24, 0x6C	; 108
    3502:	11 f4       	brne	.+4      	; 0x3508 <vfprintf+0xec>
    3504:	20 68       	ori	r18, 0x80	; 128
    3506:	02 c0       	rjmp	.+4      	; 0x350c <vfprintf+0xf0>
    3508:	88 36       	cpi	r24, 0x68	; 104
    350a:	41 f4       	brne	.+16     	; 0x351c <vfprintf+0x100>
    350c:	f4 01       	movw	r30, r8
    350e:	93 fd       	sbrc	r25, 3
    3510:	85 91       	lpm	r24, Z+
    3512:	93 ff       	sbrs	r25, 3
    3514:	81 91       	ld	r24, Z+
    3516:	4f 01       	movw	r8, r30
    3518:	81 11       	cpse	r24, r1
    351a:	c1 cf       	rjmp	.-126    	; 0x349e <vfprintf+0x82>
    351c:	9b eb       	ldi	r25, 0xBB	; 187
    351e:	98 0f       	add	r25, r24
    3520:	93 30       	cpi	r25, 0x03	; 3
    3522:	18 f4       	brcc	.+6      	; 0x352a <vfprintf+0x10e>
    3524:	20 61       	ori	r18, 0x10	; 16
    3526:	80 5e       	subi	r24, 0xE0	; 224
    3528:	06 c0       	rjmp	.+12     	; 0x3536 <vfprintf+0x11a>
    352a:	9b e9       	ldi	r25, 0x9B	; 155
    352c:	98 0f       	add	r25, r24
    352e:	93 30       	cpi	r25, 0x03	; 3
    3530:	08 f0       	brcs	.+2      	; 0x3534 <vfprintf+0x118>
    3532:	64 c1       	rjmp	.+712    	; 0x37fc <vfprintf+0x3e0>
    3534:	2f 7e       	andi	r18, 0xEF	; 239
    3536:	26 ff       	sbrs	r18, 6
    3538:	16 e0       	ldi	r17, 0x06	; 6
    353a:	2f 73       	andi	r18, 0x3F	; 63
    353c:	32 2e       	mov	r3, r18
    353e:	85 36       	cpi	r24, 0x65	; 101
    3540:	19 f4       	brne	.+6      	; 0x3548 <vfprintf+0x12c>
    3542:	20 64       	ori	r18, 0x40	; 64
    3544:	32 2e       	mov	r3, r18
    3546:	08 c0       	rjmp	.+16     	; 0x3558 <vfprintf+0x13c>
    3548:	86 36       	cpi	r24, 0x66	; 102
    354a:	21 f4       	brne	.+8      	; 0x3554 <vfprintf+0x138>
    354c:	f2 2f       	mov	r31, r18
    354e:	f0 68       	ori	r31, 0x80	; 128
    3550:	3f 2e       	mov	r3, r31
    3552:	02 c0       	rjmp	.+4      	; 0x3558 <vfprintf+0x13c>
    3554:	11 11       	cpse	r17, r1
    3556:	11 50       	subi	r17, 0x01	; 1
    3558:	37 fe       	sbrs	r3, 7
    355a:	07 c0       	rjmp	.+14     	; 0x356a <vfprintf+0x14e>
    355c:	1c 33       	cpi	r17, 0x3C	; 60
    355e:	50 f4       	brcc	.+20     	; 0x3574 <vfprintf+0x158>
    3560:	ee 24       	eor	r14, r14
    3562:	e3 94       	inc	r14
    3564:	e1 0e       	add	r14, r17
    3566:	27 e0       	ldi	r18, 0x07	; 7
    3568:	0b c0       	rjmp	.+22     	; 0x3580 <vfprintf+0x164>
    356a:	18 30       	cpi	r17, 0x08	; 8
    356c:	38 f0       	brcs	.+14     	; 0x357c <vfprintf+0x160>
    356e:	27 e0       	ldi	r18, 0x07	; 7
    3570:	17 e0       	ldi	r17, 0x07	; 7
    3572:	05 c0       	rjmp	.+10     	; 0x357e <vfprintf+0x162>
    3574:	27 e0       	ldi	r18, 0x07	; 7
    3576:	4c e3       	ldi	r20, 0x3C	; 60
    3578:	e4 2e       	mov	r14, r20
    357a:	02 c0       	rjmp	.+4      	; 0x3580 <vfprintf+0x164>
    357c:	21 2f       	mov	r18, r17
    357e:	e1 2c       	mov	r14, r1
    3580:	52 01       	movw	r10, r4
    3582:	44 e0       	ldi	r20, 0x04	; 4
    3584:	a4 0e       	add	r10, r20
    3586:	b1 1c       	adc	r11, r1
    3588:	f2 01       	movw	r30, r4
    358a:	60 81       	ld	r22, Z
    358c:	71 81       	ldd	r23, Z+1	; 0x01
    358e:	82 81       	ldd	r24, Z+2	; 0x02
    3590:	93 81       	ldd	r25, Z+3	; 0x03
    3592:	0e 2d       	mov	r16, r14
    3594:	a3 01       	movw	r20, r6
    3596:	c5 d3       	rcall	.+1930   	; 0x3d22 <__ftoa_engine>
    3598:	2c 01       	movw	r4, r24
    359a:	09 81       	ldd	r16, Y+1	; 0x01
    359c:	00 ff       	sbrs	r16, 0
    359e:	02 c0       	rjmp	.+4      	; 0x35a4 <vfprintf+0x188>
    35a0:	03 ff       	sbrs	r16, 3
    35a2:	07 c0       	rjmp	.+14     	; 0x35b2 <vfprintf+0x196>
    35a4:	31 fc       	sbrc	r3, 1
    35a6:	08 c0       	rjmp	.+16     	; 0x35b8 <vfprintf+0x19c>
    35a8:	32 fe       	sbrs	r3, 2
    35aa:	09 c0       	rjmp	.+18     	; 0x35be <vfprintf+0x1a2>
    35ac:	30 e2       	ldi	r19, 0x20	; 32
    35ae:	23 2e       	mov	r2, r19
    35b0:	07 c0       	rjmp	.+14     	; 0x35c0 <vfprintf+0x1a4>
    35b2:	2d e2       	ldi	r18, 0x2D	; 45
    35b4:	22 2e       	mov	r2, r18
    35b6:	04 c0       	rjmp	.+8      	; 0x35c0 <vfprintf+0x1a4>
    35b8:	9b e2       	ldi	r25, 0x2B	; 43
    35ba:	29 2e       	mov	r2, r25
    35bc:	01 c0       	rjmp	.+2      	; 0x35c0 <vfprintf+0x1a4>
    35be:	21 2c       	mov	r2, r1
    35c0:	80 2f       	mov	r24, r16
    35c2:	8c 70       	andi	r24, 0x0C	; 12
    35c4:	19 f0       	breq	.+6      	; 0x35cc <vfprintf+0x1b0>
    35c6:	21 10       	cpse	r2, r1
    35c8:	51 c2       	rjmp	.+1186   	; 0x3a6c <vfprintf+0x650>
    35ca:	8d c2       	rjmp	.+1306   	; 0x3ae6 <vfprintf+0x6ca>
    35cc:	37 fe       	sbrs	r3, 7
    35ce:	0f c0       	rjmp	.+30     	; 0x35ee <vfprintf+0x1d2>
    35d0:	e4 0c       	add	r14, r4
    35d2:	04 ff       	sbrs	r16, 4
    35d4:	04 c0       	rjmp	.+8      	; 0x35de <vfprintf+0x1c2>
    35d6:	8a 81       	ldd	r24, Y+2	; 0x02
    35d8:	81 33       	cpi	r24, 0x31	; 49
    35da:	09 f4       	brne	.+2      	; 0x35de <vfprintf+0x1c2>
    35dc:	ea 94       	dec	r14
    35de:	1e 14       	cp	r1, r14
    35e0:	74 f5       	brge	.+92     	; 0x363e <vfprintf+0x222>
    35e2:	f8 e0       	ldi	r31, 0x08	; 8
    35e4:	fe 15       	cp	r31, r14
    35e6:	78 f5       	brcc	.+94     	; 0x3646 <vfprintf+0x22a>
    35e8:	88 e0       	ldi	r24, 0x08	; 8
    35ea:	e8 2e       	mov	r14, r24
    35ec:	2c c0       	rjmp	.+88     	; 0x3646 <vfprintf+0x22a>
    35ee:	36 fc       	sbrc	r3, 6
    35f0:	2a c0       	rjmp	.+84     	; 0x3646 <vfprintf+0x22a>
    35f2:	81 2f       	mov	r24, r17
    35f4:	90 e0       	ldi	r25, 0x00	; 0
    35f6:	84 15       	cp	r24, r4
    35f8:	95 05       	cpc	r25, r5
    35fa:	9c f0       	brlt	.+38     	; 0x3622 <vfprintf+0x206>
    35fc:	2c ef       	ldi	r18, 0xFC	; 252
    35fe:	42 16       	cp	r4, r18
    3600:	2f ef       	ldi	r18, 0xFF	; 255
    3602:	52 06       	cpc	r5, r18
    3604:	74 f0       	brlt	.+28     	; 0x3622 <vfprintf+0x206>
    3606:	43 2d       	mov	r20, r3
    3608:	40 68       	ori	r20, 0x80	; 128
    360a:	34 2e       	mov	r3, r20
    360c:	0a c0       	rjmp	.+20     	; 0x3622 <vfprintf+0x206>
    360e:	e2 e0       	ldi	r30, 0x02	; 2
    3610:	f0 e0       	ldi	r31, 0x00	; 0
    3612:	ec 0f       	add	r30, r28
    3614:	fd 1f       	adc	r31, r29
    3616:	e1 0f       	add	r30, r17
    3618:	f1 1d       	adc	r31, r1
    361a:	80 81       	ld	r24, Z
    361c:	80 33       	cpi	r24, 0x30	; 48
    361e:	19 f4       	brne	.+6      	; 0x3626 <vfprintf+0x20a>
    3620:	11 50       	subi	r17, 0x01	; 1
    3622:	11 11       	cpse	r17, r1
    3624:	f4 cf       	rjmp	.-24     	; 0x360e <vfprintf+0x1f2>
    3626:	37 fe       	sbrs	r3, 7
    3628:	0e c0       	rjmp	.+28     	; 0x3646 <vfprintf+0x22a>
    362a:	ee 24       	eor	r14, r14
    362c:	e3 94       	inc	r14
    362e:	e1 0e       	add	r14, r17
    3630:	81 2f       	mov	r24, r17
    3632:	90 e0       	ldi	r25, 0x00	; 0
    3634:	48 16       	cp	r4, r24
    3636:	59 06       	cpc	r5, r25
    3638:	2c f4       	brge	.+10     	; 0x3644 <vfprintf+0x228>
    363a:	14 19       	sub	r17, r4
    363c:	04 c0       	rjmp	.+8      	; 0x3646 <vfprintf+0x22a>
    363e:	ee 24       	eor	r14, r14
    3640:	e3 94       	inc	r14
    3642:	01 c0       	rjmp	.+2      	; 0x3646 <vfprintf+0x22a>
    3644:	10 e0       	ldi	r17, 0x00	; 0
    3646:	37 fe       	sbrs	r3, 7
    3648:	06 c0       	rjmp	.+12     	; 0x3656 <vfprintf+0x23a>
    364a:	14 14       	cp	r1, r4
    364c:	15 04       	cpc	r1, r5
    364e:	34 f4       	brge	.+12     	; 0x365c <vfprintf+0x240>
    3650:	c2 01       	movw	r24, r4
    3652:	01 96       	adiw	r24, 0x01	; 1
    3654:	05 c0       	rjmp	.+10     	; 0x3660 <vfprintf+0x244>
    3656:	85 e0       	ldi	r24, 0x05	; 5
    3658:	90 e0       	ldi	r25, 0x00	; 0
    365a:	02 c0       	rjmp	.+4      	; 0x3660 <vfprintf+0x244>
    365c:	81 e0       	ldi	r24, 0x01	; 1
    365e:	90 e0       	ldi	r25, 0x00	; 0
    3660:	21 10       	cpse	r2, r1
    3662:	01 96       	adiw	r24, 0x01	; 1
    3664:	11 23       	and	r17, r17
    3666:	31 f0       	breq	.+12     	; 0x3674 <vfprintf+0x258>
    3668:	21 2f       	mov	r18, r17
    366a:	30 e0       	ldi	r19, 0x00	; 0
    366c:	2f 5f       	subi	r18, 0xFF	; 255
    366e:	3f 4f       	sbci	r19, 0xFF	; 255
    3670:	82 0f       	add	r24, r18
    3672:	93 1f       	adc	r25, r19
    3674:	2f 2d       	mov	r18, r15
    3676:	30 e0       	ldi	r19, 0x00	; 0
    3678:	82 17       	cp	r24, r18
    367a:	93 07       	cpc	r25, r19
    367c:	14 f4       	brge	.+4      	; 0x3682 <vfprintf+0x266>
    367e:	f8 1a       	sub	r15, r24
    3680:	01 c0       	rjmp	.+2      	; 0x3684 <vfprintf+0x268>
    3682:	f1 2c       	mov	r15, r1
    3684:	83 2d       	mov	r24, r3
    3686:	89 70       	andi	r24, 0x09	; 9
    3688:	41 f4       	brne	.+16     	; 0x369a <vfprintf+0x27e>
    368a:	ff 20       	and	r15, r15
    368c:	31 f0       	breq	.+12     	; 0x369a <vfprintf+0x27e>
    368e:	b6 01       	movw	r22, r12
    3690:	80 e2       	ldi	r24, 0x20	; 32
    3692:	90 e0       	ldi	r25, 0x00	; 0
    3694:	7e d4       	rcall	.+2300   	; 0x3f92 <fputc>
    3696:	fa 94       	dec	r15
    3698:	f8 cf       	rjmp	.-16     	; 0x368a <vfprintf+0x26e>
    369a:	22 20       	and	r2, r2
    369c:	21 f0       	breq	.+8      	; 0x36a6 <vfprintf+0x28a>
    369e:	b6 01       	movw	r22, r12
    36a0:	82 2d       	mov	r24, r2
    36a2:	90 e0       	ldi	r25, 0x00	; 0
    36a4:	76 d4       	rcall	.+2284   	; 0x3f92 <fputc>
    36a6:	33 fc       	sbrc	r3, 3
    36a8:	08 c0       	rjmp	.+16     	; 0x36ba <vfprintf+0x29e>
    36aa:	ff 20       	and	r15, r15
    36ac:	31 f0       	breq	.+12     	; 0x36ba <vfprintf+0x29e>
    36ae:	b6 01       	movw	r22, r12
    36b0:	80 e3       	ldi	r24, 0x30	; 48
    36b2:	90 e0       	ldi	r25, 0x00	; 0
    36b4:	6e d4       	rcall	.+2268   	; 0x3f92 <fputc>
    36b6:	fa 94       	dec	r15
    36b8:	f8 cf       	rjmp	.-16     	; 0x36aa <vfprintf+0x28e>
    36ba:	37 fe       	sbrs	r3, 7
    36bc:	58 c0       	rjmp	.+176    	; 0x376e <vfprintf+0x352>
    36be:	94 2d       	mov	r25, r4
    36c0:	85 2d       	mov	r24, r5
    36c2:	57 fe       	sbrs	r5, 7
    36c4:	02 c0       	rjmp	.+4      	; 0x36ca <vfprintf+0x2ae>
    36c6:	90 e0       	ldi	r25, 0x00	; 0
    36c8:	80 e0       	ldi	r24, 0x00	; 0
    36ca:	29 2e       	mov	r2, r25
    36cc:	38 2e       	mov	r3, r24
    36ce:	20 e0       	ldi	r18, 0x00	; 0
    36d0:	30 e0       	ldi	r19, 0x00	; 0
    36d2:	a2 01       	movw	r20, r4
    36d4:	4e 19       	sub	r20, r14
    36d6:	51 09       	sbc	r21, r1
    36d8:	4c 87       	std	Y+12, r20	; 0x0c
    36da:	5d 87       	std	Y+13, r21	; 0x0d
    36dc:	a2 01       	movw	r20, r4
    36de:	42 19       	sub	r20, r2
    36e0:	53 09       	sbc	r21, r3
    36e2:	4e 87       	std	Y+14, r20	; 0x0e
    36e4:	5f 87       	std	Y+15, r21	; 0x0f
    36e6:	61 2f       	mov	r22, r17
    36e8:	70 e0       	ldi	r23, 0x00	; 0
    36ea:	44 27       	eor	r20, r20
    36ec:	55 27       	eor	r21, r21
    36ee:	46 1b       	sub	r20, r22
    36f0:	57 0b       	sbc	r21, r23
    36f2:	48 8b       	std	Y+16, r20	; 0x10
    36f4:	59 8b       	std	Y+17, r21	; 0x11
    36f6:	5f ef       	ldi	r21, 0xFF	; 255
    36f8:	25 16       	cp	r2, r21
    36fa:	35 06       	cpc	r3, r21
    36fc:	41 f4       	brne	.+16     	; 0x370e <vfprintf+0x2f2>
    36fe:	b6 01       	movw	r22, r12
    3700:	8e e2       	ldi	r24, 0x2E	; 46
    3702:	90 e0       	ldi	r25, 0x00	; 0
    3704:	2a 8b       	std	Y+18, r18	; 0x12
    3706:	3b 8b       	std	Y+19, r19	; 0x13
    3708:	44 d4       	rcall	.+2184   	; 0x3f92 <fputc>
    370a:	3b 89       	ldd	r19, Y+19	; 0x13
    370c:	2a 89       	ldd	r18, Y+18	; 0x12
    370e:	42 14       	cp	r4, r2
    3710:	53 04       	cpc	r5, r3
    3712:	6c f0       	brlt	.+26     	; 0x372e <vfprintf+0x312>
    3714:	4c 85       	ldd	r20, Y+12	; 0x0c
    3716:	5d 85       	ldd	r21, Y+13	; 0x0d
    3718:	42 15       	cp	r20, r2
    371a:	53 05       	cpc	r21, r3
    371c:	44 f4       	brge	.+16     	; 0x372e <vfprintf+0x312>
    371e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3720:	ff 85       	ldd	r31, Y+15	; 0x0f
    3722:	e2 0f       	add	r30, r18
    3724:	f3 1f       	adc	r31, r19
    3726:	e6 0d       	add	r30, r6
    3728:	f7 1d       	adc	r31, r7
    372a:	81 81       	ldd	r24, Z+1	; 0x01
    372c:	01 c0       	rjmp	.+2      	; 0x3730 <vfprintf+0x314>
    372e:	80 e3       	ldi	r24, 0x30	; 48
    3730:	51 e0       	ldi	r21, 0x01	; 1
    3732:	25 1a       	sub	r2, r21
    3734:	31 08       	sbc	r3, r1
    3736:	2f 5f       	subi	r18, 0xFF	; 255
    3738:	3f 4f       	sbci	r19, 0xFF	; 255
    373a:	48 89       	ldd	r20, Y+16	; 0x10
    373c:	59 89       	ldd	r21, Y+17	; 0x11
    373e:	24 16       	cp	r2, r20
    3740:	35 06       	cpc	r3, r21
    3742:	44 f0       	brlt	.+16     	; 0x3754 <vfprintf+0x338>
    3744:	b6 01       	movw	r22, r12
    3746:	90 e0       	ldi	r25, 0x00	; 0
    3748:	2a 8b       	std	Y+18, r18	; 0x12
    374a:	3b 8b       	std	Y+19, r19	; 0x13
    374c:	22 d4       	rcall	.+2116   	; 0x3f92 <fputc>
    374e:	2a 89       	ldd	r18, Y+18	; 0x12
    3750:	3b 89       	ldd	r19, Y+19	; 0x13
    3752:	d1 cf       	rjmp	.-94     	; 0x36f6 <vfprintf+0x2da>
    3754:	24 14       	cp	r2, r4
    3756:	35 04       	cpc	r3, r5
    3758:	39 f4       	brne	.+14     	; 0x3768 <vfprintf+0x34c>
    375a:	9a 81       	ldd	r25, Y+2	; 0x02
    375c:	96 33       	cpi	r25, 0x36	; 54
    375e:	18 f4       	brcc	.+6      	; 0x3766 <vfprintf+0x34a>
    3760:	95 33       	cpi	r25, 0x35	; 53
    3762:	11 f4       	brne	.+4      	; 0x3768 <vfprintf+0x34c>
    3764:	04 ff       	sbrs	r16, 4
    3766:	81 e3       	ldi	r24, 0x31	; 49
    3768:	b6 01       	movw	r22, r12
    376a:	90 e0       	ldi	r25, 0x00	; 0
    376c:	45 c0       	rjmp	.+138    	; 0x37f8 <vfprintf+0x3dc>
    376e:	8a 81       	ldd	r24, Y+2	; 0x02
    3770:	81 33       	cpi	r24, 0x31	; 49
    3772:	09 f0       	breq	.+2      	; 0x3776 <vfprintf+0x35a>
    3774:	0f 7e       	andi	r16, 0xEF	; 239
    3776:	b6 01       	movw	r22, r12
    3778:	90 e0       	ldi	r25, 0x00	; 0
    377a:	0b d4       	rcall	.+2070   	; 0x3f92 <fputc>
    377c:	11 11       	cpse	r17, r1
    377e:	05 c0       	rjmp	.+10     	; 0x378a <vfprintf+0x36e>
    3780:	34 fc       	sbrc	r3, 4
    3782:	16 c0       	rjmp	.+44     	; 0x37b0 <vfprintf+0x394>
    3784:	85 e6       	ldi	r24, 0x65	; 101
    3786:	90 e0       	ldi	r25, 0x00	; 0
    3788:	15 c0       	rjmp	.+42     	; 0x37b4 <vfprintf+0x398>
    378a:	b6 01       	movw	r22, r12
    378c:	8e e2       	ldi	r24, 0x2E	; 46
    378e:	90 e0       	ldi	r25, 0x00	; 0
    3790:	00 d4       	rcall	.+2048   	; 0x3f92 <fputc>
    3792:	82 e0       	ldi	r24, 0x02	; 2
    3794:	ee 24       	eor	r14, r14
    3796:	e3 94       	inc	r14
    3798:	e8 0e       	add	r14, r24
    379a:	f3 01       	movw	r30, r6
    379c:	e8 0f       	add	r30, r24
    379e:	f1 1d       	adc	r31, r1
    37a0:	80 81       	ld	r24, Z
    37a2:	b6 01       	movw	r22, r12
    37a4:	90 e0       	ldi	r25, 0x00	; 0
    37a6:	f5 d3       	rcall	.+2026   	; 0x3f92 <fputc>
    37a8:	11 50       	subi	r17, 0x01	; 1
    37aa:	8e 2d       	mov	r24, r14
    37ac:	99 f7       	brne	.-26     	; 0x3794 <vfprintf+0x378>
    37ae:	e8 cf       	rjmp	.-48     	; 0x3780 <vfprintf+0x364>
    37b0:	85 e4       	ldi	r24, 0x45	; 69
    37b2:	90 e0       	ldi	r25, 0x00	; 0
    37b4:	b6 01       	movw	r22, r12
    37b6:	ed d3       	rcall	.+2010   	; 0x3f92 <fputc>
    37b8:	57 fc       	sbrc	r5, 7
    37ba:	05 c0       	rjmp	.+10     	; 0x37c6 <vfprintf+0x3aa>
    37bc:	41 14       	cp	r4, r1
    37be:	51 04       	cpc	r5, r1
    37c0:	39 f4       	brne	.+14     	; 0x37d0 <vfprintf+0x3b4>
    37c2:	04 ff       	sbrs	r16, 4
    37c4:	05 c0       	rjmp	.+10     	; 0x37d0 <vfprintf+0x3b4>
    37c6:	51 94       	neg	r5
    37c8:	41 94       	neg	r4
    37ca:	51 08       	sbc	r5, r1
    37cc:	8d e2       	ldi	r24, 0x2D	; 45
    37ce:	01 c0       	rjmp	.+2      	; 0x37d2 <vfprintf+0x3b6>
    37d0:	8b e2       	ldi	r24, 0x2B	; 43
    37d2:	b6 01       	movw	r22, r12
    37d4:	90 e0       	ldi	r25, 0x00	; 0
    37d6:	dd d3       	rcall	.+1978   	; 0x3f92 <fputc>
    37d8:	80 e3       	ldi	r24, 0x30	; 48
    37da:	9a e0       	ldi	r25, 0x0A	; 10
    37dc:	49 16       	cp	r4, r25
    37de:	51 04       	cpc	r5, r1
    37e0:	2c f0       	brlt	.+10     	; 0x37ec <vfprintf+0x3d0>
    37e2:	8f 5f       	subi	r24, 0xFF	; 255
    37e4:	5a e0       	ldi	r21, 0x0A	; 10
    37e6:	45 1a       	sub	r4, r21
    37e8:	51 08       	sbc	r5, r1
    37ea:	f7 cf       	rjmp	.-18     	; 0x37da <vfprintf+0x3be>
    37ec:	b6 01       	movw	r22, r12
    37ee:	90 e0       	ldi	r25, 0x00	; 0
    37f0:	d0 d3       	rcall	.+1952   	; 0x3f92 <fputc>
    37f2:	b6 01       	movw	r22, r12
    37f4:	c2 01       	movw	r24, r4
    37f6:	c0 96       	adiw	r24, 0x30	; 48
    37f8:	cc d3       	rcall	.+1944   	; 0x3f92 <fputc>
    37fa:	4c c1       	rjmp	.+664    	; 0x3a94 <vfprintf+0x678>
    37fc:	83 36       	cpi	r24, 0x63	; 99
    37fe:	31 f0       	breq	.+12     	; 0x380c <vfprintf+0x3f0>
    3800:	83 37       	cpi	r24, 0x73	; 115
    3802:	79 f0       	breq	.+30     	; 0x3822 <vfprintf+0x406>
    3804:	83 35       	cpi	r24, 0x53	; 83
    3806:	09 f0       	breq	.+2      	; 0x380a <vfprintf+0x3ee>
    3808:	54 c0       	rjmp	.+168    	; 0x38b2 <vfprintf+0x496>
    380a:	20 c0       	rjmp	.+64     	; 0x384c <vfprintf+0x430>
    380c:	52 01       	movw	r10, r4
    380e:	e2 e0       	ldi	r30, 0x02	; 2
    3810:	ae 0e       	add	r10, r30
    3812:	b1 1c       	adc	r11, r1
    3814:	f2 01       	movw	r30, r4
    3816:	80 81       	ld	r24, Z
    3818:	89 83       	std	Y+1, r24	; 0x01
    381a:	01 e0       	ldi	r16, 0x01	; 1
    381c:	10 e0       	ldi	r17, 0x00	; 0
    381e:	23 01       	movw	r4, r6
    3820:	13 c0       	rjmp	.+38     	; 0x3848 <vfprintf+0x42c>
    3822:	52 01       	movw	r10, r4
    3824:	f2 e0       	ldi	r31, 0x02	; 2
    3826:	af 0e       	add	r10, r31
    3828:	b1 1c       	adc	r11, r1
    382a:	f2 01       	movw	r30, r4
    382c:	40 80       	ld	r4, Z
    382e:	51 80       	ldd	r5, Z+1	; 0x01
    3830:	26 ff       	sbrs	r18, 6
    3832:	03 c0       	rjmp	.+6      	; 0x383a <vfprintf+0x41e>
    3834:	61 2f       	mov	r22, r17
    3836:	70 e0       	ldi	r23, 0x00	; 0
    3838:	02 c0       	rjmp	.+4      	; 0x383e <vfprintf+0x422>
    383a:	6f ef       	ldi	r22, 0xFF	; 255
    383c:	7f ef       	ldi	r23, 0xFF	; 255
    383e:	c2 01       	movw	r24, r4
    3840:	2a 8b       	std	Y+18, r18	; 0x12
    3842:	52 d3       	rcall	.+1700   	; 0x3ee8 <strnlen>
    3844:	8c 01       	movw	r16, r24
    3846:	2a 89       	ldd	r18, Y+18	; 0x12
    3848:	2f 77       	andi	r18, 0x7F	; 127
    384a:	14 c0       	rjmp	.+40     	; 0x3874 <vfprintf+0x458>
    384c:	52 01       	movw	r10, r4
    384e:	f2 e0       	ldi	r31, 0x02	; 2
    3850:	af 0e       	add	r10, r31
    3852:	b1 1c       	adc	r11, r1
    3854:	f2 01       	movw	r30, r4
    3856:	40 80       	ld	r4, Z
    3858:	51 80       	ldd	r5, Z+1	; 0x01
    385a:	26 ff       	sbrs	r18, 6
    385c:	03 c0       	rjmp	.+6      	; 0x3864 <vfprintf+0x448>
    385e:	61 2f       	mov	r22, r17
    3860:	70 e0       	ldi	r23, 0x00	; 0
    3862:	02 c0       	rjmp	.+4      	; 0x3868 <vfprintf+0x44c>
    3864:	6f ef       	ldi	r22, 0xFF	; 255
    3866:	7f ef       	ldi	r23, 0xFF	; 255
    3868:	c2 01       	movw	r24, r4
    386a:	2a 8b       	std	Y+18, r18	; 0x12
    386c:	32 d3       	rcall	.+1636   	; 0x3ed2 <strnlen_P>
    386e:	8c 01       	movw	r16, r24
    3870:	2a 89       	ldd	r18, Y+18	; 0x12
    3872:	20 68       	ori	r18, 0x80	; 128
    3874:	32 2e       	mov	r3, r18
    3876:	23 fd       	sbrc	r18, 3
    3878:	18 c0       	rjmp	.+48     	; 0x38aa <vfprintf+0x48e>
    387a:	8f 2d       	mov	r24, r15
    387c:	90 e0       	ldi	r25, 0x00	; 0
    387e:	08 17       	cp	r16, r24
    3880:	19 07       	cpc	r17, r25
    3882:	98 f4       	brcc	.+38     	; 0x38aa <vfprintf+0x48e>
    3884:	b6 01       	movw	r22, r12
    3886:	80 e2       	ldi	r24, 0x20	; 32
    3888:	90 e0       	ldi	r25, 0x00	; 0
    388a:	83 d3       	rcall	.+1798   	; 0x3f92 <fputc>
    388c:	fa 94       	dec	r15
    388e:	f5 cf       	rjmp	.-22     	; 0x387a <vfprintf+0x45e>
    3890:	f2 01       	movw	r30, r4
    3892:	37 fc       	sbrc	r3, 7
    3894:	85 91       	lpm	r24, Z+
    3896:	37 fe       	sbrs	r3, 7
    3898:	81 91       	ld	r24, Z+
    389a:	2f 01       	movw	r4, r30
    389c:	b6 01       	movw	r22, r12
    389e:	90 e0       	ldi	r25, 0x00	; 0
    38a0:	78 d3       	rcall	.+1776   	; 0x3f92 <fputc>
    38a2:	f1 10       	cpse	r15, r1
    38a4:	fa 94       	dec	r15
    38a6:	01 50       	subi	r16, 0x01	; 1
    38a8:	11 09       	sbc	r17, r1
    38aa:	01 15       	cp	r16, r1
    38ac:	11 05       	cpc	r17, r1
    38ae:	81 f7       	brne	.-32     	; 0x3890 <vfprintf+0x474>
    38b0:	f1 c0       	rjmp	.+482    	; 0x3a94 <vfprintf+0x678>
    38b2:	84 36       	cpi	r24, 0x64	; 100
    38b4:	11 f0       	breq	.+4      	; 0x38ba <vfprintf+0x49e>
    38b6:	89 36       	cpi	r24, 0x69	; 105
    38b8:	51 f5       	brne	.+84     	; 0x390e <vfprintf+0x4f2>
    38ba:	52 01       	movw	r10, r4
    38bc:	27 ff       	sbrs	r18, 7
    38be:	09 c0       	rjmp	.+18     	; 0x38d2 <vfprintf+0x4b6>
    38c0:	f4 e0       	ldi	r31, 0x04	; 4
    38c2:	af 0e       	add	r10, r31
    38c4:	b1 1c       	adc	r11, r1
    38c6:	f2 01       	movw	r30, r4
    38c8:	60 81       	ld	r22, Z
    38ca:	71 81       	ldd	r23, Z+1	; 0x01
    38cc:	82 81       	ldd	r24, Z+2	; 0x02
    38ce:	93 81       	ldd	r25, Z+3	; 0x03
    38d0:	0a c0       	rjmp	.+20     	; 0x38e6 <vfprintf+0x4ca>
    38d2:	f2 e0       	ldi	r31, 0x02	; 2
    38d4:	af 0e       	add	r10, r31
    38d6:	b1 1c       	adc	r11, r1
    38d8:	f2 01       	movw	r30, r4
    38da:	60 81       	ld	r22, Z
    38dc:	71 81       	ldd	r23, Z+1	; 0x01
    38de:	07 2e       	mov	r0, r23
    38e0:	00 0c       	add	r0, r0
    38e2:	88 0b       	sbc	r24, r24
    38e4:	99 0b       	sbc	r25, r25
    38e6:	2f 76       	andi	r18, 0x6F	; 111
    38e8:	32 2e       	mov	r3, r18
    38ea:	97 ff       	sbrs	r25, 7
    38ec:	09 c0       	rjmp	.+18     	; 0x3900 <vfprintf+0x4e4>
    38ee:	90 95       	com	r25
    38f0:	80 95       	com	r24
    38f2:	70 95       	com	r23
    38f4:	61 95       	neg	r22
    38f6:	7f 4f       	sbci	r23, 0xFF	; 255
    38f8:	8f 4f       	sbci	r24, 0xFF	; 255
    38fa:	9f 4f       	sbci	r25, 0xFF	; 255
    38fc:	20 68       	ori	r18, 0x80	; 128
    38fe:	32 2e       	mov	r3, r18
    3900:	2a e0       	ldi	r18, 0x0A	; 10
    3902:	30 e0       	ldi	r19, 0x00	; 0
    3904:	a3 01       	movw	r20, r6
    3906:	c0 d3       	rcall	.+1920   	; 0x4088 <__ultoa_invert>
    3908:	e8 2e       	mov	r14, r24
    390a:	e6 18       	sub	r14, r6
    390c:	3e c0       	rjmp	.+124    	; 0x398a <vfprintf+0x56e>
    390e:	02 2f       	mov	r16, r18
    3910:	85 37       	cpi	r24, 0x75	; 117
    3912:	21 f4       	brne	.+8      	; 0x391c <vfprintf+0x500>
    3914:	0f 7e       	andi	r16, 0xEF	; 239
    3916:	2a e0       	ldi	r18, 0x0A	; 10
    3918:	30 e0       	ldi	r19, 0x00	; 0
    391a:	1d c0       	rjmp	.+58     	; 0x3956 <vfprintf+0x53a>
    391c:	09 7f       	andi	r16, 0xF9	; 249
    391e:	8f 36       	cpi	r24, 0x6F	; 111
    3920:	91 f0       	breq	.+36     	; 0x3946 <vfprintf+0x52a>
    3922:	18 f4       	brcc	.+6      	; 0x392a <vfprintf+0x50e>
    3924:	88 35       	cpi	r24, 0x58	; 88
    3926:	59 f0       	breq	.+22     	; 0x393e <vfprintf+0x522>
    3928:	be c0       	rjmp	.+380    	; 0x3aa6 <vfprintf+0x68a>
    392a:	80 37       	cpi	r24, 0x70	; 112
    392c:	19 f0       	breq	.+6      	; 0x3934 <vfprintf+0x518>
    392e:	88 37       	cpi	r24, 0x78	; 120
    3930:	11 f0       	breq	.+4      	; 0x3936 <vfprintf+0x51a>
    3932:	b9 c0       	rjmp	.+370    	; 0x3aa6 <vfprintf+0x68a>
    3934:	00 61       	ori	r16, 0x10	; 16
    3936:	04 ff       	sbrs	r16, 4
    3938:	09 c0       	rjmp	.+18     	; 0x394c <vfprintf+0x530>
    393a:	04 60       	ori	r16, 0x04	; 4
    393c:	07 c0       	rjmp	.+14     	; 0x394c <vfprintf+0x530>
    393e:	24 ff       	sbrs	r18, 4
    3940:	08 c0       	rjmp	.+16     	; 0x3952 <vfprintf+0x536>
    3942:	06 60       	ori	r16, 0x06	; 6
    3944:	06 c0       	rjmp	.+12     	; 0x3952 <vfprintf+0x536>
    3946:	28 e0       	ldi	r18, 0x08	; 8
    3948:	30 e0       	ldi	r19, 0x00	; 0
    394a:	05 c0       	rjmp	.+10     	; 0x3956 <vfprintf+0x53a>
    394c:	20 e1       	ldi	r18, 0x10	; 16
    394e:	30 e0       	ldi	r19, 0x00	; 0
    3950:	02 c0       	rjmp	.+4      	; 0x3956 <vfprintf+0x53a>
    3952:	20 e1       	ldi	r18, 0x10	; 16
    3954:	32 e0       	ldi	r19, 0x02	; 2
    3956:	52 01       	movw	r10, r4
    3958:	07 ff       	sbrs	r16, 7
    395a:	09 c0       	rjmp	.+18     	; 0x396e <vfprintf+0x552>
    395c:	f4 e0       	ldi	r31, 0x04	; 4
    395e:	af 0e       	add	r10, r31
    3960:	b1 1c       	adc	r11, r1
    3962:	f2 01       	movw	r30, r4
    3964:	60 81       	ld	r22, Z
    3966:	71 81       	ldd	r23, Z+1	; 0x01
    3968:	82 81       	ldd	r24, Z+2	; 0x02
    396a:	93 81       	ldd	r25, Z+3	; 0x03
    396c:	08 c0       	rjmp	.+16     	; 0x397e <vfprintf+0x562>
    396e:	f2 e0       	ldi	r31, 0x02	; 2
    3970:	af 0e       	add	r10, r31
    3972:	b1 1c       	adc	r11, r1
    3974:	f2 01       	movw	r30, r4
    3976:	60 81       	ld	r22, Z
    3978:	71 81       	ldd	r23, Z+1	; 0x01
    397a:	80 e0       	ldi	r24, 0x00	; 0
    397c:	90 e0       	ldi	r25, 0x00	; 0
    397e:	a3 01       	movw	r20, r6
    3980:	83 d3       	rcall	.+1798   	; 0x4088 <__ultoa_invert>
    3982:	e8 2e       	mov	r14, r24
    3984:	e6 18       	sub	r14, r6
    3986:	0f 77       	andi	r16, 0x7F	; 127
    3988:	30 2e       	mov	r3, r16
    398a:	36 fe       	sbrs	r3, 6
    398c:	0b c0       	rjmp	.+22     	; 0x39a4 <vfprintf+0x588>
    398e:	33 2d       	mov	r19, r3
    3990:	3e 7f       	andi	r19, 0xFE	; 254
    3992:	e1 16       	cp	r14, r17
    3994:	50 f4       	brcc	.+20     	; 0x39aa <vfprintf+0x58e>
    3996:	34 fe       	sbrs	r3, 4
    3998:	0a c0       	rjmp	.+20     	; 0x39ae <vfprintf+0x592>
    399a:	32 fc       	sbrc	r3, 2
    399c:	08 c0       	rjmp	.+16     	; 0x39ae <vfprintf+0x592>
    399e:	33 2d       	mov	r19, r3
    39a0:	3e 7e       	andi	r19, 0xEE	; 238
    39a2:	05 c0       	rjmp	.+10     	; 0x39ae <vfprintf+0x592>
    39a4:	0e 2d       	mov	r16, r14
    39a6:	33 2d       	mov	r19, r3
    39a8:	03 c0       	rjmp	.+6      	; 0x39b0 <vfprintf+0x594>
    39aa:	0e 2d       	mov	r16, r14
    39ac:	01 c0       	rjmp	.+2      	; 0x39b0 <vfprintf+0x594>
    39ae:	01 2f       	mov	r16, r17
    39b0:	34 ff       	sbrs	r19, 4
    39b2:	0c c0       	rjmp	.+24     	; 0x39cc <vfprintf+0x5b0>
    39b4:	fe 01       	movw	r30, r28
    39b6:	ee 0d       	add	r30, r14
    39b8:	f1 1d       	adc	r31, r1
    39ba:	80 81       	ld	r24, Z
    39bc:	80 33       	cpi	r24, 0x30	; 48
    39be:	11 f4       	brne	.+4      	; 0x39c4 <vfprintf+0x5a8>
    39c0:	39 7e       	andi	r19, 0xE9	; 233
    39c2:	08 c0       	rjmp	.+16     	; 0x39d4 <vfprintf+0x5b8>
    39c4:	32 ff       	sbrs	r19, 2
    39c6:	05 c0       	rjmp	.+10     	; 0x39d2 <vfprintf+0x5b6>
    39c8:	0e 5f       	subi	r16, 0xFE	; 254
    39ca:	04 c0       	rjmp	.+8      	; 0x39d4 <vfprintf+0x5b8>
    39cc:	83 2f       	mov	r24, r19
    39ce:	86 78       	andi	r24, 0x86	; 134
    39d0:	09 f0       	breq	.+2      	; 0x39d4 <vfprintf+0x5b8>
    39d2:	0f 5f       	subi	r16, 0xFF	; 255
    39d4:	33 fd       	sbrc	r19, 3
    39d6:	12 c0       	rjmp	.+36     	; 0x39fc <vfprintf+0x5e0>
    39d8:	30 ff       	sbrs	r19, 0
    39da:	06 c0       	rjmp	.+12     	; 0x39e8 <vfprintf+0x5cc>
    39dc:	1e 2d       	mov	r17, r14
    39de:	0f 15       	cp	r16, r15
    39e0:	18 f4       	brcc	.+6      	; 0x39e8 <vfprintf+0x5cc>
    39e2:	1f 0d       	add	r17, r15
    39e4:	10 1b       	sub	r17, r16
    39e6:	0f 2d       	mov	r16, r15
    39e8:	0f 15       	cp	r16, r15
    39ea:	60 f4       	brcc	.+24     	; 0x3a04 <vfprintf+0x5e8>
    39ec:	b6 01       	movw	r22, r12
    39ee:	80 e2       	ldi	r24, 0x20	; 32
    39f0:	90 e0       	ldi	r25, 0x00	; 0
    39f2:	3b 8b       	std	Y+19, r19	; 0x13
    39f4:	ce d2       	rcall	.+1436   	; 0x3f92 <fputc>
    39f6:	0f 5f       	subi	r16, 0xFF	; 255
    39f8:	3b 89       	ldd	r19, Y+19	; 0x13
    39fa:	f6 cf       	rjmp	.-20     	; 0x39e8 <vfprintf+0x5cc>
    39fc:	0f 15       	cp	r16, r15
    39fe:	10 f4       	brcc	.+4      	; 0x3a04 <vfprintf+0x5e8>
    3a00:	f0 1a       	sub	r15, r16
    3a02:	01 c0       	rjmp	.+2      	; 0x3a06 <vfprintf+0x5ea>
    3a04:	f1 2c       	mov	r15, r1
    3a06:	34 ff       	sbrs	r19, 4
    3a08:	11 c0       	rjmp	.+34     	; 0x3a2c <vfprintf+0x610>
    3a0a:	b6 01       	movw	r22, r12
    3a0c:	80 e3       	ldi	r24, 0x30	; 48
    3a0e:	90 e0       	ldi	r25, 0x00	; 0
    3a10:	3b 8b       	std	Y+19, r19	; 0x13
    3a12:	bf d2       	rcall	.+1406   	; 0x3f92 <fputc>
    3a14:	3b 89       	ldd	r19, Y+19	; 0x13
    3a16:	32 ff       	sbrs	r19, 2
    3a18:	16 c0       	rjmp	.+44     	; 0x3a46 <vfprintf+0x62a>
    3a1a:	31 fd       	sbrc	r19, 1
    3a1c:	03 c0       	rjmp	.+6      	; 0x3a24 <vfprintf+0x608>
    3a1e:	88 e7       	ldi	r24, 0x78	; 120
    3a20:	90 e0       	ldi	r25, 0x00	; 0
    3a22:	02 c0       	rjmp	.+4      	; 0x3a28 <vfprintf+0x60c>
    3a24:	88 e5       	ldi	r24, 0x58	; 88
    3a26:	90 e0       	ldi	r25, 0x00	; 0
    3a28:	b6 01       	movw	r22, r12
    3a2a:	0c c0       	rjmp	.+24     	; 0x3a44 <vfprintf+0x628>
    3a2c:	83 2f       	mov	r24, r19
    3a2e:	86 78       	andi	r24, 0x86	; 134
    3a30:	51 f0       	breq	.+20     	; 0x3a46 <vfprintf+0x62a>
    3a32:	31 ff       	sbrs	r19, 1
    3a34:	02 c0       	rjmp	.+4      	; 0x3a3a <vfprintf+0x61e>
    3a36:	8b e2       	ldi	r24, 0x2B	; 43
    3a38:	01 c0       	rjmp	.+2      	; 0x3a3c <vfprintf+0x620>
    3a3a:	80 e2       	ldi	r24, 0x20	; 32
    3a3c:	37 fd       	sbrc	r19, 7
    3a3e:	8d e2       	ldi	r24, 0x2D	; 45
    3a40:	b6 01       	movw	r22, r12
    3a42:	90 e0       	ldi	r25, 0x00	; 0
    3a44:	a6 d2       	rcall	.+1356   	; 0x3f92 <fputc>
    3a46:	e1 16       	cp	r14, r17
    3a48:	30 f4       	brcc	.+12     	; 0x3a56 <vfprintf+0x63a>
    3a4a:	b6 01       	movw	r22, r12
    3a4c:	80 e3       	ldi	r24, 0x30	; 48
    3a4e:	90 e0       	ldi	r25, 0x00	; 0
    3a50:	a0 d2       	rcall	.+1344   	; 0x3f92 <fputc>
    3a52:	11 50       	subi	r17, 0x01	; 1
    3a54:	f8 cf       	rjmp	.-16     	; 0x3a46 <vfprintf+0x62a>
    3a56:	ea 94       	dec	r14
    3a58:	f3 01       	movw	r30, r6
    3a5a:	ee 0d       	add	r30, r14
    3a5c:	f1 1d       	adc	r31, r1
    3a5e:	80 81       	ld	r24, Z
    3a60:	b6 01       	movw	r22, r12
    3a62:	90 e0       	ldi	r25, 0x00	; 0
    3a64:	96 d2       	rcall	.+1324   	; 0x3f92 <fputc>
    3a66:	e1 10       	cpse	r14, r1
    3a68:	f6 cf       	rjmp	.-20     	; 0x3a56 <vfprintf+0x63a>
    3a6a:	14 c0       	rjmp	.+40     	; 0x3a94 <vfprintf+0x678>
    3a6c:	f4 e0       	ldi	r31, 0x04	; 4
    3a6e:	ff 15       	cp	r31, r15
    3a70:	48 f5       	brcc	.+82     	; 0x3ac4 <vfprintf+0x6a8>
    3a72:	84 e0       	ldi	r24, 0x04	; 4
    3a74:	f8 1a       	sub	r15, r24
    3a76:	33 fe       	sbrs	r3, 3
    3a78:	1d c0       	rjmp	.+58     	; 0x3ab4 <vfprintf+0x698>
    3a7a:	21 10       	cpse	r2, r1
    3a7c:	24 c0       	rjmp	.+72     	; 0x3ac6 <vfprintf+0x6aa>
    3a7e:	03 ff       	sbrs	r16, 3
    3a80:	27 c0       	rjmp	.+78     	; 0x3ad0 <vfprintf+0x6b4>
    3a82:	0e e4       	ldi	r16, 0x4E	; 78
    3a84:	12 e0       	ldi	r17, 0x02	; 2
    3a86:	f3 2d       	mov	r31, r3
    3a88:	f0 71       	andi	r31, 0x10	; 16
    3a8a:	3f 2e       	mov	r3, r31
    3a8c:	f8 01       	movw	r30, r16
    3a8e:	84 91       	lpm	r24, Z
    3a90:	81 11       	cpse	r24, r1
    3a92:	21 c0       	rjmp	.+66     	; 0x3ad6 <vfprintf+0x6ba>
    3a94:	ff 20       	and	r15, r15
    3a96:	09 f4       	brne	.+2      	; 0x3a9a <vfprintf+0x67e>
    3a98:	fd cc       	rjmp	.-1542   	; 0x3494 <vfprintf+0x78>
    3a9a:	b6 01       	movw	r22, r12
    3a9c:	80 e2       	ldi	r24, 0x20	; 32
    3a9e:	90 e0       	ldi	r25, 0x00	; 0
    3aa0:	78 d2       	rcall	.+1264   	; 0x3f92 <fputc>
    3aa2:	fa 94       	dec	r15
    3aa4:	f7 cf       	rjmp	.-18     	; 0x3a94 <vfprintf+0x678>
    3aa6:	f6 01       	movw	r30, r12
    3aa8:	86 81       	ldd	r24, Z+6	; 0x06
    3aaa:	97 81       	ldd	r25, Z+7	; 0x07
    3aac:	23 c0       	rjmp	.+70     	; 0x3af4 <vfprintf+0x6d8>
    3aae:	8f ef       	ldi	r24, 0xFF	; 255
    3ab0:	9f ef       	ldi	r25, 0xFF	; 255
    3ab2:	20 c0       	rjmp	.+64     	; 0x3af4 <vfprintf+0x6d8>
    3ab4:	b6 01       	movw	r22, r12
    3ab6:	80 e2       	ldi	r24, 0x20	; 32
    3ab8:	90 e0       	ldi	r25, 0x00	; 0
    3aba:	6b d2       	rcall	.+1238   	; 0x3f92 <fputc>
    3abc:	fa 94       	dec	r15
    3abe:	f1 10       	cpse	r15, r1
    3ac0:	f9 cf       	rjmp	.-14     	; 0x3ab4 <vfprintf+0x698>
    3ac2:	db cf       	rjmp	.-74     	; 0x3a7a <vfprintf+0x65e>
    3ac4:	f1 2c       	mov	r15, r1
    3ac6:	b6 01       	movw	r22, r12
    3ac8:	82 2d       	mov	r24, r2
    3aca:	90 e0       	ldi	r25, 0x00	; 0
    3acc:	62 d2       	rcall	.+1220   	; 0x3f92 <fputc>
    3ace:	d7 cf       	rjmp	.-82     	; 0x3a7e <vfprintf+0x662>
    3ad0:	02 e5       	ldi	r16, 0x52	; 82
    3ad2:	12 e0       	ldi	r17, 0x02	; 2
    3ad4:	d8 cf       	rjmp	.-80     	; 0x3a86 <vfprintf+0x66a>
    3ad6:	31 10       	cpse	r3, r1
    3ad8:	80 52       	subi	r24, 0x20	; 32
    3ada:	b6 01       	movw	r22, r12
    3adc:	90 e0       	ldi	r25, 0x00	; 0
    3ade:	59 d2       	rcall	.+1202   	; 0x3f92 <fputc>
    3ae0:	0f 5f       	subi	r16, 0xFF	; 255
    3ae2:	1f 4f       	sbci	r17, 0xFF	; 255
    3ae4:	d3 cf       	rjmp	.-90     	; 0x3a8c <vfprintf+0x670>
    3ae6:	23 e0       	ldi	r18, 0x03	; 3
    3ae8:	2f 15       	cp	r18, r15
    3aea:	10 f4       	brcc	.+4      	; 0x3af0 <vfprintf+0x6d4>
    3aec:	83 e0       	ldi	r24, 0x03	; 3
    3aee:	c2 cf       	rjmp	.-124    	; 0x3a74 <vfprintf+0x658>
    3af0:	f1 2c       	mov	r15, r1
    3af2:	c5 cf       	rjmp	.-118    	; 0x3a7e <vfprintf+0x662>
    3af4:	63 96       	adiw	r28, 0x13	; 19
    3af6:	cd bf       	out	0x3d, r28	; 61
    3af8:	de bf       	out	0x3e, r29	; 62
    3afa:	df 91       	pop	r29
    3afc:	cf 91       	pop	r28
    3afe:	1f 91       	pop	r17
    3b00:	0f 91       	pop	r16
    3b02:	ff 90       	pop	r15
    3b04:	ef 90       	pop	r14
    3b06:	df 90       	pop	r13
    3b08:	cf 90       	pop	r12
    3b0a:	bf 90       	pop	r11
    3b0c:	af 90       	pop	r10
    3b0e:	9f 90       	pop	r9
    3b10:	8f 90       	pop	r8
    3b12:	7f 90       	pop	r7
    3b14:	6f 90       	pop	r6
    3b16:	5f 90       	pop	r5
    3b18:	4f 90       	pop	r4
    3b1a:	3f 90       	pop	r3
    3b1c:	2f 90       	pop	r2
    3b1e:	08 95       	ret

00003b20 <__udivmodhi4>:
    3b20:	aa 1b       	sub	r26, r26
    3b22:	bb 1b       	sub	r27, r27
    3b24:	51 e1       	ldi	r21, 0x11	; 17
    3b26:	07 c0       	rjmp	.+14     	; 0x3b36 <__udivmodhi4_ep>

00003b28 <__udivmodhi4_loop>:
    3b28:	aa 1f       	adc	r26, r26
    3b2a:	bb 1f       	adc	r27, r27
    3b2c:	a6 17       	cp	r26, r22
    3b2e:	b7 07       	cpc	r27, r23
    3b30:	10 f0       	brcs	.+4      	; 0x3b36 <__udivmodhi4_ep>
    3b32:	a6 1b       	sub	r26, r22
    3b34:	b7 0b       	sbc	r27, r23

00003b36 <__udivmodhi4_ep>:
    3b36:	88 1f       	adc	r24, r24
    3b38:	99 1f       	adc	r25, r25
    3b3a:	5a 95       	dec	r21
    3b3c:	a9 f7       	brne	.-22     	; 0x3b28 <__udivmodhi4_loop>
    3b3e:	80 95       	com	r24
    3b40:	90 95       	com	r25
    3b42:	bc 01       	movw	r22, r24
    3b44:	cd 01       	movw	r24, r26
    3b46:	08 95       	ret

00003b48 <__udivmodsi4>:
    3b48:	a1 e2       	ldi	r26, 0x21	; 33
    3b4a:	1a 2e       	mov	r1, r26
    3b4c:	aa 1b       	sub	r26, r26
    3b4e:	bb 1b       	sub	r27, r27
    3b50:	fd 01       	movw	r30, r26
    3b52:	0d c0       	rjmp	.+26     	; 0x3b6e <__udivmodsi4_ep>

00003b54 <__udivmodsi4_loop>:
    3b54:	aa 1f       	adc	r26, r26
    3b56:	bb 1f       	adc	r27, r27
    3b58:	ee 1f       	adc	r30, r30
    3b5a:	ff 1f       	adc	r31, r31
    3b5c:	a2 17       	cp	r26, r18
    3b5e:	b3 07       	cpc	r27, r19
    3b60:	e4 07       	cpc	r30, r20
    3b62:	f5 07       	cpc	r31, r21
    3b64:	20 f0       	brcs	.+8      	; 0x3b6e <__udivmodsi4_ep>
    3b66:	a2 1b       	sub	r26, r18
    3b68:	b3 0b       	sbc	r27, r19
    3b6a:	e4 0b       	sbc	r30, r20
    3b6c:	f5 0b       	sbc	r31, r21

00003b6e <__udivmodsi4_ep>:
    3b6e:	66 1f       	adc	r22, r22
    3b70:	77 1f       	adc	r23, r23
    3b72:	88 1f       	adc	r24, r24
    3b74:	99 1f       	adc	r25, r25
    3b76:	1a 94       	dec	r1
    3b78:	69 f7       	brne	.-38     	; 0x3b54 <__udivmodsi4_loop>
    3b7a:	60 95       	com	r22
    3b7c:	70 95       	com	r23
    3b7e:	80 95       	com	r24
    3b80:	90 95       	com	r25
    3b82:	9b 01       	movw	r18, r22
    3b84:	ac 01       	movw	r20, r24
    3b86:	bd 01       	movw	r22, r26
    3b88:	cf 01       	movw	r24, r30
    3b8a:	08 95       	ret

00003b8c <__muluhisi3>:
    3b8c:	bb d0       	rcall	.+374    	; 0x3d04 <__umulhisi3>
    3b8e:	a5 9f       	mul	r26, r21
    3b90:	90 0d       	add	r25, r0
    3b92:	b4 9f       	mul	r27, r20
    3b94:	90 0d       	add	r25, r0
    3b96:	a4 9f       	mul	r26, r20
    3b98:	80 0d       	add	r24, r0
    3b9a:	91 1d       	adc	r25, r1
    3b9c:	11 24       	eor	r1, r1
    3b9e:	08 95       	ret

00003ba0 <__muldi3>:
    3ba0:	df 93       	push	r29
    3ba2:	cf 93       	push	r28
    3ba4:	1f 93       	push	r17
    3ba6:	0f 93       	push	r16
    3ba8:	9a 9d       	mul	r25, r10
    3baa:	f0 2d       	mov	r31, r0
    3bac:	21 9f       	mul	r18, r17
    3bae:	f0 0d       	add	r31, r0
    3bb0:	8b 9d       	mul	r24, r11
    3bb2:	f0 0d       	add	r31, r0
    3bb4:	8a 9d       	mul	r24, r10
    3bb6:	e0 2d       	mov	r30, r0
    3bb8:	f1 0d       	add	r31, r1
    3bba:	03 9f       	mul	r16, r19
    3bbc:	f0 0d       	add	r31, r0
    3bbe:	02 9f       	mul	r16, r18
    3bc0:	e0 0d       	add	r30, r0
    3bc2:	f1 1d       	adc	r31, r1
    3bc4:	4e 9d       	mul	r20, r14
    3bc6:	e0 0d       	add	r30, r0
    3bc8:	f1 1d       	adc	r31, r1
    3bca:	5e 9d       	mul	r21, r14
    3bcc:	f0 0d       	add	r31, r0
    3bce:	4f 9d       	mul	r20, r15
    3bd0:	f0 0d       	add	r31, r0
    3bd2:	7f 93       	push	r23
    3bd4:	6f 93       	push	r22
    3bd6:	bf 92       	push	r11
    3bd8:	af 92       	push	r10
    3bda:	5f 93       	push	r21
    3bdc:	4f 93       	push	r20
    3bde:	d5 01       	movw	r26, r10
    3be0:	91 d0       	rcall	.+290    	; 0x3d04 <__umulhisi3>
    3be2:	8b 01       	movw	r16, r22
    3be4:	ac 01       	movw	r20, r24
    3be6:	d7 01       	movw	r26, r14
    3be8:	8d d0       	rcall	.+282    	; 0x3d04 <__umulhisi3>
    3bea:	eb 01       	movw	r28, r22
    3bec:	e8 0f       	add	r30, r24
    3bee:	f9 1f       	adc	r31, r25
    3bf0:	d6 01       	movw	r26, r12
    3bf2:	1f d0       	rcall	.+62     	; 0x3c32 <__muldi3_6>
    3bf4:	2f 91       	pop	r18
    3bf6:	3f 91       	pop	r19
    3bf8:	d6 01       	movw	r26, r12
    3bfa:	84 d0       	rcall	.+264    	; 0x3d04 <__umulhisi3>
    3bfc:	c6 0f       	add	r28, r22
    3bfe:	d7 1f       	adc	r29, r23
    3c00:	e8 1f       	adc	r30, r24
    3c02:	f9 1f       	adc	r31, r25
    3c04:	af 91       	pop	r26
    3c06:	bf 91       	pop	r27
    3c08:	14 d0       	rcall	.+40     	; 0x3c32 <__muldi3_6>
    3c0a:	2f 91       	pop	r18
    3c0c:	3f 91       	pop	r19
    3c0e:	7a d0       	rcall	.+244    	; 0x3d04 <__umulhisi3>
    3c10:	c6 0f       	add	r28, r22
    3c12:	d7 1f       	adc	r29, r23
    3c14:	e8 1f       	adc	r30, r24
    3c16:	f9 1f       	adc	r31, r25
    3c18:	d6 01       	movw	r26, r12
    3c1a:	74 d0       	rcall	.+232    	; 0x3d04 <__umulhisi3>
    3c1c:	e6 0f       	add	r30, r22
    3c1e:	f7 1f       	adc	r31, r23
    3c20:	98 01       	movw	r18, r16
    3c22:	be 01       	movw	r22, r28
    3c24:	cf 01       	movw	r24, r30
    3c26:	11 24       	eor	r1, r1
    3c28:	0f 91       	pop	r16
    3c2a:	1f 91       	pop	r17
    3c2c:	cf 91       	pop	r28
    3c2e:	df 91       	pop	r29
    3c30:	08 95       	ret

00003c32 <__muldi3_6>:
    3c32:	68 d0       	rcall	.+208    	; 0x3d04 <__umulhisi3>
    3c34:	46 0f       	add	r20, r22
    3c36:	57 1f       	adc	r21, r23
    3c38:	c8 1f       	adc	r28, r24
    3c3a:	d9 1f       	adc	r29, r25
    3c3c:	08 f4       	brcc	.+2      	; 0x3c40 <__muldi3_6+0xe>
    3c3e:	31 96       	adiw	r30, 0x01	; 1
    3c40:	08 95       	ret

00003c42 <__ashldi3>:
    3c42:	0f 93       	push	r16
    3c44:	08 30       	cpi	r16, 0x08	; 8
    3c46:	90 f0       	brcs	.+36     	; 0x3c6c <__ashldi3+0x2a>
    3c48:	98 2f       	mov	r25, r24
    3c4a:	87 2f       	mov	r24, r23
    3c4c:	76 2f       	mov	r23, r22
    3c4e:	65 2f       	mov	r22, r21
    3c50:	54 2f       	mov	r21, r20
    3c52:	43 2f       	mov	r20, r19
    3c54:	32 2f       	mov	r19, r18
    3c56:	22 27       	eor	r18, r18
    3c58:	08 50       	subi	r16, 0x08	; 8
    3c5a:	f4 cf       	rjmp	.-24     	; 0x3c44 <__ashldi3+0x2>
    3c5c:	22 0f       	add	r18, r18
    3c5e:	33 1f       	adc	r19, r19
    3c60:	44 1f       	adc	r20, r20
    3c62:	55 1f       	adc	r21, r21
    3c64:	66 1f       	adc	r22, r22
    3c66:	77 1f       	adc	r23, r23
    3c68:	88 1f       	adc	r24, r24
    3c6a:	99 1f       	adc	r25, r25
    3c6c:	0a 95       	dec	r16
    3c6e:	b2 f7       	brpl	.-20     	; 0x3c5c <__ashldi3+0x1a>
    3c70:	0f 91       	pop	r16
    3c72:	08 95       	ret

00003c74 <__ashrdi3>:
    3c74:	97 fb       	bst	r25, 7
    3c76:	10 f8       	bld	r1, 0

00003c78 <__lshrdi3>:
    3c78:	16 94       	lsr	r1
    3c7a:	00 08       	sbc	r0, r0
    3c7c:	0f 93       	push	r16
    3c7e:	08 30       	cpi	r16, 0x08	; 8
    3c80:	98 f0       	brcs	.+38     	; 0x3ca8 <__lshrdi3+0x30>
    3c82:	08 50       	subi	r16, 0x08	; 8
    3c84:	23 2f       	mov	r18, r19
    3c86:	34 2f       	mov	r19, r20
    3c88:	45 2f       	mov	r20, r21
    3c8a:	56 2f       	mov	r21, r22
    3c8c:	67 2f       	mov	r22, r23
    3c8e:	78 2f       	mov	r23, r24
    3c90:	89 2f       	mov	r24, r25
    3c92:	90 2d       	mov	r25, r0
    3c94:	f4 cf       	rjmp	.-24     	; 0x3c7e <__lshrdi3+0x6>
    3c96:	05 94       	asr	r0
    3c98:	97 95       	ror	r25
    3c9a:	87 95       	ror	r24
    3c9c:	77 95       	ror	r23
    3c9e:	67 95       	ror	r22
    3ca0:	57 95       	ror	r21
    3ca2:	47 95       	ror	r20
    3ca4:	37 95       	ror	r19
    3ca6:	27 95       	ror	r18
    3ca8:	0a 95       	dec	r16
    3caa:	aa f7       	brpl	.-22     	; 0x3c96 <__lshrdi3+0x1e>
    3cac:	0f 91       	pop	r16
    3cae:	08 95       	ret

00003cb0 <__adddi3>:
    3cb0:	2a 0d       	add	r18, r10
    3cb2:	3b 1d       	adc	r19, r11
    3cb4:	4c 1d       	adc	r20, r12
    3cb6:	5d 1d       	adc	r21, r13
    3cb8:	6e 1d       	adc	r22, r14
    3cba:	7f 1d       	adc	r23, r15
    3cbc:	80 1f       	adc	r24, r16
    3cbe:	91 1f       	adc	r25, r17
    3cc0:	08 95       	ret

00003cc2 <__adddi3_s8>:
    3cc2:	00 24       	eor	r0, r0
    3cc4:	a7 fd       	sbrc	r26, 7
    3cc6:	00 94       	com	r0
    3cc8:	2a 0f       	add	r18, r26
    3cca:	30 1d       	adc	r19, r0
    3ccc:	40 1d       	adc	r20, r0
    3cce:	50 1d       	adc	r21, r0
    3cd0:	60 1d       	adc	r22, r0
    3cd2:	70 1d       	adc	r23, r0
    3cd4:	80 1d       	adc	r24, r0
    3cd6:	90 1d       	adc	r25, r0
    3cd8:	08 95       	ret

00003cda <__subdi3>:
    3cda:	2a 19       	sub	r18, r10
    3cdc:	3b 09       	sbc	r19, r11
    3cde:	4c 09       	sbc	r20, r12
    3ce0:	5d 09       	sbc	r21, r13
    3ce2:	6e 09       	sbc	r22, r14
    3ce4:	7f 09       	sbc	r23, r15
    3ce6:	80 0b       	sbc	r24, r16
    3ce8:	91 0b       	sbc	r25, r17
    3cea:	08 95       	ret

00003cec <__cmpdi2_s8>:
    3cec:	00 24       	eor	r0, r0
    3cee:	a7 fd       	sbrc	r26, 7
    3cf0:	00 94       	com	r0
    3cf2:	2a 17       	cp	r18, r26
    3cf4:	30 05       	cpc	r19, r0
    3cf6:	40 05       	cpc	r20, r0
    3cf8:	50 05       	cpc	r21, r0
    3cfa:	60 05       	cpc	r22, r0
    3cfc:	70 05       	cpc	r23, r0
    3cfe:	80 05       	cpc	r24, r0
    3d00:	90 05       	cpc	r25, r0
    3d02:	08 95       	ret

00003d04 <__umulhisi3>:
    3d04:	a2 9f       	mul	r26, r18
    3d06:	b0 01       	movw	r22, r0
    3d08:	b3 9f       	mul	r27, r19
    3d0a:	c0 01       	movw	r24, r0
    3d0c:	a3 9f       	mul	r26, r19
    3d0e:	70 0d       	add	r23, r0
    3d10:	81 1d       	adc	r24, r1
    3d12:	11 24       	eor	r1, r1
    3d14:	91 1d       	adc	r25, r1
    3d16:	b2 9f       	mul	r27, r18
    3d18:	70 0d       	add	r23, r0
    3d1a:	81 1d       	adc	r24, r1
    3d1c:	11 24       	eor	r1, r1
    3d1e:	91 1d       	adc	r25, r1
    3d20:	08 95       	ret

00003d22 <__ftoa_engine>:
    3d22:	28 30       	cpi	r18, 0x08	; 8
    3d24:	08 f0       	brcs	.+2      	; 0x3d28 <__ftoa_engine+0x6>
    3d26:	27 e0       	ldi	r18, 0x07	; 7
    3d28:	33 27       	eor	r19, r19
    3d2a:	da 01       	movw	r26, r20
    3d2c:	99 0f       	add	r25, r25
    3d2e:	31 1d       	adc	r19, r1
    3d30:	87 fd       	sbrc	r24, 7
    3d32:	91 60       	ori	r25, 0x01	; 1
    3d34:	00 96       	adiw	r24, 0x00	; 0
    3d36:	61 05       	cpc	r22, r1
    3d38:	71 05       	cpc	r23, r1
    3d3a:	39 f4       	brne	.+14     	; 0x3d4a <__ftoa_engine+0x28>
    3d3c:	32 60       	ori	r19, 0x02	; 2
    3d3e:	2e 5f       	subi	r18, 0xFE	; 254
    3d40:	3d 93       	st	X+, r19
    3d42:	30 e3       	ldi	r19, 0x30	; 48
    3d44:	2a 95       	dec	r18
    3d46:	e1 f7       	brne	.-8      	; 0x3d40 <__ftoa_engine+0x1e>
    3d48:	08 95       	ret
    3d4a:	9f 3f       	cpi	r25, 0xFF	; 255
    3d4c:	30 f0       	brcs	.+12     	; 0x3d5a <__ftoa_engine+0x38>
    3d4e:	80 38       	cpi	r24, 0x80	; 128
    3d50:	71 05       	cpc	r23, r1
    3d52:	61 05       	cpc	r22, r1
    3d54:	09 f0       	breq	.+2      	; 0x3d58 <__ftoa_engine+0x36>
    3d56:	3c 5f       	subi	r19, 0xFC	; 252
    3d58:	3c 5f       	subi	r19, 0xFC	; 252
    3d5a:	3d 93       	st	X+, r19
    3d5c:	91 30       	cpi	r25, 0x01	; 1
    3d5e:	08 f0       	brcs	.+2      	; 0x3d62 <__ftoa_engine+0x40>
    3d60:	80 68       	ori	r24, 0x80	; 128
    3d62:	91 1d       	adc	r25, r1
    3d64:	df 93       	push	r29
    3d66:	cf 93       	push	r28
    3d68:	1f 93       	push	r17
    3d6a:	0f 93       	push	r16
    3d6c:	ff 92       	push	r15
    3d6e:	ef 92       	push	r14
    3d70:	19 2f       	mov	r17, r25
    3d72:	98 7f       	andi	r25, 0xF8	; 248
    3d74:	96 95       	lsr	r25
    3d76:	e9 2f       	mov	r30, r25
    3d78:	96 95       	lsr	r25
    3d7a:	96 95       	lsr	r25
    3d7c:	e9 0f       	add	r30, r25
    3d7e:	ff 27       	eor	r31, r31
    3d80:	e0 55       	subi	r30, 0x50	; 80
    3d82:	fd 4f       	sbci	r31, 0xFD	; 253
    3d84:	99 27       	eor	r25, r25
    3d86:	33 27       	eor	r19, r19
    3d88:	ee 24       	eor	r14, r14
    3d8a:	ff 24       	eor	r15, r15
    3d8c:	a7 01       	movw	r20, r14
    3d8e:	e7 01       	movw	r28, r14
    3d90:	05 90       	lpm	r0, Z+
    3d92:	08 94       	sec
    3d94:	07 94       	ror	r0
    3d96:	28 f4       	brcc	.+10     	; 0x3da2 <__ftoa_engine+0x80>
    3d98:	36 0f       	add	r19, r22
    3d9a:	e7 1e       	adc	r14, r23
    3d9c:	f8 1e       	adc	r15, r24
    3d9e:	49 1f       	adc	r20, r25
    3da0:	51 1d       	adc	r21, r1
    3da2:	66 0f       	add	r22, r22
    3da4:	77 1f       	adc	r23, r23
    3da6:	88 1f       	adc	r24, r24
    3da8:	99 1f       	adc	r25, r25
    3daa:	06 94       	lsr	r0
    3dac:	a1 f7       	brne	.-24     	; 0x3d96 <__ftoa_engine+0x74>
    3dae:	05 90       	lpm	r0, Z+
    3db0:	07 94       	ror	r0
    3db2:	28 f4       	brcc	.+10     	; 0x3dbe <__ftoa_engine+0x9c>
    3db4:	e7 0e       	add	r14, r23
    3db6:	f8 1e       	adc	r15, r24
    3db8:	49 1f       	adc	r20, r25
    3dba:	56 1f       	adc	r21, r22
    3dbc:	c1 1d       	adc	r28, r1
    3dbe:	77 0f       	add	r23, r23
    3dc0:	88 1f       	adc	r24, r24
    3dc2:	99 1f       	adc	r25, r25
    3dc4:	66 1f       	adc	r22, r22
    3dc6:	06 94       	lsr	r0
    3dc8:	a1 f7       	brne	.-24     	; 0x3db2 <__ftoa_engine+0x90>
    3dca:	05 90       	lpm	r0, Z+
    3dcc:	07 94       	ror	r0
    3dce:	28 f4       	brcc	.+10     	; 0x3dda <__ftoa_engine+0xb8>
    3dd0:	f8 0e       	add	r15, r24
    3dd2:	49 1f       	adc	r20, r25
    3dd4:	56 1f       	adc	r21, r22
    3dd6:	c7 1f       	adc	r28, r23
    3dd8:	d1 1d       	adc	r29, r1
    3dda:	88 0f       	add	r24, r24
    3ddc:	99 1f       	adc	r25, r25
    3dde:	66 1f       	adc	r22, r22
    3de0:	77 1f       	adc	r23, r23
    3de2:	06 94       	lsr	r0
    3de4:	a1 f7       	brne	.-24     	; 0x3dce <__ftoa_engine+0xac>
    3de6:	05 90       	lpm	r0, Z+
    3de8:	07 94       	ror	r0
    3dea:	20 f4       	brcc	.+8      	; 0x3df4 <__ftoa_engine+0xd2>
    3dec:	49 0f       	add	r20, r25
    3dee:	56 1f       	adc	r21, r22
    3df0:	c7 1f       	adc	r28, r23
    3df2:	d8 1f       	adc	r29, r24
    3df4:	99 0f       	add	r25, r25
    3df6:	66 1f       	adc	r22, r22
    3df8:	77 1f       	adc	r23, r23
    3dfa:	88 1f       	adc	r24, r24
    3dfc:	06 94       	lsr	r0
    3dfe:	a9 f7       	brne	.-22     	; 0x3dea <__ftoa_engine+0xc8>
    3e00:	84 91       	lpm	r24, Z
    3e02:	10 95       	com	r17
    3e04:	17 70       	andi	r17, 0x07	; 7
    3e06:	41 f0       	breq	.+16     	; 0x3e18 <__ftoa_engine+0xf6>
    3e08:	d6 95       	lsr	r29
    3e0a:	c7 95       	ror	r28
    3e0c:	57 95       	ror	r21
    3e0e:	47 95       	ror	r20
    3e10:	f7 94       	ror	r15
    3e12:	e7 94       	ror	r14
    3e14:	1a 95       	dec	r17
    3e16:	c1 f7       	brne	.-16     	; 0x3e08 <__ftoa_engine+0xe6>
    3e18:	e6 e5       	ldi	r30, 0x56	; 86
    3e1a:	f2 e0       	ldi	r31, 0x02	; 2
    3e1c:	68 94       	set
    3e1e:	15 90       	lpm	r1, Z+
    3e20:	15 91       	lpm	r17, Z+
    3e22:	35 91       	lpm	r19, Z+
    3e24:	65 91       	lpm	r22, Z+
    3e26:	95 91       	lpm	r25, Z+
    3e28:	05 90       	lpm	r0, Z+
    3e2a:	7f e2       	ldi	r23, 0x2F	; 47
    3e2c:	73 95       	inc	r23
    3e2e:	e1 18       	sub	r14, r1
    3e30:	f1 0a       	sbc	r15, r17
    3e32:	43 0b       	sbc	r20, r19
    3e34:	56 0b       	sbc	r21, r22
    3e36:	c9 0b       	sbc	r28, r25
    3e38:	d0 09       	sbc	r29, r0
    3e3a:	c0 f7       	brcc	.-16     	; 0x3e2c <__ftoa_engine+0x10a>
    3e3c:	e1 0c       	add	r14, r1
    3e3e:	f1 1e       	adc	r15, r17
    3e40:	43 1f       	adc	r20, r19
    3e42:	56 1f       	adc	r21, r22
    3e44:	c9 1f       	adc	r28, r25
    3e46:	d0 1d       	adc	r29, r0
    3e48:	7e f4       	brtc	.+30     	; 0x3e68 <__ftoa_engine+0x146>
    3e4a:	70 33       	cpi	r23, 0x30	; 48
    3e4c:	11 f4       	brne	.+4      	; 0x3e52 <__ftoa_engine+0x130>
    3e4e:	8a 95       	dec	r24
    3e50:	e6 cf       	rjmp	.-52     	; 0x3e1e <__ftoa_engine+0xfc>
    3e52:	e8 94       	clt
    3e54:	01 50       	subi	r16, 0x01	; 1
    3e56:	30 f0       	brcs	.+12     	; 0x3e64 <__ftoa_engine+0x142>
    3e58:	08 0f       	add	r16, r24
    3e5a:	0a f4       	brpl	.+2      	; 0x3e5e <__ftoa_engine+0x13c>
    3e5c:	00 27       	eor	r16, r16
    3e5e:	02 17       	cp	r16, r18
    3e60:	08 f4       	brcc	.+2      	; 0x3e64 <__ftoa_engine+0x142>
    3e62:	20 2f       	mov	r18, r16
    3e64:	23 95       	inc	r18
    3e66:	02 2f       	mov	r16, r18
    3e68:	7a 33       	cpi	r23, 0x3A	; 58
    3e6a:	28 f0       	brcs	.+10     	; 0x3e76 <__ftoa_engine+0x154>
    3e6c:	79 e3       	ldi	r23, 0x39	; 57
    3e6e:	7d 93       	st	X+, r23
    3e70:	2a 95       	dec	r18
    3e72:	e9 f7       	brne	.-6      	; 0x3e6e <__ftoa_engine+0x14c>
    3e74:	10 c0       	rjmp	.+32     	; 0x3e96 <__ftoa_engine+0x174>
    3e76:	7d 93       	st	X+, r23
    3e78:	2a 95       	dec	r18
    3e7a:	89 f6       	brne	.-94     	; 0x3e1e <__ftoa_engine+0xfc>
    3e7c:	06 94       	lsr	r0
    3e7e:	97 95       	ror	r25
    3e80:	67 95       	ror	r22
    3e82:	37 95       	ror	r19
    3e84:	17 95       	ror	r17
    3e86:	17 94       	ror	r1
    3e88:	e1 18       	sub	r14, r1
    3e8a:	f1 0a       	sbc	r15, r17
    3e8c:	43 0b       	sbc	r20, r19
    3e8e:	56 0b       	sbc	r21, r22
    3e90:	c9 0b       	sbc	r28, r25
    3e92:	d0 09       	sbc	r29, r0
    3e94:	98 f0       	brcs	.+38     	; 0x3ebc <__ftoa_engine+0x19a>
    3e96:	23 95       	inc	r18
    3e98:	7e 91       	ld	r23, -X
    3e9a:	73 95       	inc	r23
    3e9c:	7a 33       	cpi	r23, 0x3A	; 58
    3e9e:	08 f0       	brcs	.+2      	; 0x3ea2 <__ftoa_engine+0x180>
    3ea0:	70 e3       	ldi	r23, 0x30	; 48
    3ea2:	7c 93       	st	X, r23
    3ea4:	20 13       	cpse	r18, r16
    3ea6:	b8 f7       	brcc	.-18     	; 0x3e96 <__ftoa_engine+0x174>
    3ea8:	7e 91       	ld	r23, -X
    3eaa:	70 61       	ori	r23, 0x10	; 16
    3eac:	7d 93       	st	X+, r23
    3eae:	30 f0       	brcs	.+12     	; 0x3ebc <__ftoa_engine+0x19a>
    3eb0:	83 95       	inc	r24
    3eb2:	71 e3       	ldi	r23, 0x31	; 49
    3eb4:	7d 93       	st	X+, r23
    3eb6:	70 e3       	ldi	r23, 0x30	; 48
    3eb8:	2a 95       	dec	r18
    3eba:	e1 f7       	brne	.-8      	; 0x3eb4 <__ftoa_engine+0x192>
    3ebc:	11 24       	eor	r1, r1
    3ebe:	ef 90       	pop	r14
    3ec0:	ff 90       	pop	r15
    3ec2:	0f 91       	pop	r16
    3ec4:	1f 91       	pop	r17
    3ec6:	cf 91       	pop	r28
    3ec8:	df 91       	pop	r29
    3eca:	99 27       	eor	r25, r25
    3ecc:	87 fd       	sbrc	r24, 7
    3ece:	90 95       	com	r25
    3ed0:	08 95       	ret

00003ed2 <strnlen_P>:
    3ed2:	fc 01       	movw	r30, r24
    3ed4:	05 90       	lpm	r0, Z+
    3ed6:	61 50       	subi	r22, 0x01	; 1
    3ed8:	70 40       	sbci	r23, 0x00	; 0
    3eda:	01 10       	cpse	r0, r1
    3edc:	d8 f7       	brcc	.-10     	; 0x3ed4 <strnlen_P+0x2>
    3ede:	80 95       	com	r24
    3ee0:	90 95       	com	r25
    3ee2:	8e 0f       	add	r24, r30
    3ee4:	9f 1f       	adc	r25, r31
    3ee6:	08 95       	ret

00003ee8 <strnlen>:
    3ee8:	fc 01       	movw	r30, r24
    3eea:	61 50       	subi	r22, 0x01	; 1
    3eec:	70 40       	sbci	r23, 0x00	; 0
    3eee:	01 90       	ld	r0, Z+
    3ef0:	01 10       	cpse	r0, r1
    3ef2:	d8 f7       	brcc	.-10     	; 0x3eea <strnlen+0x2>
    3ef4:	80 95       	com	r24
    3ef6:	90 95       	com	r25
    3ef8:	8e 0f       	add	r24, r30
    3efa:	9f 1f       	adc	r25, r31
    3efc:	08 95       	ret

00003efe <fdevopen>:
    3efe:	0f 93       	push	r16
    3f00:	1f 93       	push	r17
    3f02:	cf 93       	push	r28
    3f04:	df 93       	push	r29
    3f06:	00 97       	sbiw	r24, 0x00	; 0
    3f08:	31 f4       	brne	.+12     	; 0x3f16 <fdevopen+0x18>
    3f0a:	61 15       	cp	r22, r1
    3f0c:	71 05       	cpc	r23, r1
    3f0e:	19 f4       	brne	.+6      	; 0x3f16 <fdevopen+0x18>
    3f10:	80 e0       	ldi	r24, 0x00	; 0
    3f12:	90 e0       	ldi	r25, 0x00	; 0
    3f14:	39 c0       	rjmp	.+114    	; 0x3f88 <fdevopen+0x8a>
    3f16:	8b 01       	movw	r16, r22
    3f18:	ec 01       	movw	r28, r24
    3f1a:	6e e0       	ldi	r22, 0x0E	; 14
    3f1c:	70 e0       	ldi	r23, 0x00	; 0
    3f1e:	81 e0       	ldi	r24, 0x01	; 1
    3f20:	90 e0       	ldi	r25, 0x00	; 0
    3f22:	10 d1       	rcall	.+544    	; 0x4144 <calloc>
    3f24:	fc 01       	movw	r30, r24
    3f26:	89 2b       	or	r24, r25
    3f28:	99 f3       	breq	.-26     	; 0x3f10 <fdevopen+0x12>
    3f2a:	80 e8       	ldi	r24, 0x80	; 128
    3f2c:	83 83       	std	Z+3, r24	; 0x03
    3f2e:	01 15       	cp	r16, r1
    3f30:	11 05       	cpc	r17, r1
    3f32:	71 f0       	breq	.+28     	; 0x3f50 <fdevopen+0x52>
    3f34:	02 87       	std	Z+10, r16	; 0x0a
    3f36:	13 87       	std	Z+11, r17	; 0x0b
    3f38:	81 e8       	ldi	r24, 0x81	; 129
    3f3a:	83 83       	std	Z+3, r24	; 0x03
    3f3c:	80 91 db 20 	lds	r24, 0x20DB	; 0x8020db <__iob>
    3f40:	90 91 dc 20 	lds	r25, 0x20DC	; 0x8020dc <__iob+0x1>
    3f44:	89 2b       	or	r24, r25
    3f46:	21 f4       	brne	.+8      	; 0x3f50 <fdevopen+0x52>
    3f48:	e0 93 db 20 	sts	0x20DB, r30	; 0x8020db <__iob>
    3f4c:	f0 93 dc 20 	sts	0x20DC, r31	; 0x8020dc <__iob+0x1>
    3f50:	20 97       	sbiw	r28, 0x00	; 0
    3f52:	c9 f0       	breq	.+50     	; 0x3f86 <fdevopen+0x88>
    3f54:	c0 87       	std	Z+8, r28	; 0x08
    3f56:	d1 87       	std	Z+9, r29	; 0x09
    3f58:	83 81       	ldd	r24, Z+3	; 0x03
    3f5a:	82 60       	ori	r24, 0x02	; 2
    3f5c:	83 83       	std	Z+3, r24	; 0x03
    3f5e:	80 91 dd 20 	lds	r24, 0x20DD	; 0x8020dd <__iob+0x2>
    3f62:	90 91 de 20 	lds	r25, 0x20DE	; 0x8020de <__iob+0x3>
    3f66:	89 2b       	or	r24, r25
    3f68:	71 f4       	brne	.+28     	; 0x3f86 <fdevopen+0x88>
    3f6a:	e0 93 dd 20 	sts	0x20DD, r30	; 0x8020dd <__iob+0x2>
    3f6e:	f0 93 de 20 	sts	0x20DE, r31	; 0x8020de <__iob+0x3>
    3f72:	80 91 df 20 	lds	r24, 0x20DF	; 0x8020df <__iob+0x4>
    3f76:	90 91 e0 20 	lds	r25, 0x20E0	; 0x8020e0 <__iob+0x5>
    3f7a:	89 2b       	or	r24, r25
    3f7c:	21 f4       	brne	.+8      	; 0x3f86 <fdevopen+0x88>
    3f7e:	e0 93 df 20 	sts	0x20DF, r30	; 0x8020df <__iob+0x4>
    3f82:	f0 93 e0 20 	sts	0x20E0, r31	; 0x8020e0 <__iob+0x5>
    3f86:	cf 01       	movw	r24, r30
    3f88:	df 91       	pop	r29
    3f8a:	cf 91       	pop	r28
    3f8c:	1f 91       	pop	r17
    3f8e:	0f 91       	pop	r16
    3f90:	08 95       	ret

00003f92 <fputc>:
    3f92:	0f 93       	push	r16
    3f94:	1f 93       	push	r17
    3f96:	cf 93       	push	r28
    3f98:	df 93       	push	r29
    3f9a:	fb 01       	movw	r30, r22
    3f9c:	23 81       	ldd	r18, Z+3	; 0x03
    3f9e:	21 fd       	sbrc	r18, 1
    3fa0:	03 c0       	rjmp	.+6      	; 0x3fa8 <fputc+0x16>
    3fa2:	8f ef       	ldi	r24, 0xFF	; 255
    3fa4:	9f ef       	ldi	r25, 0xFF	; 255
    3fa6:	28 c0       	rjmp	.+80     	; 0x3ff8 <fputc+0x66>
    3fa8:	22 ff       	sbrs	r18, 2
    3faa:	16 c0       	rjmp	.+44     	; 0x3fd8 <fputc+0x46>
    3fac:	46 81       	ldd	r20, Z+6	; 0x06
    3fae:	57 81       	ldd	r21, Z+7	; 0x07
    3fb0:	24 81       	ldd	r18, Z+4	; 0x04
    3fb2:	35 81       	ldd	r19, Z+5	; 0x05
    3fb4:	42 17       	cp	r20, r18
    3fb6:	53 07       	cpc	r21, r19
    3fb8:	44 f4       	brge	.+16     	; 0x3fca <fputc+0x38>
    3fba:	a0 81       	ld	r26, Z
    3fbc:	b1 81       	ldd	r27, Z+1	; 0x01
    3fbe:	9d 01       	movw	r18, r26
    3fc0:	2f 5f       	subi	r18, 0xFF	; 255
    3fc2:	3f 4f       	sbci	r19, 0xFF	; 255
    3fc4:	20 83       	st	Z, r18
    3fc6:	31 83       	std	Z+1, r19	; 0x01
    3fc8:	8c 93       	st	X, r24
    3fca:	26 81       	ldd	r18, Z+6	; 0x06
    3fcc:	37 81       	ldd	r19, Z+7	; 0x07
    3fce:	2f 5f       	subi	r18, 0xFF	; 255
    3fd0:	3f 4f       	sbci	r19, 0xFF	; 255
    3fd2:	26 83       	std	Z+6, r18	; 0x06
    3fd4:	37 83       	std	Z+7, r19	; 0x07
    3fd6:	10 c0       	rjmp	.+32     	; 0x3ff8 <fputc+0x66>
    3fd8:	eb 01       	movw	r28, r22
    3fda:	09 2f       	mov	r16, r25
    3fdc:	18 2f       	mov	r17, r24
    3fde:	00 84       	ldd	r0, Z+8	; 0x08
    3fe0:	f1 85       	ldd	r31, Z+9	; 0x09
    3fe2:	e0 2d       	mov	r30, r0
    3fe4:	19 95       	eicall
    3fe6:	89 2b       	or	r24, r25
    3fe8:	e1 f6       	brne	.-72     	; 0x3fa2 <fputc+0x10>
    3fea:	8e 81       	ldd	r24, Y+6	; 0x06
    3fec:	9f 81       	ldd	r25, Y+7	; 0x07
    3fee:	01 96       	adiw	r24, 0x01	; 1
    3ff0:	8e 83       	std	Y+6, r24	; 0x06
    3ff2:	9f 83       	std	Y+7, r25	; 0x07
    3ff4:	81 2f       	mov	r24, r17
    3ff6:	90 2f       	mov	r25, r16
    3ff8:	df 91       	pop	r29
    3ffa:	cf 91       	pop	r28
    3ffc:	1f 91       	pop	r17
    3ffe:	0f 91       	pop	r16
    4000:	08 95       	ret

00004002 <printf>:
    4002:	cf 93       	push	r28
    4004:	df 93       	push	r29
    4006:	cd b7       	in	r28, 0x3d	; 61
    4008:	de b7       	in	r29, 0x3e	; 62
    400a:	ae 01       	movw	r20, r28
    400c:	4a 5f       	subi	r20, 0xFA	; 250
    400e:	5f 4f       	sbci	r21, 0xFF	; 255
    4010:	fa 01       	movw	r30, r20
    4012:	61 91       	ld	r22, Z+
    4014:	71 91       	ld	r23, Z+
    4016:	af 01       	movw	r20, r30
    4018:	80 91 dd 20 	lds	r24, 0x20DD	; 0x8020dd <__iob+0x2>
    401c:	90 91 de 20 	lds	r25, 0x20DE	; 0x8020de <__iob+0x3>
    4020:	fd d9       	rcall	.-3078   	; 0x341c <vfprintf>
    4022:	df 91       	pop	r29
    4024:	cf 91       	pop	r28
    4026:	08 95       	ret

00004028 <puts>:
    4028:	0f 93       	push	r16
    402a:	1f 93       	push	r17
    402c:	cf 93       	push	r28
    402e:	df 93       	push	r29
    4030:	e0 91 dd 20 	lds	r30, 0x20DD	; 0x8020dd <__iob+0x2>
    4034:	f0 91 de 20 	lds	r31, 0x20DE	; 0x8020de <__iob+0x3>
    4038:	23 81       	ldd	r18, Z+3	; 0x03
    403a:	21 ff       	sbrs	r18, 1
    403c:	1b c0       	rjmp	.+54     	; 0x4074 <puts+0x4c>
    403e:	8c 01       	movw	r16, r24
    4040:	d0 e0       	ldi	r29, 0x00	; 0
    4042:	c0 e0       	ldi	r28, 0x00	; 0
    4044:	f8 01       	movw	r30, r16
    4046:	81 91       	ld	r24, Z+
    4048:	8f 01       	movw	r16, r30
    404a:	60 91 dd 20 	lds	r22, 0x20DD	; 0x8020dd <__iob+0x2>
    404e:	70 91 de 20 	lds	r23, 0x20DE	; 0x8020de <__iob+0x3>
    4052:	db 01       	movw	r26, r22
    4054:	18 96       	adiw	r26, 0x08	; 8
    4056:	ed 91       	ld	r30, X+
    4058:	fc 91       	ld	r31, X
    405a:	19 97       	sbiw	r26, 0x09	; 9
    405c:	88 23       	and	r24, r24
    405e:	31 f0       	breq	.+12     	; 0x406c <puts+0x44>
    4060:	19 95       	eicall
    4062:	89 2b       	or	r24, r25
    4064:	79 f3       	breq	.-34     	; 0x4044 <puts+0x1c>
    4066:	df ef       	ldi	r29, 0xFF	; 255
    4068:	cf ef       	ldi	r28, 0xFF	; 255
    406a:	ec cf       	rjmp	.-40     	; 0x4044 <puts+0x1c>
    406c:	8a e0       	ldi	r24, 0x0A	; 10
    406e:	19 95       	eicall
    4070:	89 2b       	or	r24, r25
    4072:	19 f0       	breq	.+6      	; 0x407a <puts+0x52>
    4074:	8f ef       	ldi	r24, 0xFF	; 255
    4076:	9f ef       	ldi	r25, 0xFF	; 255
    4078:	02 c0       	rjmp	.+4      	; 0x407e <puts+0x56>
    407a:	8d 2f       	mov	r24, r29
    407c:	9c 2f       	mov	r25, r28
    407e:	df 91       	pop	r29
    4080:	cf 91       	pop	r28
    4082:	1f 91       	pop	r17
    4084:	0f 91       	pop	r16
    4086:	08 95       	ret

00004088 <__ultoa_invert>:
    4088:	fa 01       	movw	r30, r20
    408a:	aa 27       	eor	r26, r26
    408c:	28 30       	cpi	r18, 0x08	; 8
    408e:	51 f1       	breq	.+84     	; 0x40e4 <__ultoa_invert+0x5c>
    4090:	20 31       	cpi	r18, 0x10	; 16
    4092:	81 f1       	breq	.+96     	; 0x40f4 <__ultoa_invert+0x6c>
    4094:	e8 94       	clt
    4096:	6f 93       	push	r22
    4098:	6e 7f       	andi	r22, 0xFE	; 254
    409a:	6e 5f       	subi	r22, 0xFE	; 254
    409c:	7f 4f       	sbci	r23, 0xFF	; 255
    409e:	8f 4f       	sbci	r24, 0xFF	; 255
    40a0:	9f 4f       	sbci	r25, 0xFF	; 255
    40a2:	af 4f       	sbci	r26, 0xFF	; 255
    40a4:	b1 e0       	ldi	r27, 0x01	; 1
    40a6:	3e d0       	rcall	.+124    	; 0x4124 <__ultoa_invert+0x9c>
    40a8:	b4 e0       	ldi	r27, 0x04	; 4
    40aa:	3c d0       	rcall	.+120    	; 0x4124 <__ultoa_invert+0x9c>
    40ac:	67 0f       	add	r22, r23
    40ae:	78 1f       	adc	r23, r24
    40b0:	89 1f       	adc	r24, r25
    40b2:	9a 1f       	adc	r25, r26
    40b4:	a1 1d       	adc	r26, r1
    40b6:	68 0f       	add	r22, r24
    40b8:	79 1f       	adc	r23, r25
    40ba:	8a 1f       	adc	r24, r26
    40bc:	91 1d       	adc	r25, r1
    40be:	a1 1d       	adc	r26, r1
    40c0:	6a 0f       	add	r22, r26
    40c2:	71 1d       	adc	r23, r1
    40c4:	81 1d       	adc	r24, r1
    40c6:	91 1d       	adc	r25, r1
    40c8:	a1 1d       	adc	r26, r1
    40ca:	20 d0       	rcall	.+64     	; 0x410c <__ultoa_invert+0x84>
    40cc:	09 f4       	brne	.+2      	; 0x40d0 <__ultoa_invert+0x48>
    40ce:	68 94       	set
    40d0:	3f 91       	pop	r19
    40d2:	2a e0       	ldi	r18, 0x0A	; 10
    40d4:	26 9f       	mul	r18, r22
    40d6:	11 24       	eor	r1, r1
    40d8:	30 19       	sub	r19, r0
    40da:	30 5d       	subi	r19, 0xD0	; 208
    40dc:	31 93       	st	Z+, r19
    40de:	de f6       	brtc	.-74     	; 0x4096 <__ultoa_invert+0xe>
    40e0:	cf 01       	movw	r24, r30
    40e2:	08 95       	ret
    40e4:	46 2f       	mov	r20, r22
    40e6:	47 70       	andi	r20, 0x07	; 7
    40e8:	40 5d       	subi	r20, 0xD0	; 208
    40ea:	41 93       	st	Z+, r20
    40ec:	b3 e0       	ldi	r27, 0x03	; 3
    40ee:	0f d0       	rcall	.+30     	; 0x410e <__ultoa_invert+0x86>
    40f0:	c9 f7       	brne	.-14     	; 0x40e4 <__ultoa_invert+0x5c>
    40f2:	f6 cf       	rjmp	.-20     	; 0x40e0 <__ultoa_invert+0x58>
    40f4:	46 2f       	mov	r20, r22
    40f6:	4f 70       	andi	r20, 0x0F	; 15
    40f8:	40 5d       	subi	r20, 0xD0	; 208
    40fa:	4a 33       	cpi	r20, 0x3A	; 58
    40fc:	18 f0       	brcs	.+6      	; 0x4104 <__ultoa_invert+0x7c>
    40fe:	49 5d       	subi	r20, 0xD9	; 217
    4100:	31 fd       	sbrc	r19, 1
    4102:	40 52       	subi	r20, 0x20	; 32
    4104:	41 93       	st	Z+, r20
    4106:	02 d0       	rcall	.+4      	; 0x410c <__ultoa_invert+0x84>
    4108:	a9 f7       	brne	.-22     	; 0x40f4 <__ultoa_invert+0x6c>
    410a:	ea cf       	rjmp	.-44     	; 0x40e0 <__ultoa_invert+0x58>
    410c:	b4 e0       	ldi	r27, 0x04	; 4
    410e:	a6 95       	lsr	r26
    4110:	97 95       	ror	r25
    4112:	87 95       	ror	r24
    4114:	77 95       	ror	r23
    4116:	67 95       	ror	r22
    4118:	ba 95       	dec	r27
    411a:	c9 f7       	brne	.-14     	; 0x410e <__ultoa_invert+0x86>
    411c:	00 97       	sbiw	r24, 0x00	; 0
    411e:	61 05       	cpc	r22, r1
    4120:	71 05       	cpc	r23, r1
    4122:	08 95       	ret
    4124:	9b 01       	movw	r18, r22
    4126:	ac 01       	movw	r20, r24
    4128:	0a 2e       	mov	r0, r26
    412a:	06 94       	lsr	r0
    412c:	57 95       	ror	r21
    412e:	47 95       	ror	r20
    4130:	37 95       	ror	r19
    4132:	27 95       	ror	r18
    4134:	ba 95       	dec	r27
    4136:	c9 f7       	brne	.-14     	; 0x412a <__ultoa_invert+0xa2>
    4138:	62 0f       	add	r22, r18
    413a:	73 1f       	adc	r23, r19
    413c:	84 1f       	adc	r24, r20
    413e:	95 1f       	adc	r25, r21
    4140:	a0 1d       	adc	r26, r0
    4142:	08 95       	ret

00004144 <calloc>:
    4144:	0f 93       	push	r16
    4146:	1f 93       	push	r17
    4148:	cf 93       	push	r28
    414a:	df 93       	push	r29
    414c:	86 9f       	mul	r24, r22
    414e:	80 01       	movw	r16, r0
    4150:	87 9f       	mul	r24, r23
    4152:	10 0d       	add	r17, r0
    4154:	96 9f       	mul	r25, r22
    4156:	10 0d       	add	r17, r0
    4158:	11 24       	eor	r1, r1
    415a:	c8 01       	movw	r24, r16
    415c:	0d d0       	rcall	.+26     	; 0x4178 <malloc>
    415e:	ec 01       	movw	r28, r24
    4160:	00 97       	sbiw	r24, 0x00	; 0
    4162:	21 f0       	breq	.+8      	; 0x416c <calloc+0x28>
    4164:	a8 01       	movw	r20, r16
    4166:	60 e0       	ldi	r22, 0x00	; 0
    4168:	70 e0       	ldi	r23, 0x00	; 0
    416a:	33 d1       	rcall	.+614    	; 0x43d2 <memset>
    416c:	ce 01       	movw	r24, r28
    416e:	df 91       	pop	r29
    4170:	cf 91       	pop	r28
    4172:	1f 91       	pop	r17
    4174:	0f 91       	pop	r16
    4176:	08 95       	ret

00004178 <malloc>:
    4178:	cf 93       	push	r28
    417a:	df 93       	push	r29
    417c:	82 30       	cpi	r24, 0x02	; 2
    417e:	91 05       	cpc	r25, r1
    4180:	10 f4       	brcc	.+4      	; 0x4186 <malloc+0xe>
    4182:	82 e0       	ldi	r24, 0x02	; 2
    4184:	90 e0       	ldi	r25, 0x00	; 0
    4186:	e0 91 e3 20 	lds	r30, 0x20E3	; 0x8020e3 <__flp>
    418a:	f0 91 e4 20 	lds	r31, 0x20E4	; 0x8020e4 <__flp+0x1>
    418e:	20 e0       	ldi	r18, 0x00	; 0
    4190:	30 e0       	ldi	r19, 0x00	; 0
    4192:	c0 e0       	ldi	r28, 0x00	; 0
    4194:	d0 e0       	ldi	r29, 0x00	; 0
    4196:	30 97       	sbiw	r30, 0x00	; 0
    4198:	11 f1       	breq	.+68     	; 0x41de <malloc+0x66>
    419a:	40 81       	ld	r20, Z
    419c:	51 81       	ldd	r21, Z+1	; 0x01
    419e:	48 17       	cp	r20, r24
    41a0:	59 07       	cpc	r21, r25
    41a2:	c0 f0       	brcs	.+48     	; 0x41d4 <malloc+0x5c>
    41a4:	48 17       	cp	r20, r24
    41a6:	59 07       	cpc	r21, r25
    41a8:	61 f4       	brne	.+24     	; 0x41c2 <malloc+0x4a>
    41aa:	82 81       	ldd	r24, Z+2	; 0x02
    41ac:	93 81       	ldd	r25, Z+3	; 0x03
    41ae:	20 97       	sbiw	r28, 0x00	; 0
    41b0:	19 f0       	breq	.+6      	; 0x41b8 <malloc+0x40>
    41b2:	8a 83       	std	Y+2, r24	; 0x02
    41b4:	9b 83       	std	Y+3, r25	; 0x03
    41b6:	2b c0       	rjmp	.+86     	; 0x420e <malloc+0x96>
    41b8:	80 93 e3 20 	sts	0x20E3, r24	; 0x8020e3 <__flp>
    41bc:	90 93 e4 20 	sts	0x20E4, r25	; 0x8020e4 <__flp+0x1>
    41c0:	26 c0       	rjmp	.+76     	; 0x420e <malloc+0x96>
    41c2:	21 15       	cp	r18, r1
    41c4:	31 05       	cpc	r19, r1
    41c6:	19 f0       	breq	.+6      	; 0x41ce <malloc+0x56>
    41c8:	42 17       	cp	r20, r18
    41ca:	53 07       	cpc	r21, r19
    41cc:	18 f4       	brcc	.+6      	; 0x41d4 <malloc+0x5c>
    41ce:	9a 01       	movw	r18, r20
    41d0:	be 01       	movw	r22, r28
    41d2:	df 01       	movw	r26, r30
    41d4:	ef 01       	movw	r28, r30
    41d6:	02 80       	ldd	r0, Z+2	; 0x02
    41d8:	f3 81       	ldd	r31, Z+3	; 0x03
    41da:	e0 2d       	mov	r30, r0
    41dc:	dc cf       	rjmp	.-72     	; 0x4196 <malloc+0x1e>
    41de:	21 15       	cp	r18, r1
    41e0:	31 05       	cpc	r19, r1
    41e2:	09 f1       	breq	.+66     	; 0x4226 <malloc+0xae>
    41e4:	28 1b       	sub	r18, r24
    41e6:	39 0b       	sbc	r19, r25
    41e8:	24 30       	cpi	r18, 0x04	; 4
    41ea:	31 05       	cpc	r19, r1
    41ec:	90 f4       	brcc	.+36     	; 0x4212 <malloc+0x9a>
    41ee:	12 96       	adiw	r26, 0x02	; 2
    41f0:	8d 91       	ld	r24, X+
    41f2:	9c 91       	ld	r25, X
    41f4:	13 97       	sbiw	r26, 0x03	; 3
    41f6:	61 15       	cp	r22, r1
    41f8:	71 05       	cpc	r23, r1
    41fa:	21 f0       	breq	.+8      	; 0x4204 <malloc+0x8c>
    41fc:	fb 01       	movw	r30, r22
    41fe:	82 83       	std	Z+2, r24	; 0x02
    4200:	93 83       	std	Z+3, r25	; 0x03
    4202:	04 c0       	rjmp	.+8      	; 0x420c <malloc+0x94>
    4204:	80 93 e3 20 	sts	0x20E3, r24	; 0x8020e3 <__flp>
    4208:	90 93 e4 20 	sts	0x20E4, r25	; 0x8020e4 <__flp+0x1>
    420c:	fd 01       	movw	r30, r26
    420e:	32 96       	adiw	r30, 0x02	; 2
    4210:	44 c0       	rjmp	.+136    	; 0x429a <malloc+0x122>
    4212:	fd 01       	movw	r30, r26
    4214:	e2 0f       	add	r30, r18
    4216:	f3 1f       	adc	r31, r19
    4218:	81 93       	st	Z+, r24
    421a:	91 93       	st	Z+, r25
    421c:	22 50       	subi	r18, 0x02	; 2
    421e:	31 09       	sbc	r19, r1
    4220:	2d 93       	st	X+, r18
    4222:	3c 93       	st	X, r19
    4224:	3a c0       	rjmp	.+116    	; 0x429a <malloc+0x122>
    4226:	20 91 e1 20 	lds	r18, 0x20E1	; 0x8020e1 <__brkval>
    422a:	30 91 e2 20 	lds	r19, 0x20E2	; 0x8020e2 <__brkval+0x1>
    422e:	23 2b       	or	r18, r19
    4230:	41 f4       	brne	.+16     	; 0x4242 <malloc+0xca>
    4232:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    4236:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    423a:	20 93 e1 20 	sts	0x20E1, r18	; 0x8020e1 <__brkval>
    423e:	30 93 e2 20 	sts	0x20E2, r19	; 0x8020e2 <__brkval+0x1>
    4242:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    4246:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    424a:	21 15       	cp	r18, r1
    424c:	31 05       	cpc	r19, r1
    424e:	41 f4       	brne	.+16     	; 0x4260 <malloc+0xe8>
    4250:	2d b7       	in	r18, 0x3d	; 61
    4252:	3e b7       	in	r19, 0x3e	; 62
    4254:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    4258:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    425c:	24 1b       	sub	r18, r20
    425e:	35 0b       	sbc	r19, r21
    4260:	e0 91 e1 20 	lds	r30, 0x20E1	; 0x8020e1 <__brkval>
    4264:	f0 91 e2 20 	lds	r31, 0x20E2	; 0x8020e2 <__brkval+0x1>
    4268:	e2 17       	cp	r30, r18
    426a:	f3 07       	cpc	r31, r19
    426c:	a0 f4       	brcc	.+40     	; 0x4296 <malloc+0x11e>
    426e:	2e 1b       	sub	r18, r30
    4270:	3f 0b       	sbc	r19, r31
    4272:	28 17       	cp	r18, r24
    4274:	39 07       	cpc	r19, r25
    4276:	78 f0       	brcs	.+30     	; 0x4296 <malloc+0x11e>
    4278:	ac 01       	movw	r20, r24
    427a:	4e 5f       	subi	r20, 0xFE	; 254
    427c:	5f 4f       	sbci	r21, 0xFF	; 255
    427e:	24 17       	cp	r18, r20
    4280:	35 07       	cpc	r19, r21
    4282:	48 f0       	brcs	.+18     	; 0x4296 <malloc+0x11e>
    4284:	4e 0f       	add	r20, r30
    4286:	5f 1f       	adc	r21, r31
    4288:	40 93 e1 20 	sts	0x20E1, r20	; 0x8020e1 <__brkval>
    428c:	50 93 e2 20 	sts	0x20E2, r21	; 0x8020e2 <__brkval+0x1>
    4290:	81 93       	st	Z+, r24
    4292:	91 93       	st	Z+, r25
    4294:	02 c0       	rjmp	.+4      	; 0x429a <malloc+0x122>
    4296:	e0 e0       	ldi	r30, 0x00	; 0
    4298:	f0 e0       	ldi	r31, 0x00	; 0
    429a:	cf 01       	movw	r24, r30
    429c:	df 91       	pop	r29
    429e:	cf 91       	pop	r28
    42a0:	08 95       	ret

000042a2 <free>:
    42a2:	0f 93       	push	r16
    42a4:	1f 93       	push	r17
    42a6:	cf 93       	push	r28
    42a8:	df 93       	push	r29
    42aa:	00 97       	sbiw	r24, 0x00	; 0
    42ac:	09 f4       	brne	.+2      	; 0x42b0 <free+0xe>
    42ae:	8c c0       	rjmp	.+280    	; 0x43c8 <free+0x126>
    42b0:	fc 01       	movw	r30, r24
    42b2:	32 97       	sbiw	r30, 0x02	; 2
    42b4:	12 82       	std	Z+2, r1	; 0x02
    42b6:	13 82       	std	Z+3, r1	; 0x03
    42b8:	00 91 e3 20 	lds	r16, 0x20E3	; 0x8020e3 <__flp>
    42bc:	10 91 e4 20 	lds	r17, 0x20E4	; 0x8020e4 <__flp+0x1>
    42c0:	01 15       	cp	r16, r1
    42c2:	11 05       	cpc	r17, r1
    42c4:	81 f4       	brne	.+32     	; 0x42e6 <free+0x44>
    42c6:	20 81       	ld	r18, Z
    42c8:	31 81       	ldd	r19, Z+1	; 0x01
    42ca:	82 0f       	add	r24, r18
    42cc:	93 1f       	adc	r25, r19
    42ce:	20 91 e1 20 	lds	r18, 0x20E1	; 0x8020e1 <__brkval>
    42d2:	30 91 e2 20 	lds	r19, 0x20E2	; 0x8020e2 <__brkval+0x1>
    42d6:	28 17       	cp	r18, r24
    42d8:	39 07       	cpc	r19, r25
    42da:	79 f5       	brne	.+94     	; 0x433a <free+0x98>
    42dc:	e0 93 e1 20 	sts	0x20E1, r30	; 0x8020e1 <__brkval>
    42e0:	f0 93 e2 20 	sts	0x20E2, r31	; 0x8020e2 <__brkval+0x1>
    42e4:	71 c0       	rjmp	.+226    	; 0x43c8 <free+0x126>
    42e6:	d8 01       	movw	r26, r16
    42e8:	40 e0       	ldi	r20, 0x00	; 0
    42ea:	50 e0       	ldi	r21, 0x00	; 0
    42ec:	ae 17       	cp	r26, r30
    42ee:	bf 07       	cpc	r27, r31
    42f0:	50 f4       	brcc	.+20     	; 0x4306 <free+0x64>
    42f2:	12 96       	adiw	r26, 0x02	; 2
    42f4:	2d 91       	ld	r18, X+
    42f6:	3c 91       	ld	r19, X
    42f8:	13 97       	sbiw	r26, 0x03	; 3
    42fa:	ad 01       	movw	r20, r26
    42fc:	21 15       	cp	r18, r1
    42fe:	31 05       	cpc	r19, r1
    4300:	09 f1       	breq	.+66     	; 0x4344 <free+0xa2>
    4302:	d9 01       	movw	r26, r18
    4304:	f3 cf       	rjmp	.-26     	; 0x42ec <free+0x4a>
    4306:	9d 01       	movw	r18, r26
    4308:	da 01       	movw	r26, r20
    430a:	22 83       	std	Z+2, r18	; 0x02
    430c:	33 83       	std	Z+3, r19	; 0x03
    430e:	60 81       	ld	r22, Z
    4310:	71 81       	ldd	r23, Z+1	; 0x01
    4312:	86 0f       	add	r24, r22
    4314:	97 1f       	adc	r25, r23
    4316:	82 17       	cp	r24, r18
    4318:	93 07       	cpc	r25, r19
    431a:	69 f4       	brne	.+26     	; 0x4336 <free+0x94>
    431c:	ec 01       	movw	r28, r24
    431e:	28 81       	ld	r18, Y
    4320:	39 81       	ldd	r19, Y+1	; 0x01
    4322:	26 0f       	add	r18, r22
    4324:	37 1f       	adc	r19, r23
    4326:	2e 5f       	subi	r18, 0xFE	; 254
    4328:	3f 4f       	sbci	r19, 0xFF	; 255
    432a:	20 83       	st	Z, r18
    432c:	31 83       	std	Z+1, r19	; 0x01
    432e:	8a 81       	ldd	r24, Y+2	; 0x02
    4330:	9b 81       	ldd	r25, Y+3	; 0x03
    4332:	82 83       	std	Z+2, r24	; 0x02
    4334:	93 83       	std	Z+3, r25	; 0x03
    4336:	45 2b       	or	r20, r21
    4338:	29 f4       	brne	.+10     	; 0x4344 <free+0xa2>
    433a:	e0 93 e3 20 	sts	0x20E3, r30	; 0x8020e3 <__flp>
    433e:	f0 93 e4 20 	sts	0x20E4, r31	; 0x8020e4 <__flp+0x1>
    4342:	42 c0       	rjmp	.+132    	; 0x43c8 <free+0x126>
    4344:	12 96       	adiw	r26, 0x02	; 2
    4346:	ed 93       	st	X+, r30
    4348:	fc 93       	st	X, r31
    434a:	13 97       	sbiw	r26, 0x03	; 3
    434c:	ed 01       	movw	r28, r26
    434e:	49 91       	ld	r20, Y+
    4350:	59 91       	ld	r21, Y+
    4352:	9e 01       	movw	r18, r28
    4354:	24 0f       	add	r18, r20
    4356:	35 1f       	adc	r19, r21
    4358:	e2 17       	cp	r30, r18
    435a:	f3 07       	cpc	r31, r19
    435c:	71 f4       	brne	.+28     	; 0x437a <free+0xd8>
    435e:	80 81       	ld	r24, Z
    4360:	91 81       	ldd	r25, Z+1	; 0x01
    4362:	84 0f       	add	r24, r20
    4364:	95 1f       	adc	r25, r21
    4366:	02 96       	adiw	r24, 0x02	; 2
    4368:	8d 93       	st	X+, r24
    436a:	9c 93       	st	X, r25
    436c:	11 97       	sbiw	r26, 0x01	; 1
    436e:	82 81       	ldd	r24, Z+2	; 0x02
    4370:	93 81       	ldd	r25, Z+3	; 0x03
    4372:	12 96       	adiw	r26, 0x02	; 2
    4374:	8d 93       	st	X+, r24
    4376:	9c 93       	st	X, r25
    4378:	13 97       	sbiw	r26, 0x03	; 3
    437a:	e0 e0       	ldi	r30, 0x00	; 0
    437c:	f0 e0       	ldi	r31, 0x00	; 0
    437e:	d8 01       	movw	r26, r16
    4380:	12 96       	adiw	r26, 0x02	; 2
    4382:	8d 91       	ld	r24, X+
    4384:	9c 91       	ld	r25, X
    4386:	13 97       	sbiw	r26, 0x03	; 3
    4388:	00 97       	sbiw	r24, 0x00	; 0
    438a:	19 f0       	breq	.+6      	; 0x4392 <free+0xf0>
    438c:	f8 01       	movw	r30, r16
    438e:	8c 01       	movw	r16, r24
    4390:	f6 cf       	rjmp	.-20     	; 0x437e <free+0xdc>
    4392:	8d 91       	ld	r24, X+
    4394:	9c 91       	ld	r25, X
    4396:	98 01       	movw	r18, r16
    4398:	2e 5f       	subi	r18, 0xFE	; 254
    439a:	3f 4f       	sbci	r19, 0xFF	; 255
    439c:	82 0f       	add	r24, r18
    439e:	93 1f       	adc	r25, r19
    43a0:	20 91 e1 20 	lds	r18, 0x20E1	; 0x8020e1 <__brkval>
    43a4:	30 91 e2 20 	lds	r19, 0x20E2	; 0x8020e2 <__brkval+0x1>
    43a8:	28 17       	cp	r18, r24
    43aa:	39 07       	cpc	r19, r25
    43ac:	69 f4       	brne	.+26     	; 0x43c8 <free+0x126>
    43ae:	30 97       	sbiw	r30, 0x00	; 0
    43b0:	29 f4       	brne	.+10     	; 0x43bc <free+0x11a>
    43b2:	10 92 e3 20 	sts	0x20E3, r1	; 0x8020e3 <__flp>
    43b6:	10 92 e4 20 	sts	0x20E4, r1	; 0x8020e4 <__flp+0x1>
    43ba:	02 c0       	rjmp	.+4      	; 0x43c0 <free+0x11e>
    43bc:	12 82       	std	Z+2, r1	; 0x02
    43be:	13 82       	std	Z+3, r1	; 0x03
    43c0:	00 93 e1 20 	sts	0x20E1, r16	; 0x8020e1 <__brkval>
    43c4:	10 93 e2 20 	sts	0x20E2, r17	; 0x8020e2 <__brkval+0x1>
    43c8:	df 91       	pop	r29
    43ca:	cf 91       	pop	r28
    43cc:	1f 91       	pop	r17
    43ce:	0f 91       	pop	r16
    43d0:	08 95       	ret

000043d2 <memset>:
    43d2:	dc 01       	movw	r26, r24
    43d4:	01 c0       	rjmp	.+2      	; 0x43d8 <memset+0x6>
    43d6:	6d 93       	st	X+, r22
    43d8:	41 50       	subi	r20, 0x01	; 1
    43da:	50 40       	sbci	r21, 0x00	; 0
    43dc:	e0 f7       	brcc	.-8      	; 0x43d6 <memset+0x4>
    43de:	08 95       	ret

000043e0 <_exit>:
    43e0:	f8 94       	cli

000043e2 <__stop_program>:
    43e2:	ff cf       	rjmp	.-2      	; 0x43e2 <__stop_program>
